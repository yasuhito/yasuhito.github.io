<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Notes on Notes</title>
		<link>https://yasuhito.github.io/</link>
		<description>Recent content in Notes </description>
		<generator>Hugo -- gohugo.io</generator>
		
  		<language>ja</language>
		
		<managingEditor>Page(&#34;Notes&#34;) (Yasuhito Takamiya)</managingEditor>
    	
  		<lastBuildDate>Mon, 22 Mar 2021 00:00:00 +0900</lastBuildDate>
		
		<atom:link href="/" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Comm</title>
			<link>https://yasuhito.github.io/post/20210322140545-comm/</link>
			<pubDate>Mon, 22 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210322140545-comm/</guid>
			<description>Comm は Commutativity (可換性) の略。図式的線形代数では足し算を扱うので、単に Comm と書いた場合それは足し算の可換性を表す。
図式で足し算の可換性を表すと次のようになる。
  これが正しいことは、変数 \(x\), \(y\) を使うことで次のように示せる。
Comm の左辺に \(x\) と \(y\) を入力すると、
  Comm の右辺に \(x\) と \(y\) を入力すると、
  ここで足し算の可換性より \(x + y = y + x\) だから、
  が成り立つ。</description>
		</item>
      	
		<item>
			<title>図式的線形代数</title>
			<link>https://yasuhito.github.io/post/20210322104014-%E5%9B%B3%E5%BC%8F%E7%9A%84%E7%B7%9A%E5%BD%A2%E4%BB%A3%E6%95%B0/</link>
			<pubDate>Mon, 22 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210322104014-%E5%9B%B3%E5%BC%8F%E7%9A%84%E7%B7%9A%E5%BD%A2%E4%BB%A3%E6%95%B0/</guid>
			<description>https://graphicallinearalgebra.net/
 Comm  </description>
		</item>
      	
		<item>
			<title>void</title>
			<link>https://yasuhito.github.io/post/20210320155430-void/</link>
			<pubDate>Sat, 20 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210320155430-void/</guid>
			<description>return 文を含まない関数の戻り値の型はなんでしょうか?
TypeScript では、そういう関数の戻り値の型は void です。あえて型エラーを起こしてエラーメッセージを見ればわかります。
function f() { } const n: number = f(); // → type error: Type &amp;#39;void&amp;#39; is not assignable to type &amp;#39;number&amp;#39;. void の使いみちは、明示的に何も返さない関数を表現したい場合です。たとえば console.log はその一例です。
void 型は、値を一切持たないことを示します。他の多くの静的言語では、例外はなく、 void は本当に値を持つことはできません。しかし、TypeScript では不思議なことに、 void 型の変数を作ることができます。この変数には undefined という値しか入りません。
const aVoid: void = undefined; // → undefined だからといって、その void を undefined 型の変数に代入できるわけではありません。 void は何にも代入できないので、型エラーになります。
const aVoid: void = undefined; const u: undefined = aVoid; // → type error: Type &amp;#39;void&amp;#39; is not assignable to type &amp;#39;undefined&amp;#39;.</description>
		</item>
      	
		<item>
			<title>プログラミング学習の SRS 化</title>
			<link>https://yasuhito.github.io/post/20210320161559-%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF%E5%AD%A6%E7%BF%92%E3%81%AE_srs_%E5%8C%96/</link>
			<pubDate>Sat, 20 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210320161559-%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF%E5%AD%A6%E7%BF%92%E3%81%AE_srs_%E5%8C%96/</guid>
			<description>SRS の回答方式による効果の違いを確認するために、Execute Program を参考にいくつかレッスンを作り、Anki カードを起こしてみる。
  void never  </description>
		</item>
      	
		<item>
			<title>Anki</title>
			<link>https://yasuhito.github.io/post/20210319115727-anki/</link>
			<pubDate>Fri, 19 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210319115727-anki/</guid>
			<description>https://apps.ankiweb.net/
人気のある SRS の一種。</description>
		</item>
      	
		<item>
			<title>Duolingo</title>
			<link>https://yasuhito.github.io/post/20210319132742-duolingo/</link>
			<pubDate>Fri, 19 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210319132742-duolingo/</guid>
			<description>https://en.duolingo.com/
世界で最も人気のある外国語学習サービス。単語や文法の学習に SRS を採用している。
SRS として見たときの Duolingo のユニークな点 (たとえばExecute Program との違い) は、すべての学習がカードのみで完結しているところ。Execute Program ではプログラミング言語の解説を読みながらクイズに答えていく。一方で Duolingo では外国語に対する知識ゼロの状態からいきなりクイズが始まり、正解/不正解を繰り返しながら (試行錯誤を繰り返しながら) 外国語を学んでいくことができる。
外国語学習の場合、文法や単語の説明を読むのはダルい/集中力が続かないという人が圧倒的に多いはずなので、正式な学習法と比べてどのくらい効果があるかどうかは分からないが、ひとつの妥当なデザインチョイスだと思う。</description>
		</item>
      	
		<item>
			<title>SRS の回答方式による効果の違い</title>
			<link>https://yasuhito.github.io/post/20210319113717-srs_%E3%81%AE%E5%9B%9E%E7%AD%94%E6%96%B9%E5%BC%8F%E3%81%AB%E3%82%88%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%AE%E9%81%95%E3%81%84/</link>
			<pubDate>Fri, 19 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210319113717-srs_%E3%81%AE%E5%9B%9E%E7%AD%94%E6%96%B9%E5%BC%8F%E3%81%AB%E3%82%88%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%AE%E9%81%95%E3%81%84/</guid>
			<description>SRS のユーザ回答方式には、Anki のようにユーザが裏面を見て自分で答合わせをする方式と、Duolingo や Execute Program のようにユーザが入力した答をシステムが答合わせする方式の 2 つがある。どちらが記憶効果が高いだろうか？
この論文 (Probabilistic Models of Student Learning and Forgetting) では実験から次のことを導き出している:
 ひとつひとつの単体のレビューの効果については、ユーザが入力する方式の方が効果が高い 長期的な効果については、入力のためのタイピングにはかなり時間がかかるため、自分で答合わせをする方式のほうがレビューを多くこなせ、結果的に効果が高くなる  </description>
		</item>
      	
		<item>
			<title>never</title>
			<link>https://yasuhito.github.io/post/20210318110047-never/</link>
			<pubDate>Thu, 18 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210318110047-never/</guid>
			<description>関数の中には、決して戻らないものがあります。例えば、常に例外を投げる関数は決して戻りません。
// この関数は戻らない function throws() { throw new Error(&amp;#39;oh no&amp;#39;); } この関数の戻り値の型はどうすればよいでしょうか？ TypeScript は、この関数の戻り値の型を void と推論します。しかし、それではコードで何が起こっているのかをコンパイラは完全には把握できていません。
void 型は、何らかの処理を行い終了するが、値を返さない関数のための型です。上の関数はこれとは異なり、この関数を呼び出しても、その後のコードは全く実行されません。
幸いなことに、TypeScript にはそのための型があります: never です。
// 戻らない関数の返り値は never と指定する function throws(): never { throw new Error(&amp;#39;oh no&amp;#39;); } never 型はちょっと不思議です。他のどの型にも割り当て可能です1。例えば、 number 型の変数に割り当てることができます (ただし、実行すると例外が投げられます)。
function throws(): never { throw new Error(&amp;#39;oh no&amp;#39;); } // never はどんな型にも割り当てられる const n: number = throws(); // → Error: oh no 最初は、 never が any のように振る舞っているように見えます。なぜなら、 never を number （または string 、その他何でも）に割り当てることができるからです。しかし、 any と違って、これは安全です。</description>
		</item>
      	
		<item>
			<title>デジタル・ガーデン</title>
			<link>https://yasuhito.github.io/post/20210318171123-%E3%83%86%E3%82%B7%E3%82%BF%E3%83%AB_%E3%82%AB%E3%83%BC%E3%83%86%E3%83%B3/</link>
			<pubDate>Thu, 18 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210318171123-%E3%83%86%E3%82%B7%E3%82%BF%E3%83%AB_%E3%82%AB%E3%83%BC%E3%83%86%E3%83%B3/</guid>
			<description>個人的なメモをインターネット上に公開したもの。多くの場合はメモ間にリンクが貼ってあり、Wiki のように関連するメモを読むことができる。
一般的な作り方としては、Roam Research や Obsidian といった個人用のメモツールで書いたメモを外部ツールでインターネット上に公開する場合が多い。
 MaggieAppleton/digital-gardeners デジタル・ガーデン用ツール、作りかたチュートリアル、各種ノート法などの基礎知識、個別のデジタル・ガーデンサイトへのリンク集 Andyʼs working notes デジタル・ガーデン流行の火付け役となったサイトであり、多くの人がお手本にしている Andy Matuschak のサイト 効率的なノートを作成できるドイツの社会学者が生み出した方法「Zettelkasten」とは？ ノート法の一種で、多くのデジタル・ガーデンはこの方法に則って書かれている  </description>
		</item>
      	
		<item>
			<title>スカラー行列</title>
			<link>https://yasuhito.github.io/post/20210317113230-%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC%E8%A1%8C%E5%88%97/</link>
			<pubDate>Wed, 17 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210317113230-%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC%E8%A1%8C%E5%88%97/</guid>
			<description>単位行列の定数倍をスカラー行列という。
たとえば、
\[\begin{bmatrix} \lambda &amp;amp; 0 &amp;amp; 0 \\\
0 &amp;amp; \lambda &amp;amp; 0 \\\
0 &amp;amp; 0 &amp;amp; \lambda \end{bmatrix}\]
はスカラー行列である。</description>
		</item>
      	
	</channel>
</rss>
