<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes</title>
    <link>https://yasuhito.github.io/</link>
    <description>Recent content on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Yasuhito Takamiya</copyright>
    <lastBuildDate>Wed, 17 Mar 2021 00:00:00 +0900</lastBuildDate><atom:link href="https://yasuhito.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>スカラー行列</title>
      <link>https://yasuhito.github.io/posts/20210317113230-%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC%E8%A1%8C%E5%88%97/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210317113230-%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC%E8%A1%8C%E5%88%97/</guid>
      <description>単位行列の定数倍をスカラー行列という。
たとえば、
\[\begin{bmatrix} \lambda &amp;amp; 0 &amp;amp; 0 \\\
0 &amp;amp; \lambda &amp;amp; 0 \\\
0 &amp;amp; 0 &amp;amp; \lambda \end{bmatrix}\]
はスカラー行列である。</description>
    </item>
    
    <item>
      <title>対角行列</title>
      <link>https://yasuhito.github.io/posts/20210317101558-%E5%AF%BE%E8%A7%92%E8%A1%8C%E5%88%97/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210317101558-%E5%AF%BE%E8%A7%92%E8%A1%8C%E5%88%97/</guid>
      <description>\(n\) 次正方行列で、その対角線上にない成分がすべて \(0\) である行列のこと。
\[\begin{bmatrix} 1 &amp;amp; 0 &amp;amp; 0 \\\
0 &amp;amp; 2 &amp;amp; 0 \\\
0 &amp;amp; 0 &amp;amp; -1 \end{bmatrix}\]
注意点として、行列の対角線は右下がりのもののみを言う。右上がりのものは対角線とは呼ばない。</description>
    </item>
    
    <item>
      <title>正方行列</title>
      <link>https://yasuhito.github.io/posts/20210317105154-%E6%AD%A3%E6%96%B9%E8%A1%8C%E5%88%97/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210317105154-%E6%AD%A3%E6%96%B9%E8%A1%8C%E5%88%97/</guid>
      <description>\(m \times m\) 行列は正方形状に成分が並ぶので \(m\) 次正方行列と呼ぶ。
\(2\) 次正方行列の例
\[\begin{bmatrix} 1 &amp;amp; 2 \\\
2 &amp;amp; -1 \end{bmatrix}\]
\(3\) 次正方行列の例
\[\begin{bmatrix} -1 &amp;amp; 2 &amp;amp; 3 \\\
1 &amp;amp; 1 &amp;amp; 0 \\\
2 &amp;amp; 0 &amp;amp; 1 \end{bmatrix}\]</description>
    </item>
    
    <item>
      <title>ディラック記法</title>
      <link>https://yasuhito.github.io/posts/20210311082809-%E3%83%86%E3%82%A3%E3%83%A9%E3%83%83%E3%82%AF%E8%A8%98%E6%B3%95/</link>
      <pubDate>Thu, 11 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210311082809-%E3%83%86%E3%82%A3%E3%83%A9%E3%83%83%E3%82%AF%E8%A8%98%E6%B3%95/</guid>
      <description>ディラック記法は、物理学者ポール・ディラックがとくに量子論を記述する目的で導入した記法。量子論のほとんどの教科書で今日でも使われている。
   名前 記号     ディラックのケット (ket) \(\vert{}\psi\rangle\)   ディラックのブラ (bra) \(\langle\pi\vert{}\)   ディラックのブラケット (braket) \(\langle\pi\vert{}\psi\rangle\)    Quantum Computation and Quantum Information によると、量子力学の難しさの原因はそれ自体が難しいというわけではなく、ディラック記法やそのほか物理学特有の記号がたくさんあることにあるようだ。
 量子力学の公理の理解を阻む主な要因は公理それ自体にあるのではなく、それを理解するのに必要な線形代数の表記法の多さにある。物理学者が量子力学に用いている見慣れない Dirac の表記法と相まって、それは (間違って) とても恐ろしい印象を与える。
    記号 意味     \(z^{\ast}\) 複素数 \(z\) の複素共役。\((1 + i)^{\ast} = 1 - i\)   \(\vert{}\psi\rangle\) ベクトル。ケット (ket) とも呼ばれる。   \(\langle\psi\vert{}\) \(\vert{}\psi\rangle\) に双対 (dual) なベクトル。ブラ (bra) とも呼ばれる   \(\langle\varphi\vert{}\psi\rangle\) \(\vert{}\varphi\rangle\) と \(\vert{}\psi\rangle\) の内積   \(\vert{}\varphi\rangle \otimes \vert{}\psi\rangle\) \(\vert{}\varphi\rangle\) と \(\vert{}\psi\rangle\) のテンソル積   \(\vert{}\varphi\rangle\vert{}\psi\rangle\) \(\vert{}\varphi\rangle\) と \(\vert{}\psi\rangle\) のテンソル積に対する簡略記号   \(A^{\ast}\) 行列 \(A\) の複素共役   \(A^T\) 行列 \(A\) の転置   \(A^{\dagger}\) 行列 \(A\) のエルミート共役、もしくは随伴。\(A^{\dagger} = (A^T)^{\ast}\)   \(\langle\varphi\vert{}A\vert{}\psi\rangle\) \(\vert{}\varphi\rangle\) と \(A\vert{}\psi\rangle\) の内積。\(A^{\dagger}\vert{}\varphi\rangle\) と \(\vert{}\psi\rangle\) の内積に等しい。    参考文献  P.</description>
    </item>
    
    <item>
      <title>Org Mode</title>
      <link>https://yasuhito.github.io/posts/20210223135036-org_mode/</link>
      <pubDate>Wed, 10 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210223135036-org_mode/</guid>
      <description>メモや論文など書くこと全般に使える Emacs のメジャーモード。Org-Roam を使うと、Roam Research 的なスマートノートを作ることができる。このノート上には Anki のカードも定義できるので、スマートノートと SRS をスムーズに組み合わせることができる。そのほか、文芸的プログラミングをサポートしているので、Emacs の設定ファイルを Org のドキュメントから生成できる。
Org mode for Emacs
Org のインライン記法  強調 **強調** 斜体 /斜体/ 下線 _下線_ 打ち消し +打ち消し+ verbatim =verbatim= inline code ~inline code~  </description>
    </item>
    
    <item>
      <title>文芸的プログラミング</title>
      <link>https://yasuhito.github.io/posts/20210310093010-%E6%96%87%E8%8A%B8%E7%9A%84%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF/</link>
      <pubDate>Wed, 10 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210310093010-%E6%96%87%E8%8A%B8%E7%9A%84%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF/</guid>
      <description>Donald E. Knuth が提唱したプログラミング手法の一つで、テキストファイル内にドキュメントとコードを埋めこみ、これから完全なドキュメントとコンパイル可能なソースコードを生成する方法。驚くことに TeX はこの方法で書かれていて、生成されたドキュメントは本として出版されている (TeX: The Program)。
TeX 以外に実用的なソフトウェアで文芸的プログラミングを採用した例は見当たらないが、最近では Org ファイルから Emacs や Bash などの設定ドキュメントとドットファイルを生成するという限定的な用途で文芸的プログラミングが使われている。
極端な例では、Org-Mode 内で論文を書く際に、本文だけでなくテーブルやグラフなど論文の構成要素をすべて生成するという Reproducible Research という手法もある。</description>
    </item>
    
    <item>
      <title>How to Take Smart Notes</title>
      <link>https://yasuhito.github.io/posts/20210228111127-how_to_take_smart_notes/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210228111127-how_to_take_smart_notes/</guid>
      <description> How to Take Smart Notes (Scribd) How to Take Smart Notes (Amazon)  </description>
    </item>
    
    <item>
      <title>Powers of 10: Time Scales in User Experience</title>
      <link>https://yasuhito.github.io/posts/20210303105204-powers_of_10_time_scales_in_user_experience/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210303105204-powers_of_10_time_scales_in_user_experience/</guid>
      <description>Powers of 10: Time Scales in User Experience</description>
    </item>
    
    <item>
      <title>すべての知的努力はメモから</title>
      <link>https://yasuhito.github.io/posts/20210303082924-%E3%81%99%E3%81%B8%E3%81%A6%E3%81%AE%E7%9F%A5%E7%9A%84%E5%8A%AA%E5%8A%9B%E3%81%AF%E3%83%A1%E3%83%A2%E3%81%8B%E3%82%89/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210303082924-%E3%81%99%E3%81%B8%E3%81%A6%E3%81%AE%E7%9F%A5%E7%9A%84%E5%8A%AA%E5%8A%9B%E3%81%AF%E3%83%A1%E3%83%A2%E3%81%8B%E3%82%89/</guid>
      <description>学習、勉強、研究、小説などあらゆる種類の知的活動や創作は、すべてメモを取ることから始まる。書くことについての話題となると、論文や小説といった「書きかけの作品」をいかに完成させるかという議論になりやすい。しかし、これらは「書く」という活動から見ればどれも例外的な瞬間にすぎない。書くことの大部分を占めるのは日常的なメモ書きであり、論文や小説などといった長い作品はメモを書く作業の積み重ねによって生まれる。
文章を書くプロセスは、真っ白な画面よりもはるかに早い段階から始まっていて、実際に議論を書き留めることは、全体のプロセスの中では最小の部分である。
参考文献  How to Take Smart Notes  </description>
    </item>
    
    <item>
      <title>直感性と応答時間</title>
      <link>https://yasuhito.github.io/posts/20210303103710-%E7%9B%B4%E6%84%9F%E6%80%A7%E3%81%A8%E5%BF%9C%E7%AD%94%E6%99%82%E9%96%93/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210303103710-%E7%9B%B4%E6%84%9F%E6%80%A7%E3%81%A8%E5%BF%9C%E7%AD%94%E6%99%82%E9%96%93/</guid>
      <description>ライブプログラミング環境の直感性は、応答時間に大きく依存する。ユーザビリティ研究で有名な Jakob Nielsen の記事 &amp;ldquo;Powers of 10: Time Scales in User Experience&amp;rdquo; によると、ユーザーが何かを操作してから結果が返るまでの応答時間と、ユーザが感じる直感性の関係には、次の一般的な指標がある。
 応答時間 0.1 秒未満 操作が直感的だと感じる。ユーザは自分の行動が直接画面上で何かを引き起したという「直接操作」という錯覚を感じ、操作に集中できる。 応答時間 0.1 〜 1 秒 直感性がやや失われる。ユーザはコンピュータ側で何らかの処理が発生していることに気付き、処理を待つ間に集中力を失いはじめる。 応答時間 1 秒以上 直感性がなくなる。ユーザは反応が遅すぎると感じ、操作をためらうようになる。また、目の前の問題への集中力を完全に失う。  つまり直感性のためには、0.1 秒以内の応答時間を達成する必要がある。</description>
    </item>
    
    <item>
      <title>真っ白な画面</title>
      <link>https://yasuhito.github.io/posts/20210303084450-%E7%9C%9F%E3%81%A3%E7%99%BD%E3%81%AA%E7%94%BB%E9%9D%A2/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210303084450-%E7%9C%9F%E3%81%A3%E7%99%BD%E3%81%AA%E7%94%BB%E9%9D%A2/</guid>
      <description>論文や小説などを書くときには何もないところから始めるという誤った考えかた。ほとんどの文章指南本や自己啓発本はこれを前提にしており、締切の間に合わせかたやその他心理的テクニックなどに終始している (やる気の出しかた、締切との向き合いかた etc.)。そうではなく、すべての知的努力はメモから始まることを理解していて、普段からスマートメモを取っていれば、そもそも真っ白な画面にぶつかることはない。
参考文献  How to Take Smart Notes  </description>
    </item>
    
    <item>
      <title>量子コンピュータ</title>
      <link>https://yasuhito.github.io/posts/20210303094727-%E9%87%8F%E5%AD%90%E3%82%B3%E3%83%B3%E3%83%92%E3%83%A5%E3%83%BC%E3%82%BF/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210303094727-%E9%87%8F%E5%AD%90%E3%82%B3%E3%83%B3%E3%83%92%E3%83%A5%E3%83%BC%E3%82%BF/</guid>
      <description>量子コンピュータは量子力学に基いた新しいタイプのコンピュータである。線形重ね合わせのできる量子ビットを量子ゲートで操作し、量子ビットを測定することで計算結果が得られる。特定の問題について従来のコンピュータより高速に計算できることが知られており、実際、フーリエ変換、素因数分解、データ探索、位相推定をはじめとした量子コンピュータ向けのアルゴリズムが多数存在する (Quantum Algorithm Zoo)。
こうした線形重ね合わせや測定は量子コンピュータ特有の操作であり，従来の開発者にとっては直感的でないという問題がある．そのため，試行錯誤を容易に行える直感的な量子プログラミング環境の構築が重要である。
参考文献  Quantum Computation and Quantum Information Thinking Too Classically: Research Topics in Human-Quantum Computer Interaction  </description>
    </item>
    
    <item>
      <title>Andy Matuschak</title>
      <link>https://yasuhito.github.io/posts/20210302131638-andy_matuschak/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210302131638-andy_matuschak/</guid>
      <description>Andyʼs working notes</description>
    </item>
    
    <item>
      <title>API としてのタイトル</title>
      <link>https://yasuhito.github.io/posts/20210302115454-api_%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%88%E3%83%AB/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210302115454-api_%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%88%E3%83%AB/</guid>
      <description>エバーグリーンノートのタイトル付けは API 設計によく似ている。
 単機能にする (例: Object#inspect) キャッチーな名詞にする (例: &amp;ldquo;囚人のジレンマ&amp;rdquo;、&amp;ldquo;割れ窓理論&amp;rdquo;) 一発で決まらない時は、時間とともに改善 (リファクタリング)  参考文献  Evergreen note titles are like APIs  </description>
    </item>
    
    <item>
      <title>Bret Victor</title>
      <link>https://yasuhito.github.io/posts/20210302122859-bret_victor/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210302122859-bret_victor/</guid>
      <description> 本人のサイト  </description>
    </item>
    
    <item>
      <title>Execute Program</title>
      <link>https://yasuhito.github.io/posts/20210302155222-execute_program/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210302155222-execute_program/</guid>
      <description>https://www.executeprogram.com/
SRS で JavaScript などの API を学習できるサービス。SRS が外国語学習だけでなく API の習得にも有効なのは、Michael Nielsen の Augmenting Long-term Memory でも実証されていることである。
ビジネス的には、SRS は長期 (数年〜) に渡って使うものなので、こういうサービスは個人利用であっても契約期間が長くなる → 収益化しやすい、と予想できる。
使ってみた感想として、回答では必ずキー入力を求められるので、Anki のようにサクサク進められず、レビューセッションを始める前の心理的バリアが少し高いと感じた。キー入力が必要な要因として、問題と回答がアトミックな質問と答になっていないことが考えられる。
キー入力を使わない SRS でプログラミング API を習得することは可能だろうか？ Execute Program の問題を SRS に起こし、自分を実験台にして確認してみる。</description>
    </item>
    
    <item>
      <title>アトミックな質問と答</title>
      <link>https://yasuhito.github.io/posts/20210302123555-%E3%82%A2%E3%83%88%E3%83%9F%E3%83%83%E3%82%AF%E3%81%AA%E8%B3%AA%E5%95%8F%E3%81%A8%E7%AD%94/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210302123555-%E3%82%A2%E3%83%88%E3%83%9F%E3%83%83%E3%82%AF%E3%81%AA%E8%B3%AA%E5%95%8F%E3%81%A8%E7%AD%94/</guid>
      <description>Anki のカードを作るときは、問題と答がたった一つの概念を表すようになるまで、つまりそれ以上分けられない単位 (=アトミック) まで分解する。
たとえば次の Anki カードがあった場合、
 問題: Unix でリンク名からファイル名へのソフトリンクを作るには? 答: ln -s ファイル名 リンク名  これは次の 2 つのカードに分割できる:
  問題: Unix ソフトリンクを作るための基本的コマンドとオプションは?
  答: ln -s
  問題: Unix ソフトリンクを作る時、リンク名とファイル名を指定する順番は?
  答: ファイル名 リンク名
  このようにすると、覚えやすくなり正解率も上がる。答も短くなるため、レビューがテンポ良く進むという利点もある。
もし間違えた場合でも、ミスをした箇所は明らかなため次からは間違えにくい。一方で、2 つ以上の要素が入ったアトミックでない問題で間違えた場合、ミスをした箇所がはっきりしないため、何度も間違えることが多い。
日常的に問題をアトミックに分割する癖を付けておくことは、学んだ事柄ひとつひとつを鋭く結晶化してくれる。手間はかかるが、それだけの価値はある。
注: アトミックな問題に分割した時、元のカードも取っておいたほうが良い。一つ上のレベルの問題として使える場合があるから。</description>
    </item>
    
    <item>
      <title>アトミック・タイトル</title>
      <link>https://yasuhito.github.io/posts/20210302115056-%E3%82%A2%E3%83%88%E3%83%9F%E3%83%83%E3%82%AF_%E3%82%BF%E3%82%A4%E3%83%88%E3%83%AB/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210302115056-%E3%82%A2%E3%83%88%E3%83%9F%E3%83%83%E3%82%AF_%E3%82%BF%E3%82%A4%E3%83%88%E3%83%AB/</guid>
      <description>エバーグリーンノートのタイトルは、それ以上分割できない概念を名詞で表したもの (例: &amp;ldquo;囚人のジレンマ&amp;rdquo;、&amp;ldquo;割れ窓理論&amp;rdquo; etc.) にする。
これをアトミック・タイトルと呼ぶ。アトミック・タイトルはノート内からリンクを貼りやすく、覚えやすい。また一言で言えるので、複雑な概念を表す &amp;ldquo;ハンドル&amp;rdquo; として便利 (API としてのタイトル)。
タイトルがアトミック・タイトルかどうかは、少ない語の名詞になっているかどうかが良い判断基準になると思う。
参考文献  Evergreen notes should be atomic  </description>
    </item>
    
    <item>
      <title>ユニタリ行列</title>
      <link>https://yasuhito.github.io/posts/20210302120815-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E8%A1%8C%E5%88%97/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210302120815-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E8%A1%8C%E5%88%97/</guid>
      <description>ユニタリ行列は \(A^{\dagger} = A^{-1}\) を満たす行列 \(A\)
直交行列 \({}^tA = A^{-1}\) の複素数版。
参考文献  正規行列の対角化可能性  </description>
    </item>
    
    <item>
      <title>ライティング・インボックス</title>
      <link>https://yasuhito.github.io/posts/20210302145631-%E3%83%A9%E3%82%A4%E3%83%86%E3%82%A3%E3%83%B3%E3%82%AF_%E3%82%A4%E3%83%B3%E3%83%9B%E3%83%83%E3%82%AF%E3%82%B9/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210302145631-%E3%83%A9%E3%82%A4%E3%83%86%E3%82%A3%E3%83%B3%E3%82%AF_%E3%82%A4%E3%83%B3%E3%83%9B%E3%83%83%E3%82%AF%E3%82%B9/</guid>
      <description>保存版メモの作業場所としてライティング・インボックスを持っておく。一時的なメモや書きかけのメモは何でも、このインボックスにつっこむ。書きかけがすべてが入っているので、ライティング・インボックスは今までの洞察を蓄積した容れ物だと考えることができる。
このインボックスを漁ることで、次にとりかかるメモを決め、いつでも続きを書きはじめることができる。インボックスの中で保存版メモを仕上げ、アトミック・タイトルをつけ保存版メモとして保存する。つまらないメモはアーカイブする。
Org-Mode での実装 現在は、TODO アイテムに writing タグを付けることでライティング・インボックスを実装している。 練りあげてできあがった保存版メモは、Org-Roam の独立したノートを作ってそこに保存する。
参考文献  My morning writing practice by Andy Matuschak  </description>
    </item>
    
    <item>
      <title>ライブプログラミング</title>
      <link>https://yasuhito.github.io/posts/20210302122628-%E3%83%A9%E3%82%A4%E3%83%95%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210302122628-%E3%83%A9%E3%82%A4%E3%83%95%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF/</guid>
      <description>ライブプログラミングとは、プログラムの実行時の情報を参照しながらコーディングできるようにするインタラクションデザインの一種。
従来の開発環境では、プログラマはソースコード (死んだ状態) を編集しながら実行時 (生きた状態) を頭の中でエミュレーションする必要があった。一方ライブプログラミングでは、開発環境が提示する生きたプログラムの状態を確認しながらソースコードを直感的に編集できる。
ライブプログラミング環境は、頭の中だけでは想像しにくい、抽象的な記号操作をメインとするシステムの理解や開発に有効である。
 Bret Victor らの Interactive Exploration of a Dynamic System では、微分方程式の初期値やパラメータを変えながら結果をインタラクティブに確認できる。 機械学習分野でユーザの多い Jupyter Notebook は文芸的プログラミングとライブプログラミングの組み合わせである。ドキュメント内に埋め込んだソースコードの実行結果をグラフなどに可視化することで，機械学習アルゴリズムの直感的理解を支援する。 量子コンピュータも非常に複雑なシステムの一種であり、直感的には理解しづらい量子プログラミングのためのライブプログラミング環境がいくつか提案されてきた (Quirk, Davy Wybiral の量子回路シミュレータ)。  このように、ライブプログラミングは具体的なモデリング、シミュレーション、可視化をベースにした新しい実践の形を提供する。
参考文献  Live Programming について (LIVE 2017 で基調講演します)  </description>
    </item>
    
    <item>
      <title>保存版メモの数</title>
      <link>https://yasuhito.github.io/posts/20210302120102-%E4%BF%9D%E5%AD%98%E7%89%88%E3%83%A1%E3%83%A2%E3%81%AE%E6%95%B0/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210302120102-%E4%BF%9D%E5%AD%98%E7%89%88%E3%83%A1%E3%83%A2%E3%81%AE%E6%95%B0/</guid>
      <description>一日に書いた保存版メモの数&amp;quot; が、研究者の生産性指標として使える。たとえば、&amp;ldquo;一日あたり 2 個の保存版メモを書こう&amp;rdquo; という目標を立てれば、それに向かって努力することができる。
保存版メモを書かなければ、せっかくの読書のほとんどが無駄になってしまう。保存版メモを書くことは、読書に役立つだけでなくそれ自体が利益になる。たとえば、洞察力を育む、執筆そのものを加速する、など。つまり「書くことは考えること」。
自分はどのくらい一日に書いているだろうか? どのようにすれば計測できるだろうか?</description>
    </item>
    
    <item>
      <title>Ox-Hugo</title>
      <link>https://yasuhito.github.io/posts/20210301083537-ox_hugo/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210301083537-ox_hugo/</guid>
      <description>Org-Mode のファイルを Hugo 形式の Markdown に変換するためのプラグイン。
保存版メモをまとめてエクスポート 次の関数を使って &amp;quot;permanent notes&amp;quot; とタグのついた Org-Roam の保存版ノートを Markdown に一括エクスポートできる。
(after! (org org-roam) (defun my/org-roam-export-all () &amp;#34;Re-exports all Org-roam files to Hugo markdown.&amp;#34; (interactive) (dolist (f (org-roam--list-all-files)) (with-current-buffer (find-file f) (when (s-contains? &amp;#34;permanent notes&amp;#34; (buffer-string)) (org-hugo-export-wim-to-md)))))) 参考文献  Ox-Hugo (GitHub)  </description>
    </item>
    
    <item>
      <title>対角化</title>
      <link>https://yasuhito.github.io/posts/20210301113146-%E5%AF%BE%E8%A7%92%E5%8C%96/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210301113146-%E5%AF%BE%E8%A7%92%E5%8C%96/</guid>
      <description>ある行列 \(A\) を正則行列 \(P\) によって相似変換して結果を対角行列にすること。 あるいは、そのような行列 \(P\) を見つけること
\[P^{-1}AP = \begin{bmatrix} a^{\prime}_{11} &amp;amp; 0 &amp;amp; 0 &amp;amp; \ldots &amp;amp; 0 \\\
0 &amp;amp; a^{\prime}_{22} &amp;amp; 0 &amp;amp; \ldots &amp;amp; 0 \\\
0 &amp;amp; 0 &amp;amp; \ddots &amp;amp; &amp;amp; 0 \\\
\vdots &amp;amp; \vdots &amp;amp; &amp;amp; \ddots &amp;amp; 0 \\\
0 &amp;amp; 0 &amp;amp; \ldots &amp;amp; 0 &amp;amp; a^{\prime}_{nn} \end{bmatrix}\]</description>
    </item>
    
    <item>
      <title>正則行列</title>
      <link>https://yasuhito.github.io/posts/20210301112911-%E6%AD%A3%E5%89%87%E8%A1%8C%E5%88%97/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210301112911-%E6%AD%A3%E5%89%87%E8%A1%8C%E5%88%97/</guid>
      <description>\(n\) 次正方行列 \(A\) について、
\[AB = BA = I\]
となる \(n\) 次正方行列 \(B\) が存在するとき、\(A\) は正則行列という。</description>
    </item>
    
    <item>
      <title>Hugo</title>
      <link>https://yasuhito.github.io/posts/20210228145035-hugo/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210228145035-hugo/</guid>
      <description>Markdown で静的サイトを作るためのツール。Ox-Hugo を使って、Org-Roam の .org ファイルから自動的に yasuhito.github.io を生成する。
Hugo 公式サイト
.org ファイルの設定 .org ファイルの冒頭で #+SETUPFILE: setup.org を指定し setup.org には次の Hugo 共通設定を入れておく。
#+HUGO_BASE_DIR: ~/Documents/Zettel #+HUGO_SECTION: ./posts/ テーマ Mathjax が始めから入っている cactus をとりあえず使っている。
 https://github.com/monkeyWzr/hugo-theme-cactus  </description>
    </item>
    
    <item>
      <title>TOEIC L &amp; R TEST 出る単特急 金のフレーズ</title>
      <link>https://yasuhito.github.io/posts/20210228110804-toeic_l_r_test_%E5%87%BA%E3%82%8B%E5%8D%98%E7%89%B9%E6%80%A5_%E9%87%91%E3%81%AE%E3%83%95%E3%83%AC%E3%83%BC%E3%82%B9/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210228110804-toeic_l_r_test_%E5%87%BA%E3%82%8B%E5%8D%98%E7%89%B9%E6%80%A5_%E9%87%91%E3%81%AE%E3%83%95%E3%83%AC%E3%83%BC%E3%82%B9/</guid>
      <description>Amazon
Anki カード作りの研究用に買ってみた。</description>
    </item>
    
    <item>
      <title>基底状態</title>
      <link>https://yasuhito.github.io/posts/20210224084353-%E5%9F%BA%E5%BA%95%E7%8A%B6%E6%85%8B/</link>
      <pubDate>Wed, 24 Feb 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210224084353-%E5%9F%BA%E5%BA%95%E7%8A%B6%E6%85%8B/</guid>
      <description>\(|0\rangle\) と \(|1\rangle\) は基底状態と呼ばれ、古典コンピュータのビット 0 と 1 に対応する。数学的には、基底状態は状態ベクトル \(|\psi\rangle\) の正規直交基底を形成するベクトルであり、それぞれ次の列ベクトルで定義される。
\[|0\rangle := \begin{bmatrix} 1 \ 0 \end{bmatrix}, |1\rangle := \begin{bmatrix} 0 \ 1 \end{bmatrix}\]
よって 1 量子ビットの状態 \(|\psi\rangle\) は、2次元複素ベクトル空間の単位ベクトルとして表現できる。
\[|\psi\rangle = \begin{bmatrix} \alpha \ \beta \end{bmatrix}\]</description>
    </item>
    
    <item>
      <title>状態ベクトル</title>
      <link>https://yasuhito.github.io/posts/20210224083510-%E7%8A%B6%E6%85%8B%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/</link>
      <pubDate>Wed, 24 Feb 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210224083510-%E7%8A%B6%E6%85%8B%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/</guid>
      <description>量子コンピュータでは、情報を量子ビットとして表現する。量子ビットは、古典的なコンピュータでのビットに対応する。1つの量子ビットの任意の状態 \(|\psi\rangle\) は、ディラック記法を使って基底状態 \(|0\rangle\) と \(|1\rangle\) の重ね合わせ (線形結合) として次の式で表すことができる。
\[|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\]
ここで係数 \(\alpha, \beta\) を確率振幅と呼び \(\alpha, \beta \in \mathbb{C}\) である。また、正規化条件として \(|\alpha|^2 + |\beta|^2 = 1\) に従わなければならない。</description>
    </item>
    
    <item>
      <title>HTML Over the Wire</title>
      <link>https://yasuhito.github.io/posts/20210223123752-html_over_the_wire/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210223123752-html_over_the_wire/</guid>
      <description>React や Vue.js などの Web プログラミングフレームワークでは、ネイティブアプリと同様の UX を提供するために処理の大半をブラウザ側で行う。サーバは HTML ではなくデータを JSON として返す API/GraphQL サーバーとして動作し、HTML の生成はクライアントサイドのブラウザで動作する JavaScript フレームワーク上で行う。
これは、従来の Rails などのフレームワークと比較して複雑である。従来は、サーバ側で MVC フレームワークが動作し、データとプレゼンテーションを HTML としてサーバ側で生成し、ブラウザへ送っていた。一方で、近年の Web フレームワークはブラウザ上で MVC フレームワークが動作する。画面遷移を高速にするために、DOM ツリーの差分を取り、仮想 DOM という仕組みで最小の書き換えで画面遷移を実現する。
しかし、従来の単純なフレームワークでもネイティブアプリと同等の UX を達成することは可能である。DOM のうち動的な部分のみ JavaScript で書き換える。画面遷移についても、マウスオーバー時のプリフェッチによってソースコードを変更せずに高速化が可能である。
このための代表的なフレームワークが HOTwire。元々 Turbolinks や Stimulus.js だったものをまとめたもの。HTML の data 属性を使うことで、JavaScript 部分と HTML を結合することができる。JavaScript 部分は、サーバ側の MVC 実装や HTML にほとんど染み出さない。
参考文献  HTML over the wire  </description>
    </item>
    
    <item>
      <title>Org-Roam</title>
      <link>https://yasuhito.github.io/posts/20210223134834-org_roam/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210223134834-org_roam/</guid>
      <description>Org-Roam は Org Mode の上に構築された、Roam Research ライクなノート環境。
クラウドへのバックアップ iCloud で同期すれば、ソフトウェアの追加インストールなしで iPhone や Mac と org ファイルを同期できる。とにかく手軽なので、なにか問題が出るまではしばらく iCloud でバックアップを取ることにする。
iCloud に org ディレクトリを作るには、iPhone に beorg をインストールするのが手っ取り早い。インストールすると iCloud Drive 上に beorg 用のディレクトリが作られるので、ここから ~/org にシンボリックリンクを張る。
cd ~ ln -s ~/Library/Mobile\ Documents/iCloud~com~appsonthemove~beorg/Documents/org org </description>
    </item>
    
    <item>
      <title>線形結合</title>
      <link>https://yasuhito.github.io/posts/20210223212225-%E7%B7%9A%E5%BD%A2%E7%B5%90%E5%90%88/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0900</pubDate>
      
      <guid>https://yasuhito.github.io/posts/20210223212225-%E7%B7%9A%E5%BD%A2%E7%B5%90%E5%90%88/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
