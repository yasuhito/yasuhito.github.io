[
    
        
            {
                "ref": "https://yasuhito.github.io/post/20210427134245-qcqi_%E6%BC%94%E7%BF%92_2_54/",
                "title": "QCQI/演習 2.54",
                "section": "post",
                "date" : "2021.04.27",
                "body": "\\(A\\) と \\(B\\) はエルミート演算子でありかつ可換だから、同時対角化定理より \\(A\\) と \\(B\\) は同時対角化可能。つまり \\(A\\), \\(B\\) の固有ベクトルに共通の正規直交集合 \\(\\ket{i}\\) を用いて次のように書ける。\n\\[A = \\sum_i a_i \\ket{i}\\bra{i}\\] \\[B = \\sum_i b_i \\ket{i}\\bra{i}\\]\nこの結果を使うと、\n\\begin{eqnarray*} \\mathrm{exp}(A)\\mathrm{exp}(B) \u0026amp;=\u0026amp; \\sum_i \\mathrm{exp}(a_i)\\ket{i}\\bra{i}\\sum_j\\mathrm{exp}(b_j)\\ket{j}\\bra{j} \\\\\\\n\u0026amp;=\u0026amp; \\sum_{i,j} \\mathrm{exp}(a_i + b_j)\\ket{i}\\braket{i|j}\\bra{j} \\\\\\\n\u0026amp;=\u0026amp; \\sum_{i,j} \\mathrm{exp}(a_i + b_j)\\delta_{i,j}\\ket{i}\\bra{j} \\\\\\\n\u0026amp;=\u0026amp; \\sum_i \\mathrm{exp}(a_i + b_i)\\ket{i}\\bra{i} \\\\\\\n\u0026amp;=\u0026amp; \\mathrm{exp}(A + B) \\end{eqnarray*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210427140018-qcqi_%E6%BC%94%E7%BF%92_2_55/",
                "title": "QCQI/演習 2.55",
                "section": "post",
                "date" : "2021.04.27",
                "body": "\\(U(t_1, t_2)U^{\\dagger}(t_1, t_2) = I\\) を示す。\n\\(H\\) はエルミート演算子なので、固有値 \\(\\lambda_i\\) とそれに対応する正規化固有ベクトル \\(\\ket{i}\\) を用いてスペクトル分解できる\n\\[H = \\sum_i \\lambda_i \\ket{i}\\bra{i}\\]\nここで\n\\[U(t_1, t_2) = \\mathrm{exp}\\left[\\frac{-iH(t_2 - t_1)}{\\hbar}\\right]\\]\nに \\(H\\) のスペクトル分解を使うと、\n\\[U(t_1, t_2) = \\sum_j \\mathrm{exp}\\left[\\frac{-i(t_2 - t_1)\\lambda_j}{\\hbar}\\right]\\ket{j}\\bra{j}\\] \\[U^{\\dagger}(t_1, t_2) = \\sum_j \\mathrm{exp}\\left[\\frac{i(t_2 - t_1)\\lambda_j}{\\hbar}\\right]\\ket{j}\\bra{j}\\] よって、\\(U(t_1, t_2)U^{\\dagger}(t_1, t_2)\\) を計算すると、\n\\begin{eqnarray*} U(t_1, t_2)U^{\\dagger}(t_1, t_2) \u0026amp;=\u0026amp; \\sum_j \\mathrm{exp}\\left[\\frac{-i(t_2 - t_1)\\lambda_j}{\\hbar}\\right]\\mathrm{exp}\\left[\\frac{i(t_2 - t_1)\\lambda_j}{\\hbar}\\right]\\ket{j}\\bra{j} \\\\\\\n\u0026amp;=\u0026amp; \\sum_j \\ket{j}\\bra{j} \\\\\\\n\u0026amp;=\u0026amp; I \\end{eqnarray*}\nよって \\(U(t_1, t_2)\\) はユニタリー。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210427150513-qcqi_%E6%BC%94%E7%BF%92_2_56/",
                "title": "QCQI/演習 2.56",
                "section": "post",
                "date" : "2021.04.27",
                "body": "\\(U\\) は正規なので固有値 \\(\\lambda_i\\) とそれに対応する正規化固有ベクトル \\(\\ket{i}\\) を用いてスペクトル分解できる。\n\\[U = \\sum_i \\lambda_i \\ket{i}\\bra{i}\\]\nこれを \\(K\\) に適用すると、\n\\begin{align*} \u0026amp;K = -i\\mathrm{log}(U) = -i\\sum_j \\mathrm{log}(\\lambda_j)\\ket{j}\\bra{j} \\\\\\\n\u0026amp;K^{\\dagger} = i\\sum_j \\mathrm{log}(\\lambda_j)^{\\ast}\\ket{j}\\bra{j} \\end{align*}\nここで QCQI/演習 2.18 の結果より、ユニタリー行列の固有値はある実数 \\(\\theta\\) を用いて \\(e^{i\\theta}\\) の形で書けることから、\n\\begin{eqnarray*} K \u0026amp;=\u0026amp; -i\\sum_j \\mathrm{log}(\\lambda_j)\\ket{j}\\bra{j} \\\\\\\n\u0026amp;=\u0026amp; -i\\sum_j \\mathrm{log}(e^{i\\theta_j})\\ket{j}\\bra{j} \\\\\\\n\u0026amp;=\u0026amp; -i\\sum_j i\\theta_j \\ket{j}\\bra{j} \\\\\\\n\u0026amp;=\u0026amp; \\sum_j \\theta_j \\ket{j}\\bra{j} \\\\\\\n\u0026amp;=\u0026amp; K^{\\dagger} \\end{eqnarray*}\nよって \\(K\\) はエルミート演算子。\nここで、\\(K = -i\\mathrm{log}(U)\\) の両辺の \\(\\mathrm{exp}\\) を取ると \\(U = \\mathrm{exp}(iK)\\) となる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210427133807-%E5%8F%AF%E6%8F%9B/",
                "title": "可換",
                "section": "post",
                "date" : "2021.04.27",
                "body": "2 つの演算子 \\(A\\), \\(B\\) について、もし交換子 \\([A, B] = 0\\) つまり \\(AB = BA\\) ならば \\(A\\) は \\(B\\) と可換であるという。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210424110334-x_%E3%82%B1%E3%83%BC%E3%83%88/",
                "title": "X ゲート",
                "section": "post",
                "date" : "2021.04.24",
                "body": "量子 NOT ゲートを参照。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210424101536-%E9%87%8F%E5%AD%90_not_%E3%82%B1%E3%83%BC%E3%83%88/",
                "title": "量子 NOT ゲート",
                "section": "post",
                "date" : "2021.04.24",
                "body": "量子 NOT ゲートは古典ビットの反転 (NOT) に対応する量子ゲートの一つであり、\\(\\ket{0} \\rightarrow \\ket{1}\\) および \\(\\ket{1} \\rightarrow \\ket{0}\\) つまり状態 \\(\\ket{0}\\) と \\(\\ket{1}\\) の入れ替えを行う。通常は記号 \\(X\\) で表し、\n\\[X\\ket{0} = \\ket{1},\\ X\\ket{1} = \\ket{0}\\]\nのように作用する。\n量子ゲートは線形に働くことから、量子状態 \\(\\ket{\\psi} = \\alpha\\ket{0} + \\beta\\ket{1}\\) に作用させると、\n\\[X\\ket{\\psi} = X(\\alpha\\ket{0} + \\beta\\ket{1}) = \\alpha X\\ket{0} + \\beta X\\ket{1} = \\alpha\\ket{1} + \\beta\\ket{0}\\]\nとなる。これはベクトルで表すと、\n\\begin{equation*} X\\ket{\\psi} = X\\begin{bmatrix} \\alpha \\newline \\beta \\end{bmatrix} = \\begin{bmatrix} \\beta \\newline \\alpha \\end{bmatrix} \\end{equation*}\nとなる。\n行列表現 行列表現ではパウリ行列の \\(X\\) に対応する。\n\\begin{equation*} X \\equiv \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\end{equation*}\n行列として見ると、量子 NOT ゲートの作用は次のように言い換えることができる。\n 状態 \\(\\ket{0}\\) を行列 \\(X\\) の最初の列に相当する状態 \\(\\begin{bmatrix}0 \\newline 1 \\end{bmatrix} = \\ket{1}\\) で置き換える 状態 \\(\\ket{1}\\) を行列 \\(X\\) の第 2 列に相当する状態 \\(\\begin{bmatrix}1 \\newline 0 \\end{bmatrix} = \\ket{0}\\) で置き換える  外積表現 パウリ演算子の外積表現から、\\[X = \\ket{0}\\bra{1} + \\ket{1}\\bra{0}\\] と表すことができて、このとき確かに \\(X\\ket{0}\\) と \\(X\\ket{1}\\) は\n\\[X\\ket{0} = (\\ket{0}\\bra{1} + \\ket{1}\\bra{0})\\ket{0} = \\cancel{\\ket{0}\\underbrace{\\braket{1|0}}_{= 0}} + \\ket{1}\\underbrace{\\braket{0|0}}_{= 1} = \\ket{1}\\] \\[X\\ket{1} = (\\ket{0}\\bra{1} + \\ket{1}\\bra{0})\\ket{1} = \\ket{0}\\underbrace{\\braket{1|1}}_{= 1} + \\cancel{\\ket{1}\\underbrace{\\braket{0|1}}_{= 0}} = \\ket{0}\\]\nとなる。\n参照  Quantum Computation and Quantum Information 1.3.1  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210423151653-%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB%E9%83%A8%E5%88%86%E7%A9%BA%E9%96%93/",
                "title": "ベクトル部分空間",
                "section": "post",
                "date" : "2021.04.23",
                "body": "ベクトル空間 \\(V\\) のベクトル部分空間 \\(W\\) は \\(V\\) の部分集合であり、\\(W\\) もベクトル空間となる。つまり \\(W\\) は和演算とスカラー倍演算に関して閉じている。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422115645-%E3%82%A2%E3%82%BF%E3%83%9E%E3%83%BC%E3%83%AB%E3%82%B1%E3%83%BC%E3%83%88/",
                "title": "アダマールゲート",
                "section": "post",
                "date" : "2021.04.22",
                "body": "アダマールゲートはユニタリー演算子の一つで、記号 \\(H\\) で表す。\nその演算子としての作用は次のように定義される:\n\\begin{eqnarray*} H\\ket{0} \u0026amp;\\equiv\u0026amp; \\frac{\\ket{0} + \\ket{1}}{\\sqrt{2}} \\\\\\\nH\\ket{1} \u0026amp;\\equiv\u0026amp; \\frac{\\ket{0} - \\ket{1}}{\\sqrt{2}} \\end{eqnarray*}\n行列表現では次のように与えられる:\n\\begin{equation*} H = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \u0026amp; 1 \\newline 1 \u0026amp; -1 \\end{bmatrix} \\end{equation*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422135421-%E3%82%A8%E3%83%8D%E3%83%AB%E3%82%AD%E3%83%BC/",
                "title": "エネルギー",
                "section": "post",
                "date" : "2021.04.22",
                "body": "ハミルトニアンのスペクトル分解\n\\[H = \\sum_E E\\ket{E}\\bra{E}\\]\nにおいて、\\(E\\) をエネルギー固有状態 \\(\\ket{E}\\) のエネルギーと呼ぶ。\n最も低いエネルギーを系の基底状態エネルギーといい、対応するエネルギー固有状態 (または固有空間) を基底状態という。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422135039-%E3%82%A8%E3%83%8D%E3%83%AB%E3%82%AD%E3%83%BC%E5%9B%BA%E6%9C%89%E7%8A%B6%E6%85%8B/",
                "title": "エネルギー固有状態",
                "section": "post",
                "date" : "2021.04.22",
                "body": "ハミルトニアンのスペクトル分解\n\\[H = \\sum_E E\\ket{E}\\bra{E}\\]\nにおいて、状態 \\(\\ket{E}\\) をエネルギー固有状態または定常状態と呼ぶ。\n最も低いエネルギー \\(E\\) を系の基底状態エネルギーといい、対応するエネルギー固有状態 (または固有空間) を基底状態という。\n\\(\\ket{E}\\) を定常状態とも呼ぶのは、唯一の時間変化が全体に掛かる位相因子にのみ現れるからである。\n\\[\\ket{E} \\rightarrow \\mathrm{exp}(-iEt/\\hbar)\\ket{E}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422140552-%E3%83%8F%E3%83%9F%E3%83%AB%E3%83%88%E3%83%8B%E3%82%A2%E3%83%B3/",
                "title": "ハミルトニアン",
                "section": "post",
                "date" : "2021.04.22",
                "body": "シュレディンガー方程式に登場するエルミート演算子 \\(H\\) をハミルトニアンと呼ぶ。\n量子計算や量子情報で登場するハミルトニアンについては、たとえば単一量子ビットのハミルトニアンがパウリ行列のみを用いて\n\\[H = \\hbar\\omega X\\]\nで与えられるとする (\\(\\omega\\) は実験で決めるパラメータでここでは気にしない)。\nこのハミルトニアンのエネルギー固有状態は明らかに \\(X\\) の固有状態と同じであり、状態が \\((\\ket{0} + \\ket{1})/\\sqrt{2}\\) と \\((\\ket{0} - \\ket{1})/2\\), それぞれに対応するエネルギーが \\(\\hbar\\omega\\) と \\(-\\hbar\\omega\\) で与えられる。したがって基底状態は \\((\\ket{0} - \\ket{1})/\\sqrt{2}\\), 基底状態エネルギーは \\(-\\hbar\\omega\\) である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422133531-%E3%83%8F%E3%83%9F%E3%83%AB%E3%83%88%E3%83%8B%E3%82%A2%E3%83%B3%E3%81%AE%E3%82%B9%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB%E5%88%86%E8%A7%A3/",
                "title": "ハミルトニアンのスペクトル分解",
                "section": "post",
                "date" : "2021.04.22",
                "body": "ハミルトニアンはエルミート演算子なので、固有値 \\(E\\) と それに対応する正規化固有ベクトル \\(\\ket{E}\\) を用いてスペクトル分解できる。\n\\[H = \\sum_E E\\ket{E}\\bra{E}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422114021-%E6%8C%AF%E5%B9%85/",
                "title": "振幅",
                "section": "post",
                "date" : "2021.04.22",
                "body": "状態を重ね合わせるときの係数を振幅と呼ぶ。たとえば、\n\\[\\frac{\\ket{0} - \\ket{1}}{\\sqrt{2}}\\]\nは状態 \\(\\ket{0}\\) に対して振幅 \\(\\frac{1}{\\sqrt{2}}\\), 状態 \\(\\ket{1}\\) に対して振幅 \\(\\frac{-1}{\\sqrt{2}}\\) で状態 \\(\\ket{0}\\) と \\(\\ket{1}\\) を重ね合わせたもの。\n一般に、任意の線形結合 \\(\\sum_i \\alpha_i\\ket{\\psi_i}\\) は状態 \\(\\ket{\\psi_i}\\) に対する振幅 \\(\\alpha_i\\) をもって状態 \\(\\ket{\\psi_i}\\) を重ね合わせたものと言える。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422104146-%E6%AD%A3%E8%A6%8F%E5%8C%96%E6%9D%A1%E4%BB%B6/",
                "title": "正規化条件",
                "section": "post",
                "date" : "2021.04.22",
                "body": "状態ベクトルは単位ベクトルであり、そのための条件 \\(\\braket{\\psi|\\psi} = 1\\) を正規化条件と呼ぶ。\n量子ビットの状態ベクトルを \\(\\ket{\\psi} = a\\ket{0} + b\\ket{1}\\) と書いたとき、条件 \\(\\braket{\\psi|\\psi} = 1\\) は \\(|a|^2 + |b|^2 = 1\\) と等価。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422150357-%E8%A8%88%E7%AE%97%E5%9F%BA%E5%BA%95%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E9%87%8F%E5%AD%90%E3%83%92%E3%83%83%E3%83%88%E3%81%AE%E6%B8%AC%E5%AE%9A/",
                "title": "計算基底における量子ビットの測定",
                "section": "post",
                "date" : "2021.04.22",
                "body": "単一量子ビットに対する測定は \\(M_0 = \\ket{0}\\bra{0}\\), \\(M_1 = \\ket{1}\\bra{1}\\) の 2 つの測定演算子で定義でき、\\(\\ket{0}\\) と \\(\\ket{1}\\) の 2 つの結果を返す。\n\\(M_0\\) と \\(M_1\\) はエルミート演算子であり計算すると \\(M_0^2 = M_0\\), \\(M_1^2 = M_1\\) であることがわかる。したがって、完全性の関係が満たされる。\n\\[I = M_0^{\\dagger}M_0 + M_1^{\\dagger}M_1 = M_0 + M_1\\]\n測定される状態は \\(\\ket{\\psi} = a\\ket{0} + b\\ket{1}\\) であり、量子力学の公理 (量子測定は測定演算子の集まりで記述できる) より、測定結果 \\(0\\) を得る確率は、\n\\[p(0) = \\braket{\\psi|M_0^{\\dagger}M_0|\\psi} = \\braket{\\psi|M_0|\\psi} = |a|^2\\]\n同様に測定結果 1 を得る確率は \\(p(1) = |b|^2\\). よって 2 つの場合の測定後の状態は、\n\\[\\frac{M_0\\ket{\\psi}}{|a|} = \\frac{a}{|a|}\\ket{0}\\]\n\\[\\frac{M_1\\ket{\\psi}}{|b|} = \\frac{b}{|b|}\\ket{1}\\]\nここで \\(a/|a|\\) のような絶対値が \\(1\\) の係数は無視してよいので、測定後の状態は \\(\\ket{0}\\), \\(\\ket{1}\\) となる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422102127-%E9%87%8F%E5%AD%90%E3%83%92%E3%83%83%E3%83%88/",
                "title": "量子ビット",
                "section": "post",
                "date" : "2021.04.22",
                "body": "量子コンピュータでは、情報を量子ビットとして表現する。量子ビットは、古典的なコンピュータでのビットに対応する。\n量子ビットは 2 次元状態空間を持つ簡単な量子系であり、\\(\\ket{0}\\) と \\(\\ket{1}\\) がその状態空間の基底を形成する。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422091236-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E3%81%AE%E5%85%AC%E7%90%86/",
                "title": "量子力学の公理",
                "section": "post",
                "date" : "2021.04.22",
                "body": " 閉じた量子系の状態は状態ベクトルで記述できる 閉じた量子系の時間発展はユニタリー変換で記述できる  閉じた量子系の時間発展はシュレディンガー方程式で記述できる   量子測定は測定演算子の集まりで記述できる 複合量子系の記述  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422143643-%E9%87%8F%E5%AD%90%E6%B8%AC%E5%AE%9A%E3%81%AF%E6%B8%AC%E5%AE%9A%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E9%9B%86%E3%81%BE%E3%82%8A%E3%81%A6%E8%A8%98%E8%BF%B0%E3%81%A6%E3%81%8D%E3%82%8B/",
                "title": "量子測定は測定演算子の集まりで記述できる",
                "section": "post",
                "date" : "2021.04.22",
                "body": "ある量子系内部で何が起こっているかを見ようとすること (実験) を量子測定と呼び、これは相互作用となるので系はもはや閉じておらず、ユニタリー時間発展にはならない。\n量子測定は測定演算子の集まり \\(\\{M_m\\}\\) で記述できる (\\(m\\) は測定結果を指す)。これらの演算子は測定される系の状態空間に作用する。もし測定直前の量子系状態が \\(\\ket{\\psi}\\) ならば、測定結果 \\(m\\) が生じる確率は、\n\\[p(m) = \\braket{\\psi|M_m^{\\dagger}M_m|\\psi}\\]\nで与えられ、測定後の系状態は、\n\\[\\frac{M_m\\ket{\\psi}}{\\sqrt{\\braket{\\psi|M_m^{\\dagger}M_m|\\psi}}}\\]\nである。測定演算子は次の完全性の式を満たす。\n\\[\\sum_m M_m^{\\dagger}M_m = I\\]\n完全性の式は確率の和が \\(1\\) になるという事実を表現する:\n\\[1 = \\sum_m p(m) = \\sum_m \\braket{\\psi|M_m^{\\dagger}M_m|\\psi}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422120837-%E9%96%89%E3%81%97%E3%81%9F%E9%87%8F%E5%AD%90%E7%B3%BB%E3%81%AE%E6%99%82%E9%96%93%E7%99%BA%E5%B1%95%E3%81%AF%E3%82%B7%E3%83%A5%E3%83%AC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%AB%E3%83%BC%E6%96%B9%E7%A8%8B%E5%BC%8F%E3%81%A6%E8%A8%98%E8%BF%B0%E3%81%A6%E3%81%8D%E3%82%8B/",
                "title": "閉じた量子系の時間発展はシュレディンガー方程式で記述できる",
                "section": "post",
                "date" : "2021.04.22",
                "body": "閉じた量子系の時間発展はシュレディンガー方程式\n\\[i\\hbar \\frac{d\\ket{\\psi}}{dt} = H\\ket{\\psi}\\]\nで記述できる。ここで \\(\\hbar\\) はプランク定数、\\(H\\) はエルミート演算子であり閉じた系のハミルトニアンと呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422114920-%E9%96%89%E3%81%97%E3%81%9F%E9%87%8F%E5%AD%90%E7%B3%BB%E3%81%AE%E6%99%82%E9%96%93%E7%99%BA%E5%B1%95%E3%81%AF%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%BC%E5%A4%89%E6%8F%9B%E3%81%A6%E8%A8%98%E8%BF%B0%E3%81%A6%E3%81%8D%E3%82%8B/",
                "title": "閉じた量子系の時間発展はユニタリー変換で記述できる",
                "section": "post",
                "date" : "2021.04.22",
                "body": "閉じた量子系について、時刻 \\(t_1\\) における系の状態 \\(\\ket{\\psi}\\) は、時刻 \\(t_2\\) における系の状態 \\(\\ket{\\psi^{\\prime}}\\) と時刻 \\(t_1\\) と \\(t_2\\) だけに依存するユニタリー演算子 \\(U\\) によって関連付けられる。\n\\[\\ket{\\psi^{\\prime}} = U\\ket{\\psi}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210422092500-%E9%96%89%E3%81%97%E3%81%9F%E9%87%8F%E5%AD%90%E7%B3%BB%E3%81%AE%E7%8A%B6%E6%85%8B%E3%81%AF%E7%8A%B6%E6%85%8B%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB%E3%81%A6%E8%A8%98%E8%BF%B0%E3%81%A6%E3%81%8D%E3%82%8B/",
                "title": "閉じた量子系の状態は状態ベクトルで記述できる",
                "section": "post",
                "date" : "2021.04.22",
                "body": "閉じた (孤立した) 量子系に関して、系の状態空間と呼ぶヒルベルト空間が存在する。量子系はこの状態空間の単位ベクトルである状態ベクトルによって完全に記述できる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210421141056-qcqi_%E6%BC%94%E7%BF%92_2_51/",
                "title": "QCQI/演習 2.51",
                "section": "post",
                "date" : "2021.04.21",
                "body": "アダマールゲート \\(H\\) について、ユニタリー行列の条件 \\(H^{\\dagger}H = I\\) を示す。\n\\begin{eqnarray*} H^{\\dagger}H \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \u0026amp; 1 \\newline 1 \u0026amp; -1 \\end{bmatrix} \\times \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \u0026amp; 1 \\newline 1 \u0026amp; -1 \\end{bmatrix} \\\\\\\n\u0026amp;=\u0026amp; \\frac{1}{2}\\begin{bmatrix} 2 \u0026amp; 0 \\newline 0 \u0026amp; 2 \\end{bmatrix} \\\\\\\n\u0026amp;=\u0026amp; \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} \\\\\\\n\u0026amp;=\u0026amp; I \\end{eqnarray*}\nよって \\(H\\) はユニタリー。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210421142837-qcqi_%E6%BC%94%E7%BF%92_2_52/",
                "title": "QCQI/演習 2.52",
                "section": "post",
                "date" : "2021.04.21",
                "body": "QCQI/演習 2.51 よりアダマールゲート \\(H\\) について \\(H^{\\dagger}H = I\\)\nそして \\(H\\) の行列表現はエルミート行列だから \\(H^{\\dagger} = H\\)\nよって \\(H^{\\dagger}H = H^2 = I\\)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210421150137-qcqi_%E6%BC%94%E7%BF%92_2_53/",
                "title": "QCQI/演習 2.53",
                "section": "post",
                "date" : "2021.04.21",
                "body": "アダマールゲート \\(H\\) の固有値 \\(\\lambda\\) を求める。\n\\begin{eqnarray*} \\mathrm{det}|H - \\lambda I| \u0026amp;=\u0026amp; \\begin{bmatrix} \\frac{1}{\\sqrt{2}} - \\lambda \u0026amp; \\frac{1}{\\sqrt{2}} \\newline \\frac{1}{\\sqrt{2}} \u0026amp; -\\frac{1}{\\sqrt{2}} - \\lambda \\end{bmatrix} \\\\\\\n\u0026amp;=\u0026amp; -(\\frac{1}{\\sqrt{2}} - \\lambda)(\\frac{1}{\\sqrt{2}} - \\lambda) - \\frac{1}{2} \\\\\\\n\u0026amp;=\u0026amp; \\lambda^2 - 1 \\\\\\\n\u0026amp;=\u0026amp; 0 \\\\\\\n\\therefore \\lambda = \\pm 1 \\end{eqnarray*}\n\\(\\lambda = 1\\) のとき固有ベクトル \\(\\ket{\\lambda_1}\\) は、\n\\begin{eqnarray*} \\mathrm{det}|H - \\lambda I| \u0026amp;=\u0026amp; \\begin{bmatrix} \\frac{1}{\\sqrt{2}} - 1 \u0026amp; \\frac{1}{\\sqrt{2}} \\newline \\frac{1}{\\sqrt{2}} \u0026amp; -\\frac{1}{\\sqrt{2}} - 1 \\end{bmatrix} \\begin{bmatrix} \\vphantom{\\frac{1}{\\sqrt{2}}} a \\newline \\vphantom{\\frac{1}{\\sqrt{2}}} b \\end{bmatrix} = \\begin{bmatrix} \\vphantom{\\frac{1}{\\sqrt{2}}} 0 \\newline \\vphantom{\\frac{1}{\\sqrt{2}}} 0 \\end{bmatrix} \\\\\\\n\\Rightarrow \\ket{\\lambda_1} \u0026amp;=\u0026amp; \\begin{bmatrix} 1 \\newline \\sqrt{2} - 1 \\end{bmatrix} \\end{eqnarray*}\n\\(\\lambda = -1\\) のとき固有ベクトル \\(\\ket{\\lambda_{-1}}\\) は、\n\\begin{eqnarray*} \\mathrm{det}|H - \\lambda I| \u0026amp;=\u0026amp; \\begin{bmatrix} \\frac{1}{\\sqrt{2}} + 1 \u0026amp; \\frac{1}{\\sqrt{2}} \\newline \\frac{1}{\\sqrt{2}} \u0026amp; -\\frac{1}{\\sqrt{2}} + 1 \\end{bmatrix} \\begin{bmatrix} \\vphantom{\\frac{1}{\\sqrt{2}}} a \\newline \\vphantom{\\frac{1}{\\sqrt{2}}} b \\end{bmatrix} = \\begin{bmatrix} \\vphantom{\\frac{1}{\\sqrt{2}}} 0 \\newline \\vphantom{\\frac{1}{\\sqrt{2}}} 0 \\end{bmatrix} \\\\\\\n\\Rightarrow \\ket{\\lambda_{-1}} \u0026amp;=\u0026amp; \\begin{bmatrix} 1 \\newline -\\sqrt{2} - 1 \\end{bmatrix} \\end{eqnarray*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210420082939-qcqi_%E6%BC%94%E7%BF%92_2_43/",
                "title": "QCQI/演習 2.43",
                "section": "post",
                "date" : "2021.04.20",
                "body": "\\[\\sigma_j \\sigma_k = \\frac{[\\sigma_j, \\sigma_k] + \\{\\sigma_j, \\sigma_k\\}}{2}\\]\nここで QCQI/演習 2.40 より、\n\\[[\\sigma_j, \\sigma_k] = 2i\\sum_{l=1}^{3}\\epsilon_{jkl}\\sigma_l\\]\nまた QCQI/演習 2.41 より、\n\\(j \\neq k\\) のとき\n\\[\\{\\sigma_j, \\sigma_k\\} = 0\\]\n\\(j = k\\) のとき、\n\\[\\{\\sigma_j, \\sigma_k\\} = \\sigma_j\\sigma_k + \\sigma_k\\sigma_j = 2I\\]\nよって\n\\begin{eqnarray*} \\frac{[\\sigma_j, \\sigma_k] + \\{\\sigma_j, \\sigma_k\\}}{2} \u0026amp;=\u0026amp; \\frac{1}{2}\\left(2i\\sum_{l=1}^{3}\\epsilon_{jkl}\\sigma_l + 2\\delta_{jk}I\\right) \\\\\\\n\u0026amp;=\u0026amp; \\delta_{jk}I + i\\sum_{l=1}^{3}\\epsilon_{jkl}\\sigma_l \\end{eqnarray*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210420084915-qcqi_%E6%BC%94%E7%BF%92_2_44/",
                "title": "QCQI/演習 2.44",
                "section": "post",
                "date" : "2021.04.20",
                "body": "\\([A, B] = 0\\) より、\n\\begin{eqnarray*} \u0026amp;\\phantom{\\Rightarrow}\u0026amp; [A, B] = 0 \\\\\\\n\u0026amp;\\Rightarrow\u0026amp; AB - BA = 0 \\\\\\\n\u0026amp;\\Rightarrow\u0026amp; AB = BA \\end{eqnarray*}\n\\(\\{A, B\\} = 0\\) より、\n\\begin{eqnarray*} \u0026amp;\\phantom{\\Rightarrow}\u0026amp; \\{A, B\\} = 0 \\\\\\\n\u0026amp;\\Rightarrow\u0026amp; AB + BA = 0 \\\\\\\n\u0026amp;\\Rightarrow\u0026amp; 2AB = 0\\ (\\because AB = BA) \\\\\\\n\u0026amp;\\Rightarrow\u0026amp; AB = 0 \\end{eqnarray*}\n\\(A\\) は可逆だから \\(A^{-1}\\) が存在し、\n\\begin{eqnarray*} \u0026amp;\\Rightarrow\u0026amp; A^{-1}AB = A^{-1}0 \\\\\\\n\u0026amp;\\Rightarrow\u0026amp; B = 0 \\end{eqnarray*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210420090708-qcqi_%E6%BC%94%E7%BF%92_2_45/",
                "title": "QCQI/演習 2.45",
                "section": "post",
                "date" : "2021.04.20",
                "body": "\\begin{eqnarray*} [A, B]^{\\dagger} \u0026amp;=\u0026amp; (AB - BA)^{\\dagger} \\\\\\\n\\end{eqnarray*}\nQCQI/演習 2.14 より\n\\begin{eqnarray*} \\phantom{[A, B]^{\\dagger}} \u0026amp;=\u0026amp; (AB)^{\\dagger} - (BA)^{\\dagger} \\\\\\\n\u0026amp;=\u0026amp; B^{\\dagger}A^{\\dagger} - A^{\\dagger}B^{\\dagger} \\\\\\\n\u0026amp;=\u0026amp; [B^{\\dagger}, A^{\\dagger}] \\end{eqnarray*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210420091735-qcqi_%E6%BC%94%E7%BF%92_2_46/",
                "title": "QCQI/演習 2.46",
                "section": "post",
                "date" : "2021.04.20",
                "body": "\\[[A, B] = AB - BA = -(BA - AB) = -[B, A]\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210420092342-qcqi_%E6%BC%94%E7%BF%92_2_47/",
                "title": "QCQI/演習 2.47",
                "section": "post",
                "date" : "2021.04.20",
                "body": "\\(A\\) と \\(B\\) はエルミート演算子だから、\n\\[A^{\\dagger} = A, B^{\\dagger} = B\\]\nここで \\((i[A, B])^{\\dagger}\\) を計算すると、\n\\begin{eqnarray*} (i[A, B])^{\\dagger} \u0026amp;=\u0026amp; (i(AB - BA))^{\\dagger} \\\\\\\n\u0026amp;=\u0026amp; (i(AB) - i(BA))^{\\dagger} \\end{eqnarray*}\nQCQI/演習 2.14 より、\n\\begin{eqnarray*} \\phantom{(i[A, B])^{\\dagger}} \u0026amp;=\u0026amp; i(BA)^{\\dagger} - i(AB)^{\\dagger} \\\\\\\n\u0026amp;=\u0026amp; iA^{\\dagger}B^{\\dagger}-iB^{\\dagger}A^{\\dagger} \\\\\\\n\u0026amp;=\u0026amp; iAB - iBA \\\\\\\n\u0026amp;=\u0026amp; i(AB - BA) \\\\\\\n\u0026amp;=\u0026amp; i[A, B] \\end{eqnarray*}\nよって \\((i[A, B])^{\\dagger} = i[A,B]\\) なので、\\(i[A, B]\\) はエルミート演算子。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210420102232-qcqi_%E6%BC%94%E7%BF%92_2_48/",
                "title": "QCQI/演習 2.48",
                "section": "post",
                "date" : "2021.04.20",
                "body": "正の行列 \\(P\\) の極分解 正の演算子のエルミート性から正の行列は正規であり、よって \\(P\\) は負でない固有値 \\(\\lambda_i\\) を用いて スペクトル分解できる。\n\\[P = \\sum_i \\lambda_i |i\\rangle\\langle i|\\]\n極分解により、\\(P = UJ\\) を満たす正の演算子の行列表現 \\(J\\) について、\n\\begin{eqnarray*} J \u0026amp;=\u0026amp; \\sqrt{P^{\\dagger}P} \\\\\\\n\u0026amp;=\u0026amp; \\sqrt{\\sum_{i,j}\\lambda_i\\lambda_j |i\\rangle\\langle i|j\\rangle\\langle j|} \\\\\\\n\u0026amp;=\u0026amp; \\sqrt{\\sum_{i,j}\\lambda_i\\lambda_j\\delta_{i,j} |i\\rangle\\langle j|} \\\\\\\n\u0026amp;=\u0026amp; \\sqrt{\\sum_{i}\\lambda_i^2 |i\\rangle\\langle i|} \\\\\\\n\u0026amp;=\u0026amp; P \\end{eqnarray*}\nしたがって \\(U = I\\)\nユニタリー行列 \\(U^{\\prime}\\) の極分解 ユニタリー行列も正規であるから \\(U^{\\prime}\\) はスペクトル分解できる。\n極分解により、\n\\[J = \\sqrt{(U^{\\prime})^{\\dagger}U^{\\prime}} = \\sqrt{I} = I\\]\nしたがって \\(U^{\\prime} = UJ = U\\) より \\(U = U^{\\prime}\\)\nエルミート行列 \\(H\\) の極分解 \\(H\\) をスペクトル分解すると\n\\[H = \\sum_i\\lambda_i|i\\rangle\\langle i|\\]\n極分解により、\\(H = UJ\\) を満たす正の演算子の行列表現 J について、\n\\begin{eqnarray*} J \u0026amp;=\u0026amp; \\sqrt{H^{\\dagger}H} \\\\\\\n\u0026amp;=\u0026amp; \\sqrt{H^2} \\\\\\\n\u0026amp;=\u0026amp; \\sqrt{\\sum_{i,j}\\lambda_i\\lambda_j |i\\rangle\\langle i|j\\rangle\\langle j|} \\\\\\\n\u0026amp;=\u0026amp; \\sqrt{\\sum_{i,j}\\lambda_i\\lambda_j\\delta_{ij} |i\\rangle\\langle j|} \\\\\\\n\u0026amp;=\u0026amp; \\sqrt{\\sum_{i}\\lambda_i^2 |i\\rangle\\langle i|} \\\\\\\n\u0026amp;=\u0026amp; \\sum_{i} |\\lambda_i| |i\\rangle\\langle i| \\end{eqnarray*}\nよって \\(H = U\\sum_{i} |\\lambda_i| |i\\rangle\\langle i|\\)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210420111607-qcqi_%E6%BC%94%E7%BF%92_2_49/",
                "title": "QCQI/演習 2.49",
                "section": "post",
                "date" : "2021.04.20",
                "body": "正規行列 \\(A\\) を外積表現 (スペクトル分解) すると、\n\\[A = \\sum_i\\lambda_i|i\\rangle\\langle i|\\]\n極分解により、\\(A = UJ\\) を満たす正の演算子の行列表現 J について、\n\\begin{eqnarray*} J \u0026amp;=\u0026amp; \\sqrt{A^{\\dagger}A} \\\\\\\n\u0026amp;=\u0026amp; \\sqrt{\\sum_{i,j}\\lambda_i^{\\ast}\\lambda_j |i\\rangle\\langle i|j\\rangle\\langle j|} \\\\\\\n\u0026amp;=\u0026amp; \\sqrt{\\sum_{i,j}\\lambda_i^{\\ast}\\lambda_j\\delta_{ij} |i\\rangle\\langle j|} \\\\\\\n\u0026amp;=\u0026amp; \\sqrt{\\sum_{i}|\\lambda_i|^2 |i\\rangle\\langle i|} \\\\\\\n\u0026amp;=\u0026amp; \\sum_{i} |\\lambda_i| |i\\rangle\\langle i| \\end{eqnarray*}\nよって \\(A = U\\sum_{i} |\\lambda_i| |i\\rangle\\langle i|\\)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210420094316-%E6%A5%B5%E5%88%86%E8%A7%A3/",
                "title": "極分解",
                "section": "post",
                "date" : "2021.04.20",
                "body": "極分解は特異値分解と同じく、演算子をより簡単なユニタリー演算子と正の演算子の積に分割するテクニック。\n\\(A\\) をベクトル空間 \\(V\\) 上の演算子とする。次式を満たすユニタリー演算子 \\(U\\) と正の演算子 \\(J\\), \\(K\\) が存在する。\n\\[A= UJ = KU\\]\nこの式を満たす一意の正の演算子 \\(J\\), \\(K\\) は \\(J \\equiv \\sqrt{A^{\\dagger}A}\\), \\(K \\equiv \\sqrt{AA^{\\dagger}}\\) で定義される。さらにもし \\(A\\) が可逆ならば \\(U\\) は一意に決まる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210420095524-%E7%89%B9%E7%95%B0%E5%80%A4%E5%88%86%E8%A7%A3/",
                "title": "特異値分解",
                "section": "post",
                "date" : "2021.04.20",
                "body": "特異値分解は極分解とスペクトル分解を組合わせたもの。\n\\(A\\) を正方行列とする。このとき\n\\[A = UDV\\]\nを満たすユニタリー行列 \\(U\\), \\(V\\) と負でない要素をもつ対角行列 \\(D\\) が存在する。\\(D\\) の対角要素を \\(A\\) の特異値と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210417101015-qcqi_%E6%BC%94%E7%BF%92_2_40/",
                "title": "QCQI/演習 2.40",
                "section": "post",
                "date" : "2021.04.17",
                "body": "\\begin{eqnarray*} [X, Y] \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} - \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; \\begin{bmatrix} i \u0026amp; 0 \\newline 0 \u0026amp; -i \\end{bmatrix} - \\begin{bmatrix} -i \u0026amp; 0 \\newline 0 \u0026amp; i \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 2i \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 2iZ \\end{eqnarray*}\n\\begin{eqnarray*} [Y, Z] \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} - \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; i \\newline i \u0026amp; 0 \\end{bmatrix} - \\begin{bmatrix} 0 \u0026amp; -i \\newline -i \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 2i \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 2iX \\end{eqnarray*}\n\\begin{eqnarray*} [Z, X] \u0026amp;=\u0026amp; \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} - \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; 1 \\newline -1 \u0026amp; 0 \\end{bmatrix} - \\begin{bmatrix} 0 \u0026amp; -1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; 2 \\newline -2 \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 2i \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 2iY \\end{eqnarray*}\nよってパウリ行列には次の交換関係がある。\n\\[[X, Y] = 2iZ;\\ [Y, Z] = 2iX;\\ [Z, X] = 2iY.\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210417105027-qcqi_%E6%BC%94%E7%BF%92_2_41/",
                "title": "QCQI/演習 2.41",
                "section": "post",
                "date" : "2021.04.17",
                "body": "\\begin{eqnarray*} \\{\\sigma_1, \\sigma_2\\} \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} + \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; \\begin{bmatrix} i \u0026amp; 0 \\newline 0 \u0026amp; -i \\end{bmatrix} + \\begin{bmatrix} -i \u0026amp; 0 \\newline 0 \u0026amp; i \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 0 \\newline \\{\\sigma_2, \\sigma_3\\} \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} + \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; i \\newline i \u0026amp; 0 \\end{bmatrix} + \\begin{bmatrix} 0 \u0026amp; -i \\newline -i \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 0 \\newline \\{\\sigma_1, \\sigma_3\\} \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} + \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; -1 \\newline 1 \u0026amp; 0 \\end{bmatrix} + \\begin{bmatrix} 0 \u0026amp; 1 \\newline -1 \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 0 \\newline \\{\\sigma_2, \\sigma_1\\} \u0026amp;=\u0026amp; \\{\\sigma_1, \\sigma_2\\} = 0 \\newline \\{\\sigma_3, \\sigma_2\\} \u0026amp;=\u0026amp; \\{\\sigma_2, \\sigma_3\\} = 0 \\newline \\{\\sigma_3, \\sigma_1\\} \u0026amp;=\u0026amp; \\{\\sigma_1, \\sigma_3\\} = 0 \\end{eqnarray*}\n\\begin{eqnarray*} \\sigma_0^2 \u0026amp;=\u0026amp; \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} = I \\newline \\sigma_1^2 \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} = I \\newline \\sigma_2^2 \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} = I \\newline \\sigma_3^2 \u0026amp;=\u0026amp; \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} = I \\end{eqnarray*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210417103845-qcqi_%E6%BC%94%E7%BF%92_2_42/",
                "title": "QCQI/演習 2.42",
                "section": "post",
                "date" : "2021.04.17",
                "body": "\\begin{eqnarray*} \\frac{[A, B] + \\{A, B\\}}{2} \u0026amp;=\u0026amp; \\frac{AB - BA + AB + BA}{2} \\\\\\\n\u0026amp;=\u0026amp; \\frac{2AB}{2} \\\\\\\n\u0026amp;=\u0026amp; AB \\end{eqnarray*}\n関連ノート  交換子 反交換子  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210417102909-%E3%83%8F%E3%82%A6%E3%83%AA%E8%A1%8C%E5%88%97%E3%81%AE%E4%BA%A4%E6%8F%9B%E9%96%A2%E4%BF%82/",
                "title": "パウリ行列の交換関係",
                "section": "post",
                "date" : "2021.04.17",
                "body": "パウリ行列には次の交換関係がある。\n\\[[X, Y] = 2iZ;\\ [Y, Z] = 2iX;\\ [Z, X] = 2iY.\\]\n証明は QCQI/演習 2.40 を参照。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210417111543-%E3%83%8F%E3%82%A6%E3%83%AA%E8%A1%8C%E5%88%97%E3%81%AE%E5%8F%8D%E4%BA%A4%E6%8F%9B%E9%96%A2%E4%BF%82/",
                "title": "パウリ行列の反交換関係",
                "section": "post",
                "date" : "2021.04.17",
                "body": "パウリ行列には次の反交換関係がある。\n\\(i \\neq j\\) なる \\(i\\), \\(j\\) が両方とも集合 \\(\\{1, 2, 3\\}\\) から選ばれるとき、\n\\[\\{\\sigma_i, \\sigma_j\\} = 0\\]\n証明は QCQI/演習 2.41 を参照。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210417085905-%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB%E3%81%AE%E6%89%8B%E6%9B%B8%E3%81%8D/",
                "title": "ベクトルの手書き",
                "section": "post",
                "date" : "2021.04.17",
                "body": "  元画像: ベクトルの表記方法より。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210417091256-%E4%BA%A4%E6%8F%9B%E5%AD%90/",
                "title": "交換子",
                "section": "post",
                "date" : "2021.04.17",
                "body": "2 つの演算子の交換子は次式で定義される。\n\\[[A, B] \\equiv AB - BA\\]\nもし \\([A, B] = 0\\) ならば \\(AB = BA\\) であり \\(A\\) と \\(B\\) は可換。\nつまり、交換子は「\\(A\\) と \\(B\\) がどの程度可換性からかけ離れているか」を測る指標の役割を果たす。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210417092048-%E5%8F%8D%E4%BA%A4%E6%8F%9B%E5%AD%90/",
                "title": "反交換子",
                "section": "post",
                "date" : "2021.04.17",
                "body": "2 つの演算子の反交換子は次式で定義される。\n\\[\\{A, B\\} \\equiv AB + BA\\]\nもし \\(\\{A, B\\} = 0\\) ならば \\(A\\) と \\(B\\) は反可換であるという。\n関連ノート  交換子  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210417092753-%E5%90%8C%E6%99%82%E5%AF%BE%E8%A7%92%E5%8C%96/",
                "title": "同時対角化",
                "section": "post",
                "date" : "2021.04.17",
                "body": "エルミート演算子 \\(A\\), \\(B\\) が同時対角化できるとは、\\(A\\), \\(B\\) の固有ベクトルに共通の正規直交集合 \\(|i\\rangle\\) を用いて\n\\[A = \\sum_i a_i |i\\rangle\\langle i|\\] \\[B = \\sum_i b_i |i\\rangle\\langle i|\\]\nと書けること。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210417093847-%E5%90%8C%E6%99%82%E5%AF%BE%E8%A7%92%E5%8C%96%E5%AE%9A%E7%90%86/",
                "title": "同時対角化定理",
                "section": "post",
                "date" : "2021.04.17",
                "body": "2 つの演算子が同時対角化できるかどうかを、簡単な交換子の計算で判定できるという定理。\n\\(A\\) と \\(B\\) がエルミート演算子であるとする。\\(A\\) と \\(B\\) を同時に対角化できる正規直交基底が存在するとき、そのときにのみ \\([A, B] = 0\\) となる。この場合に \\(A\\) と \\(B\\) は同時対角化可能であるという。\nたとえばパウリ行列 \\(X\\) と \\(Y\\) の交換子を計算すると、\n\\begin{eqnarray*} [X, Y] \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} - \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; \\begin{bmatrix} i \u0026amp; 0 \\newline 0 \u0026amp; -i \\end{bmatrix} - \\begin{bmatrix} -i \u0026amp; 0 \\newline 0 \u0026amp; i \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 2i \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; 2iZ \\end{eqnarray*}\nよって \\(X\\) と \\(Y\\) は可換ではなく、同時対角化できない。QCQI/演習 2.11 の計算でも \\(X\\) と \\(Y\\) が共通の固有ベクトルを持たないことが分かるが、このように同時対角化定理からも同じことが予想できる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210415113826-qcqi_%E6%BC%94%E7%BF%92_2_39/",
                "title": "QCQI/演習 2.39",
                "section": "post",
                "date" : "2021.04.15",
                "body": "(1) 内積は第 2 引数に関して線形であることを示す。\n\\begin{eqnarray*} \\left(A, \\sum_i\\lambda_i B_i\\right) \u0026amp;=\u0026amp; \\mathrm{tr}\\left(A^{\\dagger}\\left(\\sum_i\\lambda_i B_i\\right)\\right) \\\\\\\n\u0026amp;=\u0026amp; \\mathrm{tr}\\left(\\sum_i \\lambda_i A^{\\dagger} B_i\\right) \\\\\\\n\u0026amp;=\u0026amp; \\sum_i \\lambda_i \\mathrm{tr}(A^{\\dagger} B_i) \\\\\\\n\u0026amp;=\u0026amp; \\sum_i \\lambda_i (A, B_i) \\end{eqnarray*}\n内積の対称性を示す。\n\\begin{eqnarray*} (B, A) \u0026amp;=\u0026amp; \\mathrm{tr}(B^{\\dagger}, A) \\\\\\\n\u0026amp;=\u0026amp; \\mathrm{tr}((A^{\\dagger}B)^{\\dagger}) \\\\\\\n\u0026amp;=\u0026amp; \\mathrm{tr}(A^{\\dagger}B)^{\\ast} \\\\\\\n\u0026amp;=\u0026amp; (A, B)^{\\ast} \\end{eqnarray*}\n内積の正値性を示す。\n\\begin{eqnarray*} (A, A) \u0026amp;=\u0026amp; \\mathrm{tr}(A^{\\dagger}A) \\\\\\\n\u0026amp;=\u0026amp; \\sum_{i,j} A^{\\ast}_{ji} A_{ji} \\\\\\\n\u0026amp;\\geq\u0026amp; 0 \\end{eqnarray*}\n等号が成り立つのは任意の \\(i, j\\) に関して \\(A_{ji} = 0\\) すなわち \\(A =0\\) のときのみ。\n(2) \\(V\\) の要素の演算子の行列表現は \\(d \\times d\\) の正方行列で表すことができる。線形独立な \\(d \\times d\\) 行列は要素の数つまり \\(d \\times d = d^2\\) 個あるので、\\(L_V\\) は \\(d^2\\) 次元。\n(3) "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210415083133-%E3%82%B9%E3%83%88%E3%83%A9%E3%83%B3%E3%82%AF_%E7%B7%9A%E5%BD%A2%E4%BB%A3%E6%95%B0%E3%82%A4%E3%83%B3%E3%83%88%E3%83%AD%E3%82%BF%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3/",
                "title": "ストラング: 線形代数イントロダクション",
                "section": "post",
                "date" : "2021.04.15",
                "body": "  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210415082319-%E7%B7%9A%E5%BD%A2%E4%BB%A3%E6%95%B0%E3%82%BB%E3%83%9F%E3%83%8A%E3%83%BC/",
                "title": "線形代数セミナー",
                "section": "post",
                "date" : "2021.04.15",
                "body": "   共立出版のページ 正誤表  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210415082141-%E7%B7%9A%E5%BD%A2%E7%A9%BA%E9%96%93/",
                "title": "線形空間",
                "section": "post",
                "date" : "2021.04.15",
                "body": "ベクトル空間の別名。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413161116-qcqi_%E6%BC%94%E7%BF%92_2_33/",
                "title": "QCQI/演習 2.33",
                "section": "post",
                "date" : "2021.04.14",
                "body": "\\begin{eqnarray*} H \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}[(|0\\rangle + |1\\rangle)\\langle 0| + (|0\\rangle - |1\\rangle)\\langle 1|] \\\\\\\n\u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(|0\\rangle\\langle 0| + |1\\rangle\\langle 0| + |0\\rangle\\langle 1| - |1\\rangle\\langle 1|) \\\\\\\n\u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}\\sum_{x,y}(-1)^{x \\cdot y}|x\\rangle\\langle y| \\end{eqnarray*}\nよって\n\\begin{eqnarray*} H^{\\otimes n} \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}\\sum_{x_1,y_1}(-1)^{x_1 \\cdot y_1}|x_1\\rangle\\langle y_1| \\otimes \\frac{1}{\\sqrt{2}}\\sum_{x_2,y_2}(-1)^{x_2 \\cdot y_2}|x_2\\rangle\\langle y_2| \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}}\\sum_{x_n,y_n}(-1)^{x_n \\cdot y_n}|x_n\\rangle\\langle y_n| \\\\\\\n\u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2^n}}\\sum_{x,y}(-1)^{x \\cdot y}|x\\rangle\\langle y| \\end{eqnarray*}\n\\(H^{\\otimes 2}\\) を計算すると、\n\\begin{eqnarray*} H^{\\otimes 2} \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2^2}}\\sum_{x,y}(-1)^{x \\cdot y}|x\\rangle\\langle y| \\newline \u0026amp;=\u0026amp; \\frac{1}{2}[|00 \\rangle\\langle 00| + |01 \\rangle\\langle 00| + |00 \\rangle\\langle 01| - |01 \\rangle\\langle 01| \\newline \u0026amp;\\phantom{=}\u0026amp; + |10 \\rangle\\langle 00| + |11 \\rangle\\langle 00| + |10 \\rangle\\langle 01| - |11 \\rangle\\langle 01| \\newline \u0026amp;\\phantom{=}\u0026amp; + |00 \\rangle\\langle 10| + |01 \\rangle\\langle 10| + |00 \\rangle\\langle 11| - |01 \\rangle\\langle 11| \\newline \u0026amp;\\phantom{=}\u0026amp; - |10 \\rangle\\langle 10| - |11 \\rangle\\langle 10| - |10 \\rangle\\langle 11| + |11 \\rangle\\langle 11|] \\newline \u0026amp;=\u0026amp; \\frac{1}{2}\\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\newline 1 \u0026amp; -1 \u0026amp; 1 \u0026amp; -1 \\newline 1 \u0026amp; 1 \u0026amp; -1 \u0026amp; -1 \\newline 1 \u0026amp; -1 \u0026amp; -1 \u0026amp; 1 \\end{bmatrix} \\end{eqnarray*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210414091444-qcqi_%E6%BC%94%E7%BF%92_2_34/",
                "title": "QCQI/演習 2.34",
                "section": "post",
                "date" : "2021.04.14",
                "body": "\\begin{equation*} A = \\begin{bmatrix} 4 \u0026amp; 3 \\newline 3 \u0026amp; 4 \\end{bmatrix} \\end{equation*}\nとすると、\n\\begin{equation*} A^{\\dagger} = \\begin{bmatrix} 4 \u0026amp; 3 \\newline 3 \u0026amp; 4 \\end{bmatrix} = A \\end{equation*}\nなので、\\(A^{\\dagger}A = AA = AA^{\\dagger}\\) となり \\(A\\) は正規である。よって \\(A\\) はスペクトル分解できる。\n\\(A\\) の固有値 \\(\\lambda\\) を求めると、\n\\begin{align*} \u0026amp; \\mathrm{det}|A - \\lambda I| = \\begin{bmatrix} 4 - \\lambda \u0026amp; 3 \\newline 3 \u0026amp; 4 - \\lambda \\end{bmatrix} = (4 - \\lambda)^2 - 9 = 0 \\newline \u0026amp; \\therefore \\lambda = 1, 7 \\end{align*}\n固有値 \\(\\lambda = 1\\) の時の固有ベクトル \\(|\\lambda_1\\rangle\\) は、\n\\begin{align*} \u0026amp; \\mathrm{det}|A - \\lambda I| = \\begin{bmatrix} 4 - \\lambda \u0026amp; 3 \\newline 3 \u0026amp; 4 - \\lambda \\end{bmatrix} \\begin{bmatrix} a \\newline b \\end{bmatrix} = \\begin{bmatrix} 3 \u0026amp; 3 \\newline 3 \u0026amp; 3 \\end{bmatrix} \\begin{bmatrix} a \\newline b \\end{bmatrix} = \\begin{bmatrix} 0 \\newline 0 \\end{bmatrix} \\newline \u0026amp; \\Rightarrow |\\lambda_1\\rangle = a \\begin{bmatrix} 1 \\newline -1 \\end{bmatrix} \\end{align*}\n\\(|\\lambda_1\\rangle\\) を 正規化すると\n\\begin{eqnarray*} |\\lambda_1\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline -1 \\end{bmatrix} \\end{eqnarray*}\n同様に、固有値 \\(\\lambda = 7\\) の時の正規化した固有ベクトル \\(|\\lambda_7\\rangle\\) は、\n\\begin{eqnarray*} |\\lambda_7\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline 1 \\end{bmatrix} \\end{eqnarray*}\nよって \\(A\\) はスペクトル分解により次のように書ける\n\\begin{equation*} A = \\lambda_1|\\lambda_1\\rangle\\langle\\lambda_1| + \\lambda_7|\\lambda_7\\rangle\\langle\\lambda_7| = |\\lambda_1\\rangle\\langle\\lambda_1| + 7|\\lambda_7\\rangle\\langle\\lambda_7| \\end{equation*}\nよって \\(A\\) の平方根 \\(\\sqrt{A}\\) は、\n\\begin{eqnarray*} \\sqrt{A} \u0026amp;=\u0026amp; \\sqrt{1}|\\lambda_1\\rangle\\langle\\lambda_1| + \\sqrt{7}|\\lambda_7\\rangle\\langle\\lambda_7| \\newline \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline -1 \\end{bmatrix} \\times \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \u0026amp; -1 \\end{bmatrix} + \\sqrt{7} \\times \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline 1 \\end{bmatrix} \\times \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \u0026amp; 1 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; \\frac{1}{2} \\begin{bmatrix} 1 + \\sqrt{7} \u0026amp; -1 + \\sqrt{7} \\newline -1 + \\sqrt{7} \u0026amp; 1 + \\sqrt{7} \\end{bmatrix} \\end{eqnarray*}\n同様に \\(A\\) の対数 \\(\\ln{A}\\) は、\n\\begin{eqnarray*} \\ln{A} \u0026amp;=\u0026amp; \\ln{1}|\\lambda_1\\rangle\\langle\\lambda_1| + \\ln{7}|\\lambda_7\\rangle\\langle\\lambda_7| \\newline \u0026amp;=\u0026amp; \\ln{7} \\times \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline 1 \\end{bmatrix} \\times \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \u0026amp; 1 \\end{bmatrix} \\newline \u0026amp;=\u0026amp; \\frac{\\ln{7}}{2} \\begin{bmatrix} 1 \u0026amp; 1 \\newline 1 \u0026amp; 1 \\end{bmatrix} \\end{eqnarray*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210414112724-qcqi_%E6%BC%94%E7%BF%92_2_35/",
                "title": "QCQI/演習 2.35",
                "section": "post",
                "date" : "2021.04.14",
                "body": "\\begin{equation*} \\vec{v} = \\begin{bmatrix} v_1 \\newline v_2 \\newline v_3 \\end{bmatrix} \\end{equation*}\nとすると、定義より\n\\begin{eqnarray*} \\vec{v} \\cdot \\vec{\\sigma} \u0026amp;=\u0026amp; v_1 X + v_2 Y + v_3 Z \\newline \u0026amp;=\u0026amp; v_1 \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} + v_2 \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} + v_3 \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} = \\begin{bmatrix} v_3 \u0026amp; v_1 - iv_2 \\newline v_1 + iv_2 \u0026amp; -v_3 \\end{bmatrix} \\end{eqnarray*}\nよって、\n\\begin{eqnarray*} \\mathrm{det}(\\vec{v} \\cdot \\vec{\\sigma} - \\lambda I) \u0026amp;=\u0026amp; -(v_3 - \\lambda)(v_3 + \\lambda) - (v_1 - iv_2)(v_1 + iv_2) \\newline \u0026amp;=\u0026amp; \\lambda^2 - v_3^2 - v_1^2 - v_2^2 \\newline \u0026amp;=\u0026amp; \\lambda^2 - (v_1^2 + v_2^2 + v_3^2) \\newline \u0026amp;=\u0026amp; \\lambda^2 - 1 = 0 \\newline \\therefore \\lambda = \\pm 1 \\end{eqnarray*}\n(\\(\\vec{v}\\) は 3 次元実数単位ベクトルであるから、\\(v_1^2 + v_2^2 + v_3^2 = 1\\) を使った)\nよってスペクトル分解により\n\\begin{equation*} \\vec{v} \\cdot \\vec{\\sigma} = |\\lambda_1\\rangle\\langle\\lambda_1| - |\\lambda_{-1}\\rangle\\langle\\lambda_{-1}| \\end{equation*}\n演算子の関数により、\n\\begin{eqnarray*} \\mathrm{exp}(i\\theta\\vec{v}\\cdot\\vec{\\sigma}) \u0026amp;=\u0026amp; \\mathrm{exp}(i\\theta)|\\lambda_1\\rangle\\langle\\lambda_1| + \\mathrm{exp}(-i\\theta)|\\lambda_{-1}\\rangle\\langle\\lambda_{-1}| \\newline \u0026amp;=\u0026amp; (\\cos\\theta + i \\sin\\theta)|\\lambda_1\\rangle\\langle\\lambda_1| + (\\cos\\theta - i\\sin\\theta)|\\lambda_{-1}\\rangle\\langle\\lambda_{-1}| \\newline \u0026amp;=\u0026amp; \\cos\\theta(|\\lambda_1\\rangle\\langle\\lambda_1| + |\\lambda_{-1}\\rangle\\langle\\lambda_{-1}|) + i\\sin\\theta(|\\lambda_1\\rangle\\langle\\lambda_1| - |\\lambda_{-1}\\rangle\\langle\\lambda_{-1}|) \\newline \u0026amp;=\u0026amp; \\cos(\\theta)I + i\\sin(\\theta)(\\vec{v} \\cdot \\vec{\\sigma}) \\end{eqnarray*}\n完全性関係より \\(|\\lambda_1\\rangle\\langle\\lambda_1| + |\\lambda_{-1}\\rangle\\langle\\lambda_{-1}| = I\\) を使った)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210414135730-qcqi_%E6%BC%94%E7%BF%92_2_36/",
                "title": "QCQI/演習 2.36",
                "section": "post",
                "date" : "2021.04.14",
                "body": "パウリ行列の \\(X\\), \\(Y\\), \\(Z\\) について、それぞれトレースを計算すると、\n\\begin{equation*} \\mathrm{tr}(X) = \\mathrm{tr} \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} = 0 \\end{equation*}\n\\begin{equation*} \\mathrm{tr}(Y) = \\mathrm{tr} \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} = 0 \\end{equation*}\n\\begin{equation*} \\mathrm{tr}(Z) = \\mathrm{tr} \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} = 0 \\end{equation*}\nよってパウリ行列のトレースは \\(I\\) 以外はゼロ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210414140612-qcqi_%E6%BC%94%E7%BF%92_2_37/",
                "title": "QCQI/演習 2.37",
                "section": "post",
                "date" : "2021.04.14",
                "body": "\\[\\mathrm{tr}(AB) = \\sum_i (AB)_{ii} = \\sum_j\\left(\\sum_j A_{ij}B_{ji}\\right) = \\sum_j\\left(\\sum_i A_{ji}B_{ij}\\right) = \\sum_j (BA)_{jj} = \\mathrm{tr}(BA)\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210414142737-qcqi_%E6%BC%94%E7%BF%92_2_38/",
                "title": "QCQI/演習 2.38",
                "section": "post",
                "date" : "2021.04.14",
                "body": "\\[\\mathrm{tr}(A + B) = \\sum_i (A + B)_{ii} = \\sum_i (A_{ii} + B_{ii}) = \\sum_i A_{ii} + \\sum_i B_{ii} = \\mathrm{tr}(A) + \\mathrm{tr}(B)\\]\n\\[\\mathrm{tr}(zA) = \\sum_i zA_{ii} = z\\sum_i A_{ii} = z\\mathrm{tr}(A)\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210414134207-%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B9/",
                "title": "トレース",
                "section": "post",
                "date" : "2021.04.14",
                "body": "演算子の関数の 1 つで、行列の対角要素を合計する関数。\n\\[\\mathrm{tr}(A) \\equiv \\sum_i A_{ii}\\]\nトレースの性質  トレースの巡回不変性 トレースの線形性  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210414141407-%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B9%E3%81%AE%E5%B7%A1%E5%9B%9E%E4%B8%8D%E5%A4%89%E6%80%A7/",
                "title": "トレースの巡回不変性",
                "section": "post",
                "date" : "2021.04.14",
                "body": "\\(A\\) と \\(B\\) が 2 つの演算子ならば\n\\[\\mathrm{tr}(AB) = \\mathrm{tr}(BA)\\]\nが成り立ち、これをトレースの巡回不変性と呼ぶ。証明は QCQI/演習 2.37 を参照。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210414142300-%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B9%E3%81%AE%E7%B7%9A%E5%BD%A2%E6%80%A7/",
                "title": "トレースの線形性",
                "section": "post",
                "date" : "2021.04.14",
                "body": "\\(A\\) と \\(B\\) が演算子、\\(z\\) が任意の複素数ならば、トレースは線形。すなわち、\n\\[\\mathrm{tr}(A + B) = \\mathrm{tr}(A) + \\mathrm{tr}(B)\\]\n\\[\\mathrm{tr}(zA) = z\\mathrm{tr}(A)\\]\n証明は QCQI/演習 2.38 を参照。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210414100121-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E9%96%A2%E6%95%B0/",
                "title": "演算子の関数",
                "section": "post",
                "date" : "2021.04.14",
                "body": "\\(\\sqrt{NOT}\\) のような演算子やその行列表現の平方根、または対数、ベキ指数などを求める方法。\n正規演算子 \\(A\\) のスペクトル分解を \\(A = \\sum_a a|a\\rangle \\langle a|\\) とする。このとき \\(f(A) \\equiv \\sum_a f(a)|a\\rangle \\langle a|\\) で \\(A\\) の行列の関数を定義できる。\n例  行列の平方根、対数 (QCQI/演習 2.34) パウリ行列の指数関数 (QCQI/演習 2.35)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413112519-k_%E5%80%8B%E3%81%AE%E5%90%8C%E4%B8%80%E3%81%AE%E3%83%86%E3%83%B3%E3%82%BD%E3%83%AB%E7%A9%8D%E8%A8%98%E5%8F%B7/",
                "title": "k 個の同一のテンソル積記号",
                "section": "post",
                "date" : "2021.04.13",
                "body": "\\(|\\psi\\rangle\\) それ自身のテンソル積を \\(k\\) 回施したものを \\(|\\psi\\rangle^{\\otimes k}\\) と書く。たとえば \\(|\\psi\\rangle^{\\otimes 2} = |\\psi\\rangle \\otimes |\\psi\\rangle\\)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413114431-qcqi_%E6%BC%94%E7%BF%92_2_26/",
                "title": "QCQI/演習 2.26",
                "section": "post",
                "date" : "2021.04.13",
                "body": "テンソル積で計算:\n\\begin{eqnarray*} |\\psi\\rangle^{\\otimes 2} \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\\\\\\n\u0026amp;=\u0026amp; \\frac{1}{2}(|0\\rangle|0\\rangle + |0\\rangle|1\\rangle + |1\\rangle|0\\rangle + |1\\rangle|1\\rangle) \\\\\\\n\\\\\\\n|\\psi\\rangle^{\\otimes 3} \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\\\\\\n\u0026amp;=\u0026amp; \\frac{1}{2\\sqrt{2}}(|0\\rangle|0\\rangle + |0\\rangle|1\\rangle + |1\\rangle|0\\rangle + |1\\rangle|1\\rangle)(|0\\rangle + |1\\rangle) \\\\\\\n\u0026amp;=\u0026amp; \\frac{1}{2\\sqrt{2}}(|0\\rangle|0\\rangle|0\\rangle + |0\\rangle|0\\rangle|1\\rangle + |0\\rangle|1\\rangle|0\\rangle + |0\\rangle|1\\rangle|1\\rangle + |1\\rangle|0\\rangle|0\\rangle + |1\\rangle|0\\rangle|1\\rangle + |1\\rangle|1\\rangle|0\\rangle + |1\\rangle|1\\rangle|1\\rangle) \\end{eqnarray*}\nクロネッカー積で計算:\n\\begin{equation*} |\\psi\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline 1 \\end{bmatrix} \\end{equation*}\n\\begin{equation*} |\\psi\\rangle^{\\otimes 2} = \\frac{1}{2} \\begin{bmatrix} 1 \\newline 1 \\newline 1 \\newline 1 \\end{bmatrix} \\end{equation*}\n\\begin{equation*} |\\psi\\rangle^{\\otimes 3} = \\frac{1}{2\\sqrt{2}} \\begin{bmatrix} 1 \\newline 1 \\newline 1 \\newline 1 \\newline 1 \\newline 1 \\newline 1 \\newline 1 \\end{bmatrix} \\end{equation*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413134407-qcqi_%E6%BC%94%E7%BF%92_2_27/",
                "title": "QCQI/演習 2.27",
                "section": "post",
                "date" : "2021.04.13",
                "body": "\\begin{equation*} X \\otimes Z = \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\otimes \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\newline 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \\newline 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\newline 0 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix} \\end{equation*}\n\\begin{equation*} I \\otimes X = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} \\otimes \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\newline 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\newline 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\newline 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\end{equation*}\n\\begin{equation*} X \\otimes I = \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\otimes \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\newline 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\newline 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix} \\end{equation*}\n\\(I \\otimes X \\neq X \\otimes I\\) より、テンソル積は可換ではない。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413140004-qcqi_%E6%BC%94%E7%BF%92_2_28/",
                "title": "QCQI/演習 2.28",
                "section": "post",
                "date" : "2021.04.13",
                "body": "\\(A\\) は \\(m\\) 行 \\(n\\) 列の行列、\\(B\\) は任意の大きさの行列とすると、\n転置の分配則 \\begin{equation*} (A \\otimes B)^T = \\begin{bmatrix} A_{11}B \u0026amp; A_{12}B \u0026amp; \\ldots \u0026amp; A_{1n}B \\newline A_{21}B \u0026amp; A_{22}B \u0026amp; \\ldots \u0026amp; A_{2n}B \\newline \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\newline A_{m1}B \u0026amp; A_{m2}B \u0026amp; \\ldots \u0026amp; A_{mn}B \\end{bmatrix}^T = \\begin{bmatrix} A_{11}B^T \u0026amp; A_{21}B^T \u0026amp; \\ldots \u0026amp; A_{m1}B^T \\newline A_{12}B^T \u0026amp; A_{22}B^T \u0026amp; \\ldots \u0026amp; A_{m2}B^T \\newline \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\newline A_{1n}B^T \u0026amp; A_{2n}B^T \u0026amp; \\ldots \u0026amp; A_{mn}B^T \\end{bmatrix} \\end{equation*}\n\\begin{equation*} A^T \\otimes B^T = \\begin{bmatrix} A_{11} \u0026amp; A_{21} \u0026amp; \\ldots \u0026amp; A_{m1} \\newline A_{12} \u0026amp; A_{22} \u0026amp; \\ldots \u0026amp; A_{m2} \\newline \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\newline A_{1n} \u0026amp; A_{2n} \u0026amp; \\ldots \u0026amp; A_{mn} \\end{bmatrix} \\otimes B^T = \\begin{bmatrix} A_{11}B^T \u0026amp; A_{21}B^T \u0026amp; \\ldots \u0026amp; A_{m1}B^T \\newline A_{12}B^T \u0026amp; A_{22}B^T \u0026amp; \\ldots \u0026amp; A_{m2}B^T \\newline \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\newline A_{1n}B^T \u0026amp; A_{2n}B^T \u0026amp; \\ldots \u0026amp; A_{mn}B^T \\end{bmatrix} \\end{equation*}\n以上より\n\\[(A \\otimes B)^T = A^T \\otimes B^T\\]\nよって転置の分配則がテンソル積に適用できる。\n複素共役の分配則 \\begin{equation*} (A \\otimes B)^{\\ast} = \\begin{bmatrix} A_{11}B \u0026amp; A_{12}B \u0026amp; \\ldots \u0026amp; A_{1n}B \\newline A_{21}B \u0026amp; A_{22}B \u0026amp; \\ldots \u0026amp; A_{2n}B \\newline \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\newline A_{m1}B \u0026amp; A_{m2}B \u0026amp; \\ldots \u0026amp; A_{mn}B \\end{bmatrix}^{\\ast} = \\begin{bmatrix} A_{11}^{\\ast}B^{\\ast} \u0026amp; A_{12}^{\\ast}B^{\\ast} \u0026amp; \\ldots \u0026amp; A_{1n}^{\\ast}B^{\\ast} \\newline A_{21}^{\\ast}B^{\\ast} \u0026amp; A_{22}^{\\ast}B^{\\ast} \u0026amp; \\ldots \u0026amp; A_{2n}^{\\ast}B^{\\ast} \\newline \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\newline A_{m1}^{\\ast}B^{\\ast} \u0026amp; A_{m2}^{\\ast}B^{\\ast} \u0026amp; \\ldots \u0026amp; A_{mn}^{\\ast}B^{\\ast} \\end{bmatrix} \\end{equation*}\n\\begin{equation*} A^{\\ast} \\otimes B^{\\ast} = \\begin{bmatrix} A_{11}^{\\ast}B^{\\ast} \u0026amp; A_{12}^{\\ast}B^{\\ast} \u0026amp; \\ldots \u0026amp; A_{1n}^{\\ast}B^{\\ast} \\newline A_{21}^{\\ast}B^{\\ast} \u0026amp; A_{22}^{\\ast}B^{\\ast} \u0026amp; \\ldots \u0026amp; A_{2n}^{\\ast}B^{\\ast} \\newline \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\newline A_{m1}^{\\ast}B^{\\ast} \u0026amp; A_{m2}^{\\ast}B^{\\ast} \u0026amp; \\ldots \u0026amp; A_{mn}^{\\ast}B^{\\ast} \\end{bmatrix} \\end{equation*}\n以上より\n\\[(A \\otimes B)^{\\ast} = A^{\\ast} \\otimes B^{\\ast}\\]\nよって複素共役の分配則がテンソル積に適用できる。\n転置共役の分配則 \\begin{eqnarray*} (A \\otimes B)^{\\dagger} \u0026amp;=\u0026amp; ((A \\otimes B)^T)^{\\ast} \\\\\\\n\u0026amp;=\u0026amp; (A^T \\otimes B^T)^{\\ast} \\\\\\\n\u0026amp;=\u0026amp; ((A^T)^{\\ast} \\otimes (B^T)^{\\ast}) \\\\\\\n\u0026amp;=\u0026amp; A^{\\dagger} \\otimes B^{\\dagger} \\end{eqnarray*}\nよって転置共役の分配則がテンソル積に適用できる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413143716-qcqi_%E6%BC%94%E7%BF%92_2_29/",
                "title": "QCQI/演習 2.29",
                "section": "post",
                "date" : "2021.04.13",
                "body": "\\(A\\), \\(B\\) をそれぞれユニタリー演算子とした時に、\\(C = A \\otimes B\\) について \\(C^{\\dagger}C = I\\) を示す。\n\\begin{eqnarray*} (A \\otimes B)^{\\dagger}(A \\otimes B) \u0026amp;=\u0026amp; (A^{\\dagger} \\otimes B^{\\dagger})(A \\otimes B) \\\\\\\n\u0026amp;=\u0026amp; A^{\\dagger}A \\otimes B^{\\dagger}B \\\\\\\n\u0026amp;=\u0026amp; I_A \\otimes I_B \\\\\\\n\u0026amp;=\u0026amp; I \\end{eqnarray*}\nよって \\(A \\otimes B\\) はユニタリー演算子。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413145005-qcqi_%E6%BC%94%E7%BF%92_2_30/",
                "title": "QCQI/演習 2.30",
                "section": "post",
                "date" : "2021.04.13",
                "body": "\\(A\\), \\(B\\) をそれぞれエルミート演算子とした時に、\\(C = A \\otimes B\\) について \\(C^{\\dagger} = C\\) を示す。\n\\begin{eqnarray*} (A \\otimes B)^{\\dagger} \u0026amp;=\u0026amp; (A^{\\dagger} \\otimes B^{\\dagger}) \\\\\\\n\u0026amp;=\u0026amp; A \\otimes B \\end{eqnarray*}\nよって \\(A \\otimes B\\) はエルミート演算子。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413150636-qcqi_%E6%BC%94%E7%BF%92_2_31/",
                "title": "QCQI/演習 2.31",
                "section": "post",
                "date" : "2021.04.13",
                "body": "演算子 \\(A\\), \\(B\\) が正の演算子であるときに、\\(C = A \\otimes B\\) と任意のベクトル \\(|v\\rangle\\), \\(|w\\rangle\\) について \\((|v\\rangle \\otimes |w\\rangle, C(|v\\rangle \\otimes |w\\rangle))\\) が実数で負でない数であることを示す。\n\\begin{eqnarray*} (|v\\rangle \\otimes |w\\rangle, (A \\otimes B)(|v\\rangle \\otimes |w\\rangle)) \u0026amp;=\u0026amp; (|v\\rangle \\otimes |w\\rangle, A|v\\rangle \\otimes B|w\\rangle) \\\\\\\n\u0026amp;=\u0026amp; \\langle v|A|v\\rangle \\langle w|B|w\\rangle \\geq 0 \\end{eqnarray*}\nよって \\(A \\otimes B\\) は正の演算子。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413155236-qcqi_%E6%BC%94%E7%BF%92_2_32/",
                "title": "QCQI/演習 2.32",
                "section": "post",
                "date" : "2021.04.13",
                "body": "演算子 \\(A\\), \\(B\\) がそれぞれ射影演算子であるときに、\\(C = A \\otimes B\\) について \\(C^2 = C\\) を示す。\n\\begin{eqnarray*} (A \\otimes B)^2 \u0026amp;=\u0026amp; (A \\otimes B)(A \\otimes B) \\\\\\\n\u0026amp;=\u0026amp; AA \\otimes BB \\\\\\\n\u0026amp;=\u0026amp; A \\otimes B \\end{eqnarray*}\nよって \\(A \\otimes B\\) は射影演算子。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413103054-%E3%82%AF%E3%83%AD%E3%83%8D%E3%83%83%E3%82%AB%E3%83%BC%E7%A9%8D/",
                "title": "クロネッカー積",
                "section": "post",
                "date" : "2021.04.13",
                "body": "テンソル積を具体的な行列表現にしたもの。\n\\(A\\) は \\(m\\) 行 \\(n\\) 列の行列、B は \\(p\\) 行 \\(q\\) 列の行列とすると、このとき \\(A \\otimes B\\) の行列表現が次のように得られる。\n\\begin{equation*} A \\otimes B \\equiv \\left.\\left[ \\vphantom{\\begin{array}{c} A_{11}B \\newline A_{21}B \\newline \\vdots \\newline A_{m1}B \\end{array}} \\smash{\\overbrace{ \\begin{array}{cccc} A_{11}B \u0026amp; A_{12}B \u0026amp; \\ldots \u0026amp; A_{1n}B \\newline A_{21}B \u0026amp; A_{22}B \u0026amp; \\ldots \u0026amp; A_{2n}B \\newline \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\newline A_{m1}B \u0026amp; A_{m2}B \u0026amp; \\ldots \u0026amp; A_{mn}B \\end{array} }^{nq \\text{ 列}}} \\right]\\right\\} mp\\text{ 行} \\end{equation*}\n具体的にはたとえば、\n\\begin{equation*} \\begin{bmatrix} 1 \\newline 2 \\end{bmatrix} \\otimes \\begin{bmatrix} 2 \\newline 3 \\end{bmatrix} = \\begin{bmatrix} 1 \\times 2 \\newline 1 \\times 3 \\newline 2 \\times 2 \\newline 2 \\times 3 \\end{bmatrix} = \\begin{bmatrix} 2 \\newline 3 \\newline 4 \\newline 6 \\end{bmatrix} \\end{equation*}\nパウリ行列 \\(X\\), \\(Y\\) のテンソル積は、\n\\begin{equation*} X \\otimes Y = \\begin{bmatrix} 0 \\cdot Y \u0026amp; 1 \\cdot Y \\newline 1 \\cdot Y \u0026amp; 0 \\cdot Y \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -i \\newline 0 \u0026amp; 0 \u0026amp; i \u0026amp; 0 \\newline 0 \u0026amp; -i \u0026amp; 0 \u0026amp; 0 \\newline i \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix} \\end{equation*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413093619-%E3%83%86%E3%83%B3%E3%82%BD%E3%83%AB%E7%A9%8D%E4%B8%8A%E3%81%AE%E5%86%85%E7%A9%8D/",
                "title": "テンソル積上の内積",
                "section": "post",
                "date" : "2021.04.13",
                "body": "ベクトル空間 \\(V\\), \\(W\\) 上の内積を使って \\(V \\otimes W\\) 上の内積を自然に定義できる。\n\\[\\left(\\sum_i a_i|v_i\\rangle \\otimes |w_i\\rangle, \\sum_j b_j |v_j^{\\prime}\\rangle \\otimes |w_j^{\\prime}\\rangle \\right) \\equiv \\sum_{ij} a_i^{\\ast}b_j \\langle v_i|v_j^{\\prime}\\rangle \\langle w_i|w_j^{\\prime}\\rangle\\]\nこの内積の定義から内積空間 \\(V \\otimes W\\) は転置共役性、ユニタリー性、正規性、エルミート性などの性質を継承する。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210413080719-%E3%83%86%E3%83%B3%E3%82%BD%E3%83%AB%E7%A9%8D%E4%B8%8A%E3%81%AE%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "テンソル積上の演算子",
                "section": "post",
                "date" : "2021.04.13",
                "body": "\\(|v\\rangle\\) と \\(|w\\rangle\\) をベクトル空間 \\(V\\), \\(W\\) のベクトルとしたとき、\\(V \\otimes W\\) 上の演算子 \\(A \\otimes B\\) は次式で定義される。\n\\(A: V \\rightarrow V, B: W \\rightarrow W\\) の場合 \\(A\\) と \\(B\\) をそれぞれ \\(V\\), \\(W\\) 上の演算子とすると、\\(V \\otimes W\\) 上の演算子 \\(A \\otimes B\\) は次式で定義される。\n\\[(A \\otimes B)(|v\\rangle \\otimes |w\\rangle) \\equiv A|v\\rangle \\otimes B|w\\rangle\\]\n\\(A \\otimes B\\) の定義は \\(A \\otimes B\\) の線形性を保って、\\(V \\otimes W\\) の全要素に自然に拡張できる。\n\\[(A \\otimes B)\\left(\\sum_i a_i|v_i\\rangle \\otimes |w_i\\rangle \\right) \\equiv \\sum_i a_i A|v_i\\rangle \\otimes B|w_i\\rangle\\]\nつまり \\(A \\otimes B\\) は \\(V \\otimes W\\) 上で明らかに線形。\n\\(A: V \\rightarrow V^{\\prime}, B: W \\rightarrow W^{\\prime}\\) の場合への拡張 \\(V \\otimes W\\) から \\(V^{\\prime} \\otimes W^{\\prime}\\) に写像する任意の演算子 \\(C\\) は、\\(A\\) と \\(B\\) の線形結合\n\\[C = \\sum_i c_i A_i \\otimes B_i\\]\nで表現される。ここで定義により\n\\[\\left(\\sum_i c_i A_i \\otimes B_i\\right) |v\\rangle \\otimes |w\\rangle \\equiv \\sum_i c_i A_i |v\\rangle \\otimes B_i|w\\rangle\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210412092339-qcqi_%E6%BC%94%E7%BF%92_2_21/",
                "title": "QCQI/演習 2.21",
                "section": "post",
                "date" : "2021.04.12",
                "body": "ベクトル空間 \\(V\\) 上のエルミート演算子 \\(M\\) は \\(V\\) のある正規直交基底に関して対角化可能であることを、\\(V\\) の次元 \\(d\\) に関する帰納法で証明する。\n\\(d=1\\) の場合は自明である。\n\\(d=k\\) の場合成り立つと仮定し、\\(d = k + 1\\) とする。\\(\\lambda\\) を \\(M\\) の固有値、\\(P\\) を固有値 \\(\\lambda\\) の固有空間への射影演算子、\\(Q\\) を直交相補空間への射影とする。\nこのとき\n\\begin{eqnarray*} M \u0026amp;=\u0026amp; IMI \\end{eqnarray*}\n正規直交相補演算子の定義より、\\(I = P + Q\\) だから、\n\\begin{eqnarray*} \\phantom{M} \u0026amp;=\u0026amp; (P + Q)M(P + Q) \\\\\\\n\u0026amp;=\u0026amp; PMP + QMP + PMQ + QMQ \\end{eqnarray*}\nである。\n \\(PMP\\) については明らかに \\(PMP = \\lambda P\\) であることから \\(PMP\\) は部分空間 \\(P\\) における正規直交基底に関して対角。 \\(QMP\\) については \\(M\\) は部分空間 \\(P\\) をそれ自身に変換するので \\(QMP = 0\\). \\(PMQ\\) については \\(P\\), \\(M\\), \\(Q\\) がエルミートであることから \\((PMQ)^{\\dagger} = QMP = 0\\). よって \\(PMQ = 0\\). \\(QMQ\\) については \\(M\\), \\(Q\\) がエルミートであることからただちにこれもエルミートであることがわかるから、帰納法の仮定により部分空間 \\(Q\\) における正規直交基底に関して対角。  したがって、\\(M = PMP + QMQ\\) は \\(V\\) のある正規直交基底に関して対角である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210412111628-qcqi_%E6%BC%94%E7%BF%92_2_22/",
                "title": "QCQI/演習 2.22",
                "section": "post",
                "date" : "2021.04.12",
                "body": "エルミート演算子 \\(A\\) が 2 つの異なる固有値 \\(v\\), \\(w\\) を持つとする。QCQI/演習 2.17 から、これらの固有値は実数である。\\(v\\), \\(w\\) に対する固有ベクトルをそれぞれ \\(|v\\rangle\\), \\(|w\\rangle\\) とすると、\n\\[v\\langle v|w \\rangle = (v|v\\rangle, |w\\rangle) = (A|v\\rangle, |w\\rangle) = (|v\\rangle, A^{\\dagger}|w\\rangle) = (|v\\rangle, A|w\\rangle) = (|v\\rangle, w|w\\rangle) = w\\langle v|w \\rangle\\]\nよって \\((v - w)\\langle v|w \\rangle = 0\\) であり、\\(v \\neq w\\) なので \\(\\langle v|w \\rangle = 0\\) である。したがって \\(|v\\rangle\\) と \\(|w\\rangle\\) は直交する。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210412113913-qcqi_%E6%BC%94%E7%BF%92_2_24/",
                "title": "QCQI/演習 2.24",
                "section": "post",
                "date" : "2021.04.12",
                "body": "\\(A\\) を正の演算子とする。\n\\[B = \\frac{A + A^{\\dagger}}{2}, C = \\frac{A - A^{\\dagger}}{2i}\\]\nと置くと、\\(A\\) は次のように書ける\n\\begin{eqnarray*} A \u0026amp;=\u0026amp; \\frac{A + A^{\\dagger}}{2} + i\\frac{A - A^{\\dagger}}{2i} \\\\\\\n\u0026amp;=\u0026amp; B + iC \\end{eqnarray*}\nこのとき、\n\\begin{eqnarray*} (|v\\rangle, A|v\\rangle) \u0026amp;=\u0026amp; (|v\\rangle, (B + iC)|v\\rangle) \\\\\\\n\u0026amp;=\u0026amp; (|v\\rangle, B|v\\rangle) + i(|v\\rangle, C|v\\rangle) \\end{eqnarray*}\n\\(A\\) は正の演算子なので複素数の項 \\(i(|v\\rangle, C|v\\rangle) = 0\\) となり、\\(C = \\frac{A - A^{\\dagger}}{2i} = 0\\) である。よって \\(A = A^{\\dagger}\\) であり、\\(A\\) はエルミート演算子である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210412122826-%E3%83%86%E3%83%B3%E3%82%BD%E3%83%AB%E7%A9%8D%E3%81%AE%E5%8F%8C%E7%B7%9A%E5%BD%A2%E6%80%A7/",
                "title": "テンソル積の双線形性",
                "section": "post",
                "date" : "2021.04.12",
                "body": "\\(V\\) と \\(W\\) をそれぞれヒルベルト空間とすると、テンソル積は次の基本的性質を満たし、これを双線形性と呼ぶ。\n  任意のスカラー \\(z\\), \\(V\\) の要素 \\(|v\\rangle\\), \\(W\\) の要素 \\(|w\\rangle\\) に対して、 \\[z(|v\\rangle \\otimes |w\\rangle) = (z|v\\rangle) \\otimes |w\\rangle = |v\\rangle \\otimes (z|w\\rangle)\\]\n  \\(V\\) の任意の要素 \\(|v_1\\rangle\\) と \\(|v_2\\rangle\\), \\(W\\) の要素 \\(|w\\rangle\\) に対して、 \\[(|v_1\\rangle + |v_2\\rangle) \\otimes |w\\rangle = |v_1\\rangle \\otimes |w\\rangle + |v_2\\rangle \\otimes |w\\rangle\\]\n  \\[|v\\rangle \\otimes (|w_1\\rangle + |w_2\\rangle) = |v\\rangle \\otimes |w_1\\rangle + |v\\rangle \\otimes |w_2\\rangle\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210412115345-%E6%AD%A3%E3%81%AE%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E3%82%A8%E3%83%AB%E3%83%9F%E3%83%BC%E3%83%88%E6%80%A7/",
                "title": "正の演算子のエルミート性",
                "section": "post",
                "date" : "2021.04.12",
                "body": "正の演算子は必ずエルミート演算子となる。証明はQCQI/演習 2.24を参照。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210412085137-%E9%87%8F%E5%AD%90%E6%83%85%E5%A0%B1%E7%A7%91%E5%AD%A6%E5%85%A5%E9%96%80/",
                "title": "量子情報科学入門",
                "section": "post",
                "date" : "2021.04.12",
                "body": "  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210411140952-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%BC%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "ユニタリー演算子",
                "section": "post",
                "date" : "2021.04.11",
                "body": "\\(U^{\\dagger}U = I\\) ならば演算子 \\(U\\) はユニタリーであるという。\nユニタリー演算子は \\(UU^{\\dagger} = I\\) も満たすので、\\(U\\) は正規でありスペクトル分解ができる。\nユニタリー演算子の例  パウリ行列 アダマールゲート  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409103428-qcqi_%E6%BC%94%E7%BF%92_2_18/",
                "title": "QCQI/演習 2.18",
                "section": "post",
                "date" : "2021.04.09",
                "body": "ユニタリー行列 \\(U\\) の固有値を \\(v\\), 固有ベクトルを \\(|v\\rangle\\) とすると、ユニタリー演算子は内積を保存することから、\n\\begin{eqnarray*} \\langle v|v \\rangle \u0026amp;=\u0026amp; (U|v\\rangle, U|v\\rangle) \\\\\\\n\u0026amp;=\u0026amp; (v|v\\rangle, v|v\\rangle) \\newline \\end{eqnarray*}\nここで\n 内積は第 1 引数に関して共役線形 内積は第 2 引数に関して線形  を使うと、\n\\begin{eqnarray*} \\phantom{\\langle v|v \\rangle} \u0026amp;=\u0026amp; vv^{\\ast}(|v\\rangle, |v\\rangle) \\\\\\\n\u0026amp;=\u0026amp; vv^{\\ast}\\langle v|v \\rangle \\end{eqnarray*}\nよって \\(vv^{\\ast} = 1\\) であるから、\\(|v| = \\sqrt{vv^{\\ast}} = 1\\). つまり、ユニタリー行列のすべての固有値は絶対値が 1 であり、したがって固有値はある実数 \\(\\theta\\) を用いて \\(e^{i\\theta}\\) の形で書けることが示せた。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409120432-qcqi_%E6%BC%94%E7%BF%92_2_19/",
                "title": "QCQI/演習 2.19",
                "section": "post",
                "date" : "2021.04.09",
                "body": "パウリ行列それぞれについて、\\(A^{\\dagger} = A\\) (エルミート行列) と \\(A^{\\dagger}A = I\\) (ユニタリー) を示す。\nI \\begin{equation*} I^{\\dagger} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} = I \\end{equation*}\n\\begin{equation*} I^{\\dagger}I = II = I \\end{equation*}\nX \\begin{equation*} X^{\\dagger} = \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} = X \\end{equation*}\n\\begin{equation*} X^{\\dagger}X = XX = \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} = I \\end{equation*}\nY \\begin{equation*} Y^{\\dagger} = \\begin{bmatrix} 0 \u0026amp; i \\newline -i \u0026amp; 0 \\end{bmatrix}^T = \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} = Y \\end{equation*}\n\\begin{equation*} Y^{\\dagger}Y = YY = \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} = I \\end{equation*}\nZ \\begin{equation*} Z^{\\dagger} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} = Z \\end{equation*}\n\\begin{equation*} Z^{\\dagger}Z = ZZ = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} = I \\end{equation*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409140256-qcqi_%E6%BC%94%E7%BF%92_2_20/",
                "title": "QCQI/演習 2.20",
                "section": "post",
                "date" : "2021.04.09",
                "body": "\\(A^{\\prime}_{ij} = \\langle v_i|A|v_j\\rangle\\) について、\\(|w_i\\rangle\\) に対する完全性関係を使うと、\n\\[\\begin{align} A^{\\prime}_{ij} = \\langle v_i|A|v_j\\rangle = \\sum_{k,l} \\langle v_i|w_k\\rangle\\langle w_k|A|w_l\\rangle\\langle w_l|v_j\\rangle \\end{align}\\]\nここで、\\(U = \\sum_i |w_i\\rangle\\langle v_i|\\) とおくと、\\(|w_i\\rangle = U|v_i\\rangle\\) から、\n\\[\\begin{align} \\phantom{A^{\\prime}_{ij} = \\langle v_i|A|v_j\\rangle} \u0026amp;= \\sum_{k,l} \\langle v_i|U|v_k\\rangle\\langle w_k|A|w_l\\rangle\\langle v_l|U^{\\dagger}|v_j\\rangle \\newline \\end{align}\\]\nよって、基底 \\(|v_i\\rangle\\) に関する \\(U\\) の行列表現を \\(U^{\\prime}\\), \\(U^{\\dagger}\\) の行列表現を \\(U^{\\dagger\\prime}\\) とすると、\n\\[A_{ij}^{\\prime} = \\sum_{k,l} U_{i,k}^{\\prime} A_{kl}^{\\prime\\prime} U_{lj}^{\\dagger\\prime}\\]\nしたがって、\n\\[A^{\\prime} = U^{\\prime}A^{\\prime\\prime}U^{\\dagger\\prime}\\]\nという関係が得られる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409164921-qcqi_%E6%BC%94%E7%BF%92_2_23/",
                "title": "QCQI/演習 2.23",
                "section": "post",
                "date" : "2021.04.09",
                "body": "\\(P\\) の固有値を \\(v\\), \\(v\\) に対する固有ベクトルを \\(|v\\rangle\\) とすると、\n\\[P^2|v\\rangle = PP|v\\rangle = P(v|v\\rangle) = vP|v\\rangle = v^2|v\\rangle\\]\n一方で \\(P^2 = P\\) (QCQI/演習 2.16) なので\n\\[P^2|v\\rangle = P|v\\rangle = v|v\\rangle\\]\nよって \\(v^2 = v\\) となり、これを解くと \\(v = 0, 1\\) である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409163352-qcqi_%E6%BC%94%E7%BF%92_2_25/",
                "title": "QCQI/演習 2.25",
                "section": "post",
                "date" : "2021.04.09",
                "body": "転置共役の定義と \\((A^{\\dagger})^{\\dagger} = A\\) (QCQI/演習 2.15) より、\n\\[(|v\\rangle, A^{\\dagger}A|v\\rangle) = (|v\\rangle, A^{\\dagger}(A|v\\rangle)) = (A|v\\rangle, A|v\\rangle)\\]\nここで内積の正値性より、\n\\begin{align*} \u0026amp;(A|v\\rangle, A|v\\rangle) \\geq 0 \\\\\\\n\\Rightarrow\\ \u0026amp;(|v\\rangle, A^{\\dagger}A|v\\rangle) \\geq 0 \\end{align*}\nよって、\\(A^{\\dagger}A\\) は正の演算子。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409154813-%E3%82%B9%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB%E5%88%86%E8%A7%A3/",
                "title": "スペクトル分解",
                "section": "post",
                "date" : "2021.04.09",
                "body": "ベクトル空間 \\(V\\) 上の任意の正規演算子 \\(M\\) は \\(V\\) のある正規直交基底に関して対角である。逆に任意の対角化可能な演算子は正規である。\n外積表現では、この定理は \\(M\\) が\n\\[M = \\sum_i \\lambda_i |i\\rangle\\langle i|\\]\nと書けることを意味する。ここで \\(\\lambda_i\\) は \\(M\\) の固有値、各 \\(|i\\rangle\\) は固有値 \\(\\lambda_i\\) に対応する \\(M\\) の固有ベクトルであり、\\(V\\) の正規直交基底を形成する。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409100412-%E3%83%86%E3%83%B3%E3%82%BD%E3%83%AB%E7%A9%8D/",
                "title": "テンソル積",
                "section": "post",
                "date" : "2021.04.09",
                "body": "テンソル積はベクトル空間を組合わせて大きなベクトル空間を作るための方法。\n\\(V\\) と \\(W\\) はそれぞれ \\(m\\) 次元と \\(n\\) 次元のベクトル空間で、便宜上ヒルベルト空間とする。このとき、\n \\(V \\otimes W\\) は \\(mn\\) 次元のベクトル空間である \\(V \\otimes W\\) の要素は \\(V\\) の要素 \\(|v\\rangle\\) と \\(W\\) の要素 \\(|w\\rangle\\) のテンソル積 (\\(|v\\rangle \\otimes |w\\rangle\\)) の線形結合である \\(|i\\rangle\\) と \\(|j\\rangle\\) が空間 \\(V\\) と \\(W\\) の正規直交基底ならば、\\(|i\\rangle \\otimes |j\\rangle\\) は \\(V \\otimes W\\) に対する基底になる  この定義によってテンソル積はテンソル積の双線形性とテンソル積上の内積を満たす。\n関連ノート  テンソル積上の演算子  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409113657-%E5%86%85%E7%A9%8D%E3%81%AE%E5%AF%BE%E7%A7%B0%E6%80%A7/",
                "title": "内積の対称性",
                "section": "post",
                "date" : "2021.04.09",
                "body": "内積関数を記号 \\((\\cdot, \\cdot)\\) で表したとき、\n\\[(|v\\rangle, |w\\rangle) = (|w\\rangle, |v\\rangle)^{\\ast}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409114109-%E5%86%85%E7%A9%8D%E3%81%AE%E6%AD%A3%E5%80%A4%E6%80%A7/",
                "title": "内積の正値性",
                "section": "post",
                "date" : "2021.04.09",
                "body": "内積関数を記号 \\((\\cdot, \\cdot)\\) で表したとき、\n\\[(|v\\rangle, |v\\rangle) \\geq 0\\]\nが成り立つ。これを内積の正値性と呼ぶ。\n等号が成り立つのは \\(|v\\rangle = 0\\) のときのみであり、これを内積の正定値性と呼ぶ。\n参照  Quantum Computation and Quantum Information 量子情報科学入門  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409105459-%E5%86%85%E7%A9%8D%E3%81%AF%E7%AC%AC_1_%E5%BC%95%E6%95%B0%E3%81%AB%E9%96%A2%E3%81%97%E3%81%A6%E5%85%B1%E5%BD%B9%E7%B7%9A%E5%BD%A2/",
                "title": "内積は第 1 引数に関して共役線形",
                "section": "post",
                "date" : "2021.04.09",
                "body": "内積の関数を記号 \\((\\cdot, \\cdot)\\) で表したとき、\n\\begin{equation} \\left(\\sum_i \\lambda_i |w_i\\rangle, |v\\rangle\\right) = \\sum_i \\lambda_i^{\\ast} (|w_i\\rangle, |v\\rangle) \\end{equation}\nとなる。証明はQCQI/演習 2.6を参照。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409111356-%E5%86%85%E7%A9%8D%E3%81%AF%E7%AC%AC_2_%E5%BC%95%E6%95%B0%E3%81%AB%E9%96%A2%E3%81%97%E3%81%A6%E7%B7%9A%E5%BD%A2/",
                "title": "内積は第 2 引数に関して線形",
                "section": "post",
                "date" : "2021.04.09",
                "body": "内積関数を記号 \\((\\cdot, \\cdot)\\) で表したとき、\n\\[\\left(|v\\rangle, \\sum_i\\lambda_i|w_i\\rangle\\right) = \\sum_i\\lambda_i(|v\\rangle, |w_i\\rangle)\\]\nとなるのでこれは第 2 引数に関して線形。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409153514-%E6%AD%A3%E3%81%AE%E5%AE%9A%E7%AC%A6%E5%8F%B7/",
                "title": "正の定符号",
                "section": "post",
                "date" : "2021.04.09",
                "body": "ベクトル \\(|v\\rangle \\neq 0\\) に対して \\((|v\\rangle, A|v\\rangle)\\) が厳密に大きければ演算子 \\(A\\) を正の定符号と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409152203-%E6%AD%A3%E3%81%AE%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "正の演算子",
                "section": "post",
                "date" : "2021.04.09",
                "body": "任意のベクトル \\(|v\\rangle\\) に対して \\((|v\\rangle, A|v\\rangle)\\) が実数で負でない数となる演算子 \\(A\\) を正の演算子と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408084752-qcqi_%E6%BC%94%E7%BF%92_2_12/",
                "title": "QCQI/演習 2.12",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\begin{equation} A = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 1 \u0026amp; 1 \\end{bmatrix} \\end{equation}\nとする。\n\\begin{eqnarray} \\mathrm{det}|A - \\lambda I| = \\begin{bmatrix} 1 - \\lambda \u0026amp; 0 \\newline 1 \u0026amp; 1 - \\lambda \\end{bmatrix} = (1 - \\lambda)^2 = 0 \\newline \\therefore \\lambda = 1 \\end{eqnarray}\n固有値 \\(\\lambda = 1\\) に対する固有ベクトル \\(|\\lambda_1\\rangle\\) を求めると、\n\\begin{eqnarray} \\begin{bmatrix} 0 \u0026amp; 0 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} a \\newline b \\end{bmatrix} = \\begin{bmatrix} 0 \\newline 0 \\end{bmatrix} \\end{eqnarray}\nよって\n\\begin{equation} |\\lambda_1\\rangle = \\begin{bmatrix} 0 \\newline 1 \\end{bmatrix} \\end{equation}\n\\(A\\) は 1 つの固有ベクトルしか持たないので対角化できない。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408092119-qcqi_%E6%BC%94%E7%BF%92_2_13/",
                "title": "QCQI/演習 2.13",
                "section": "post",
                "date" : "2021.04.08",
                "body": "任意のベクトル \\(|l\\rangle, |m\\rangle\\) に関して、\n\\begin{eqnarray} (|l\\rangle, (|w\\rangle\\langle v|)|m\\rangle) \u0026amp;=\u0026amp; (|l\\rangle, |w\\rangle \\langle v|m\\rangle) \\newline \u0026amp;=\u0026amp; \\langle v|m \\rangle(|l\\rangle, |w\\rangle) \\newline \u0026amp;=\u0026amp; \\langle v|m \\rangle \\langle l|w\\rangle \\end{eqnarray}\nまた、\n\\begin{eqnarray} ((|v\\rangle\\langle w|)|l\\rangle, |m\\rangle) \u0026amp;=\u0026amp; (|v\\rangle \\langle w|l\\rangle, |m\\rangle) \\newline \u0026amp;=\u0026amp; \\langle l|w \\rangle(|v\\rangle, |m\\rangle) \\newline \u0026amp;=\u0026amp; \\langle l|w \\rangle \\langle v|m\\rangle \\end{eqnarray}\nよって転置共役の定義より \\((|l\\rangle, (|w\\rangle\\langle v|)|m\\rangle) = ((|v\\rangle\\langle w|)|l\\rangle, |m\\rangle)\\) だから、\\((|w\\rangle\\langle v|)^{\\dagger} = |v\\rangle\\langle w|\\)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408102838-qcqi_%E6%BC%94%E7%BF%92_2_14/",
                "title": "QCQI/演習 2.14",
                "section": "post",
                "date" : "2021.04.08",
                "body": "任意のベクトル \\(|v\\rangle, |w\\rangle\\) に対して、\n\\begin{eqnarray} \\left(\\left(\\sum_i a_i A_i\\right)^{\\dagger}|v\\rangle, |w\\rangle\\right) \u0026amp;=\u0026amp; \\left(|v\\rangle, \\sum_i a_i A_i|w\\rangle\\right) \\newline \u0026amp;=\u0026amp; \\sum_i a_i (|v\\rangle, A_i|w\\rangle) \\newline \u0026amp;=\u0026amp; \\sum_i a_i (A_i^{\\dagger}|v\\rangle, |w\\rangle) \\newline \u0026amp;=\u0026amp; \\left(\\sum_i a_i^{\\ast} A_i^{\\dagger}|v\\rangle, |w\\rangle \\right) \\end{eqnarray}\n(転置共役の定義、内積の第二引数に関する線形性、第一引数に関する共役線形性 (QCQI/演習 2.6) を使った)\nよって\n\\begin{equation} \\left(\\sum_i a_i A_i\\right)^{\\dagger} = \\sum_i a_i^{\\ast} A_i^{\\dagger} \\end{equation}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408104428-qcqi_%E6%BC%94%E7%BF%92_2_15/",
                "title": "QCQI/演習 2.15",
                "section": "post",
                "date" : "2021.04.08",
                "body": "任意のベクトル \\(|v\\rangle, |w\\rangle\\) に対して、内積の性質 \\((|v\\rangle, |w\\rangle) = (|w\\rangle, |v\\rangle)^{\\ast}\\) と転置共役の定義を使うと、\n\\begin{eqnarray} (|v\\rangle, A^{\\dagger}|w\\rangle) \u0026amp;=\u0026amp; (A^{\\dagger}|w\\rangle, |v\\rangle)^{\\ast} \\newline \u0026amp;=\u0026amp; (|w\\rangle, A|v\\rangle)^{\\ast} \\newline \u0026amp;=\u0026amp; (A|v\\rangle, |w\\rangle) \\end{eqnarray}\nこれより、\n\\begin{eqnarray} (|v\\rangle, (A^{\\dagger})^{\\dagger}|w\\rangle) \u0026amp;=\u0026amp; (A^{\\dagger}|v\\rangle, |w\\rangle) \\newline \u0026amp;=\u0026amp; (|v\\rangle, A|w\\rangle) \\end{eqnarray}\nよって \\((A^{\\dagger})^{\\dagger} = A\\)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408141931-qcqi_%E6%BC%94%E7%BF%92_2_16/",
                "title": "QCQI/演習 2.16",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\begin{eqnarray} P^2 \u0026amp;=\u0026amp; \\sum_i |i \\rangle\\langle i| \\sum_j |j \\rangle\\langle j| \\newline \u0026amp;=\u0026amp; \\sum_{i,j} |i \\rangle\\langle i|j \\rangle\\langle j| \\newline \u0026amp;=\u0026amp; \\sum_{i,j} |i \\rangle\\delta_{i,j}\\langle j| \\newline \u0026amp;=\u0026amp; \\sum_i |i \\rangle\\langle i| \\newline \u0026amp;=\u0026amp; P \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408151328-qcqi_%E6%BC%94%E7%BF%92_2_17/",
                "title": "QCQI/演習 2.17",
                "section": "post",
                "date" : "2021.04.08",
                "body": "まず「\\(A\\) がエルミート行列 \\(\\Rightarrow\\) \\(A\\) の固有値は実数」を示す。\\(A\\) の固有ベクトルを任意にとり、その固有値が \\(\\lambda\\) であるとすると、\n\\begin{eqnarray} \\lambda \\langle v|v \\rangle \u0026amp;=\u0026amp; (|v\\rangle, \\lambda |v\\rangle) \\newline \u0026amp;=\u0026amp; (|v\\rangle, A|v\\rangle) \\newline \u0026amp;=\u0026amp; (A^{\\dagger}|v\\rangle, |v\\rangle) \\newline \u0026amp;=\u0026amp; (A|v\\rangle, |v\\rangle) \\newline \u0026amp;=\u0026amp; (\\lambda|v\\rangle, |v\\rangle) \\newline \u0026amp;=\u0026amp; \\lambda^{\\ast}(|v\\rangle, |v\\rangle) \\newline \u0026amp;=\u0026amp; \\lambda^{\\ast}\\langle v|v \\rangle \\end{eqnarray}\n\\(\\lambda = \\lambda^{\\ast}\\) だから、\\(\\lambda\\) は実数。\nつぎに、「正規行列 \\(A\\) の固有値がすべて実数 \\(\\Rightarrow\\) \\(A\\) はエルミート行列」を示す。スペクトル分解の定理によると、演算子は対角化可能であるときにのみ正規である。よって \\(A\\) は対角化可能だから、\n\\begin{equation} A = \\sum_i \\lambda_i |i \\rangle\\langle i| \\end{equation}\nさらに、転置共役の反線形性とQCQI/演習 2.13の結果を使って、\n\\begin{eqnarray} A^{\\dagger} \u0026amp;=\u0026amp; \\left(\\sum_i \\lambda_i |i\\rangle\\langle i|)\\right)^{\\dagger} \\newline \u0026amp;=\u0026amp; \\sum_i \\lambda_i^{\\ast}(|i\\rangle\\langle i|)^{\\dagger} \\newline \u0026amp;=\u0026amp; \\sum_i \\lambda_i^{\\ast}|i\\rangle\\langle i| \\end{eqnarray}\n仮定の「正規行列 \\(A\\) の固有値がすべて実数」より \\(\\lambda_i = \\lambda_i^{\\ast}\\), よって \\(A = A^{\\dagger}\\) であり、\\(A\\) はエルミート行列である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408114113-%E3%82%A8%E3%83%AB%E3%83%9F%E3%83%BC%E3%83%88%E5%85%B1%E5%BD%B9%E6%BC%94%E7%AE%97%E3%81%AE%E8%A1%8C%E5%88%97%E8%A1%A8%E7%8F%BE/",
                "title": "エルミート共役演算の行列表現",
                "section": "post",
                "date" : "2021.04.08",
                "body": "エルミート共役演算子の行列表現では、エルミート共役演算は行列 \\(A\\) を共役・転置すること、すなわち \\(A^{\\dagger} \\equiv (A^{\\ast})^T\\) である。\nたとえば、\n\\begin{eqnarray} \\begin{bmatrix} 1+3i \u0026amp; 2i \\newline 1_i \u0026amp; 1-4i \\end{bmatrix}^{\\dagger} = \\begin{bmatrix} 1-3i \u0026amp; 1-i \\newline -2i \u0026amp; 1+4i \\end{bmatrix} \\end{eqnarray}\nである。\n参考  正規行列の対角化可能性  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408114955-%E3%82%A8%E3%83%AB%E3%83%9F%E3%83%BC%E3%83%88%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "エルミート演算子",
                "section": "post",
                "date" : "2021.04.08",
                "body": "演算子 \\(A\\) の転置共役が元の演算子 \\(A\\) に等しいとき、つまり\n\\[A^{\\dagger} = A\\]\nなとき、その演算子をエルミート演算子または自己共役 (自己随伴) 演算子であるという。\nエルミート演算子は正規なのでスペクトル分解できる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406110144-%E3%82%B3%E3%83%BC%E3%82%B7%E3%83%BC_%E3%82%B7%E3%83%A5%E3%83%AF%E3%83%AB%E3%83%84%E3%81%AE%E4%B8%8D%E7%AD%89%E5%BC%8F/",
                "title": "コーシー・シュワルツの不等式",
                "section": "post",
                "date" : "2021.04.08",
                "body": "ヒルベルト空間の任意の 2 つのベクトル \\(|v\\rangle\\), \\(|w\\rangle\\) に対して \\(|\\langle v|w\\rangle|^2 \\leq \\langle v|v \\rangle \\langle w|w \\rangle\\).\n証明するにはグラム・シュミット直交化でベクトル空間の正規直交基底 \\(|i\\rangle\\) を作り、最初の基底 \\(|i\\rangle\\) を \\(|w\\rangle / \\sqrt{\\langle w|w \\rangle}\\) とする。完全性関係 \\(\\sum_i |i\\rangle\\langle i| = I\\) を用い、\n\\begin{eqnarray} \\langle v|v \\rangle \\langle w|w \\rangle \u0026amp;=\u0026amp; \\sum_i \\langle v|i \\rangle \\langle i | v \\rangle \\langle w|w \\rangle \\end{eqnarray}\nここで、最初の基底 \\(|i\\rangle = |w\\rangle/\\sqrt{\\langle w | w \\rangle}\\ (\\langle i| = \\langle w|/\\sqrt{\\langle w | w \\rangle})\\) の項だけを残すと、\n\\begin{eqnarray} \\sum_i \\langle v|i \\rangle \\langle i | v \\rangle \\langle w|w \\rangle \u0026amp;\\geq\u0026amp; \\frac{\\langle v|w \\rangle \\langle w | v \\rangle}{\\langle w | w \\rangle}\\langle w | w \\rangle \\newline \u0026amp;=\u0026amp; \\langle v | w\\rangle \\langle w | v\\rangle = |\\langle v | w \\rangle |^2 \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408120225-%E3%83%8F%E3%82%A6%E3%83%AA%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%A4%96%E7%A9%8D%E8%A1%A8%E7%8F%BE/",
                "title": "パウリ演算子の外積表現",
                "section": "post",
                "date" : "2021.04.08",
                "body": "次の式を覚えておけば、パウリ行列やベクトルの要素をわざわざすべて書き下さなくても、ディラック記法だけで形式的にいろいろ計算できるので便利。\n\\begin{align*} I \u0026amp;= \\ket{0}\\bra{0} + \\ket{1}\\bra{1} \u0026amp; X \u0026amp;= \\ket{0}\\bra{1} + \\ket{1}\\bra{0} \\\\\\\nY \u0026amp;= -i\\ket{0}\\bra{1} + i\\ket{1}\\bra{0} \u0026amp; Z \u0026amp;= \\ket{0}\\bra{0} - \\ket{1}\\bra{1} \\end{align*}\n(なぜこうなるかの計算は QCQI/演習 2.9 を参照)\nこれを使うとたとえば \\(Y\\ket{0}\\) は、\n\\begin{eqnarray*} Y\\ket{0} \u0026amp;=\u0026amp; (-i\\ket{0}\\bra{1} + i\\ket{1}\\bra{0})\\ket{0} \\\\\\\n\u0026amp;=\u0026amp; \\cancel{-i\\ket{0}\\underbrace{\\braket{1|0}}_{= 0}} + i\\ket{1}\\underbrace{\\braket{0|0}}_{= 1} \\\\\\\n\u0026amp;=\u0026amp; i\\ket{1} \\end{eqnarray*}\nと簡単に計算できる。\n関連ノート  演算子の外積表現  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408120013-%E3%83%8F%E3%82%A6%E3%83%AA%E8%A1%8C%E5%88%97%E3%81%AE%E5%9B%BA%E6%9C%89%E5%88%86%E8%A7%A3/",
                "title": "パウリ行列の固有分解",
                "section": "post",
                "date" : "2021.04.08",
                "body": "QCQI/演習 2.11を参照\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408160607-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%BC/",
                "title": "ユニタリー",
                "section": "post",
                "date" : "2021.04.08",
                "body": " ユニタリー演算子  ユニタリー演算子は内積を保存する ユニタリー演算子の外積表現   ユニタリー行列  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408161727-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%BC%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%A4%96%E7%A9%8D%E8%A1%A8%E7%8F%BE/",
                "title": "ユニタリー演算子の外積表現",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\(|v_i\\rangle\\) は任意の正規直交基底の集合であるとする。\\(|w_i\\rangle \\equiv U|v_i\\rangle\\) を定義すると、ユニタリー演算子は内積を保存するので \\(|w_i\\rangle\\) も正規直交基底の集合である。したがって \\(U = \\sum_i |w_i\\rangle\\langle v_i|\\) が成り立つ。逆にもし \\(|v\\rangle\\) と \\(|w\\rangle\\) が任意の 2 つの直交基底ならば、\\(U \\equiv \\sum_i |w_i\\rangle\\langle v_i|\\) で定義される演算子 \\(U\\) はユニタリー演算子であることが容易に確認できる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408161455-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%BC%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AF%E5%86%85%E7%A9%8D%E3%82%92%E4%BF%9D%E5%AD%98%E3%81%99%E3%82%8B/",
                "title": "ユニタリー演算子は内積を保存する",
                "section": "post",
                "date" : "2021.04.08",
                "body": "幾何学的にユニタリー演算子はベクトル間の内積を保存する。これを見るために \\(|v\\rangle\\) と \\(|w\\rangle\\) を任意の 2 つのベクトルとすると、\\(U|v\\rangle\\) と \\(U|w\\rangle\\) の内積は \\(|v\\rangle\\) と \\(|w\\rangle\\) の内積に等しい。\n\\begin{equation} (U|v\\rangle, U|w\\rangle) = \\langle v|U^{\\dagger}U|w\\rangle = \\langle v|I|w\\rangle = \\langle v|w\\rangle \\end{equation}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408120345-%E5%8D%98%E4%BD%8D%E5%85%83%E3%81%AE%E8%A1%8C%E5%88%97%E8%A1%A8%E7%8F%BE/",
                "title": "単位元の行列表現",
                "section": "post",
                "date" : "2021.04.08",
                "body": "QCQI/演習 2.4を参照\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408121035-%E5%B0%84%E5%BD%B1%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "射影演算子",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\(W\\) が \\(d\\) 次元ベクトル空間 \\(V\\) 上の \\(k\\) 次元ベクトル部分空間であるとする。グラム・シュミット直交化を用いると、\\(|1\\rangle, \\ldots, |k\\rangle\\) が \\(W\\) の正規直交基底となるように \\(V\\) に対する正規直交基底 \\(|1\\rangle, \\ldots, |d\\rangle\\) を作ることができる。定義により\n\\begin{equation*} P \\equiv \\sum_{i=1}^k |i\\rangle\\langle i| \\end{equation*}\nは部分空間 \\(W\\) への射影演算子である。\nQCQI/演習 2.13により任意のベクトル \\(|v\\rangle\\) に対して \\((|v\\rangle\\langle v|)^{\\dagger} = |v\\rangle\\langle v|\\) なので、\\(|v\\rangle\\langle v|\\) はエルミート演算子である。したがって \\(P\\) もエルミート演算子、すなわち \\(P^{\\dagger} = P\\) である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408142915-%E6%AD%A3%E8%A6%8F/",
                "title": "正規",
                "section": "post",
                "date" : "2021.04.08",
                "body": "演算子 \\(A\\) が \\(AA^{\\dagger} = A^{\\dagger}A\\) を満たすとき、これを正規であるという。エルミート演算子は正規である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408163416-%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E5%9F%BA%E5%BA%95/",
                "title": "正規直交基底",
                "section": "post",
                "date" : "2021.04.08",
                "body": "正規直交な基底のこと。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408140459-%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E7%9B%B8%E8%A3%9C%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "正規直交相補演算子",
                "section": "post",
                "date" : "2021.04.08",
                "body": "射影演算子 \\(P\\) について \\(Q = I - P\\) を正規直交相補演算子と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408141226-%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E7%9B%B8%E8%A3%9C%E7%A9%BA%E9%96%93/",
                "title": "正規直交相補空間",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\(W\\) が \\(d\\) 次元ベクトル空間 \\(V\\) 上の \\(k\\) 次元ベクトル部分空間であるとする。グラム・シュミット直交化を用いると、\\(|1\\rangle, \\ldots, |k\\rangle\\) が \\(W\\) の正規直交基底となるように \\(V\\) に対する正規直交基底 \\(|1\\rangle, \\ldots, |d\\rangle\\) を作ることができる。\nここで正規直交相補演算子 Q は \\(|k+1\\rangle, \\ldots, |d\\rangle\\) で張られたベクトル空間への射影演算子であり、その空間を \\(P\\) の正規直交相補空間と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408120450-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E7%A9%8D%E3%81%AE%E8%A1%8C%E5%88%97%E8%A1%A8%E7%8F%BE/",
                "title": "演算子の積の行列表現",
                "section": "post",
                "date" : "2021.04.08",
                "body": "QCQI/演習 2.3を参照\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408091257-%E8%BB%A2%E7%BD%AE%E5%85%B1%E5%BD%B9/",
                "title": "転置共役",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\(A\\) はヒルベルト空間 \\(V\\) の任意の演算子であるとすると、すべてのベクトル \\(|v\\rangle, |w\\rangle \\in V\\) に対して、\n\\begin{equation} (|v\\rangle, A|w\\rangle) = (A^{\\dagger}|v\\rangle, |w\\rangle) \\end{equation}\nを満たす演算子 \\(A^{\\dagger}\\) が \\(V\\) 上に唯 1 つのみ存在する。この演算子を演算子 \\(A\\) の転置共役またはエルミート共役という。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408115741-%E8%BB%A2%E7%BD%AE%E5%85%B1%E5%BD%B9%E3%81%AE%E5%8F%8D%E7%B7%9A%E5%BD%A2%E6%80%A7/",
                "title": "転置共役の反線形性",
                "section": "post",
                "date" : "2021.04.08",
                "body": "転置共役演算は次の性質を満たすため、反線形 (anti-linear) である。\n\\begin{equation} \\left(\\sum_i a_i A_i\\right)^{\\dagger} = \\sum_i a_i^{\\ast} A_i^{\\dagger} \\end{equation}\n証明は QCQI/演習 2.14 を参照。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406103502-qcqi_%E6%BC%94%E7%BF%92_2_10/",
                "title": "QCQI/演習 2.10",
                "section": "post",
                "date" : "2021.04.06",
                "body": "演算子の外積表現より、演算子 \\(|v_j\\rangle\\langle v_k|\\) の行列表現 \\(A\\) の行列要素は \\(A_{lm} = \\langle w_l|v_j\\rangle\\langle v_k|v_m\\rangle = \\delta_{lj}\\delta_{km}\\)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406155031-qcqi_%E6%BC%94%E7%BF%92_2_11/",
                "title": "QCQI/演習 2.11",
                "section": "post",
                "date" : "2021.04.06",
                "body": "\\(X\\) の固有分解 \\(X\\) の固有値を求めると、\n\\begin{eqnarray} \\mathrm{det}|X - \\lambda I| = \\begin{vmatrix} -\\lambda \u0026amp; 1 \\newline 1 \u0026amp; -\\lambda \\end{vmatrix} = \\lambda^2 - 1 = 0\\ \\therefore \\lambda = \\pm1 \\end{eqnarray}\nよって \\(\\lambda = 1\\) と \\(\\lambda = -1\\) のとき、\\(X\\) の固有ベクトルのうち正規化したものはそれぞれ、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline 1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle),\\newline |\\lambda_{-1}\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline -1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle) \\end{eqnarray}\nよって \\(X\\) の対角表現は、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\lambda_1|\\lambda_1\\rangle\\langle\\lambda_1| + \\lambda_{-1}|\\lambda_{-1}\\rangle\\langle\\lambda_{-1}|\\newline \u0026amp;=\u0026amp; \\frac{1}{2}(|0\\rangle + |1\\rangle)(\\langle 0| + \\langle 1|) - \\frac{1}{2}(|0\\rangle - |1\\rangle)(\\langle 0| - \\langle 1|) \\end{eqnarray}\n\\(Y\\) の固有分解 \\(Y\\) の固有値を求めると、\n\\begin{eqnarray} \\mathrm{det}|Y - \\lambda I| = \\begin{vmatrix} -\\lambda \u0026amp; -i \\newline i \u0026amp; -\\lambda \\end{vmatrix} = \\lambda^2 - 1 = 0\\ \\therefore \\lambda = \\pm1 \\end{eqnarray}\nよって \\(\\lambda = 1\\) と \\(\\lambda = -1\\) のとき、\\(Y\\) の固有ベクトルのうち正規化したものはそれぞれ、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline i \\end{bmatrix} = \\frac{1}{\\sqrt{2}}(|0\\rangle + i|1\\rangle),\\newline |\\lambda_{-1}\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline -i \\end{bmatrix} = \\frac{1}{\\sqrt{2}}(|0\\rangle - i|1\\rangle) \\end{eqnarray}\nよって \\(Y\\) の対角表現は、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\lambda_1|\\lambda_1\\rangle\\langle\\lambda_1| + \\lambda_{-1}|\\lambda_{-1}\\rangle\\langle\\lambda_{-1}|\\newline \u0026amp;=\u0026amp; \\frac{1}{2}(|0\\rangle + i|1\\rangle)(\\langle 0| + i\\langle 1|) - \\frac{1}{2}(|0\\rangle - i|1\\rangle)(\\langle 0| - i\\langle 1|) \\end{eqnarray}\n\\(Z\\) の固有分解 \\(Z\\) の固有値を求めると、\n\\begin{eqnarray} \\mathrm{det}|Z - \\lambda I| = \\begin{vmatrix} 1 - \\lambda \u0026amp; 0 \\newline 0 \u0026amp; -1 - \\lambda \\end{vmatrix} = - (1 - \\lambda^2) = 0\\ \\therefore \\lambda = \\pm1 \\end{eqnarray}\nよって \\(\\lambda = 1\\) と \\(\\lambda = -1\\) のとき、\\(Z\\) の固有ベクトルのうち正規化したものはそれぞれ、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\begin{bmatrix} 1 \\newline 0 \\end{bmatrix} = |0\\rangle,\\newline |\\lambda_{-1}\\rangle \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \\newline 1 \\end{bmatrix} = |1\\rangle \\end{eqnarray}\nよって \\(Z\\) の対角表現は、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\lambda_1|\\lambda_1\\rangle\\langle\\lambda_1| + \\lambda_{-1}|\\lambda_{-1}\\rangle\\langle\\lambda_{-1}|\\newline \u0026amp;=\u0026amp; |0\\rangle\\langle 0| - |1\\rangle\\langle 1| \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406095636-qcqi_%E6%BC%94%E7%BF%92_2_9/",
                "title": "QCQI/演習 2.9",
                "section": "post",
                "date" : "2021.04.06",
                "body": "演算子の外積表現を使う。\n\\(I\\) の外積表現 \\begin{eqnarray*} I \u0026amp;=\u0026amp; \\sum_{i,j=0}^1 \\braket{j|I|i}\\ket{j}\\bra{i} \\\\\\\n\u0026amp;=\u0026amp; \\sum_{i,j=0}^1 \\braket{j|i}\\ket{j}\\bra{i} \\\\\\\n\u0026amp;=\u0026amp; \\sum_{i,j=0}^1 \\delta_{ij}\\ket{j}\\bra{i} \\\\\\\n\u0026amp;=\u0026amp; \\ket{0}\\bra{0} + \\ket{1}\\bra{1} \\end{eqnarray*}\n\\(X\\) の外積表現 \\begin{eqnarray*} X \u0026amp;=\u0026amp; \\sum_{i,j=0}^1 \\braket{j|X|i}\\ket{j}\\bra{i} \\\\\\\n\u0026amp;=\u0026amp; \\cancel{0\\cdot\\ket{0}\\bra{0}} + 1\\cdot\\ket{0}\\bra{1} + 1\\cdot\\ket{1}\\bra{0} + \\cancel{0\\cdot\\ket{1}\\bra{1}} \\\\\\\n\u0026amp;=\u0026amp; \\ket{0}\\bra{1} + \\ket{1}\\bra{0} \\end{eqnarray*}\n\\(Y\\) の外積表現 \\begin{eqnarray*} Y \u0026amp;=\u0026amp; \\sum_{i,j=0}^1 \\braket{j|Y|i}\\ket{j}\\bra{i} \\\\\\\n\u0026amp;=\u0026amp; \\cancel{0\\cdot\\ket{0}\\bra{0}} + (-i)\\cdot\\ket{0}\\bra{1} + i\\cdot\\ket{1}\\bra{0} + \\cancel{0\\cdot\\ket{1}\\bra{1}} \\\\\\\n\u0026amp;=\u0026amp; -i\\ket{0}\\bra{1} + i\\ket{1}\\bra{0} \\end{eqnarray*}\n\\(Z\\) の外積表現 \\begin{eqnarray*} Z \u0026amp;=\u0026amp; \\sum_{i,j=0}^1 \\braket{j|Z|i}\\ket{j}\\bra{i} \\\\\\\n\u0026amp;=\u0026amp; 1\\cdot\\ket{0}\\bra{0} + \\cancel{0\\cdot\\ket{0}\\bra{1}} + \\cancel{0\\cdot\\ket{1}\\bra{0}} + (-1)\\cdot\\ket{1}\\bra{1} \\\\\\\n\u0026amp;=\u0026amp; \\ket{0}\\bra{0} - \\ket{1}\\bra{1} \\end{eqnarray*}\n関連ノート  パウリ行列  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406144840-%E5%9B%BA%E6%9C%89%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/",
                "title": "固有ベクトル",
                "section": "post",
                "date" : "2021.04.06",
                "body": "ベクトル空間における演算子 \\(A\\) の固有ベクトルとは、\\(A|v\\rangle = v|v\\rangle\\) を満たす \\(0\\) でないベクトル \\(|v\\rangle\\) のこと。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406145445-%E5%9B%BA%E6%9C%89%E5%80%A4/",
                "title": "固有値",
                "section": "post",
                "date" : "2021.04.06",
                "body": "ベクトル空間における演算子 \\(A\\) について、\\(A|v\\rangle = v|v\\rangle\\) を満たす固有ベクトル \\(|v\\rangle\\) に対応する複素数 \\(v\\) を \\(A\\) の固有値と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406155458-%E5%9B%BA%E6%9C%89%E6%96%B9%E7%A8%8B%E5%BC%8F/",
                "title": "固有方程式",
                "section": "post",
                "date" : "2021.04.06",
                "body": "特性方程式の別名\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406151942-%E5%9B%BA%E6%9C%89%E7%A9%BA%E9%96%93/",
                "title": "固有空間",
                "section": "post",
                "date" : "2021.04.06",
                "body": "固有値 \\(v\\) に対応する固有空間とは固有値 \\(v\\) を持つベクトルの集合であり、\\(A\\) が作用するベクトル空間のベクトル部分空間になる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406083525-%E5%A4%96%E7%A9%8D%E8%A1%A8%E7%8F%BE/",
                "title": "外積表現",
                "section": "post",
                "date" : "2021.04.06",
                "body": "外積表現とは、内積を使って演算子を表現する便利な方法。 \\(|v\\rangle\\) を内積空間 \\(V\\) のベクトル、\\(|w\\rangle\\) を内積空間 \\(W\\) のベクトルとしたとき、\\(|w \\rangle\\langle v|\\) は次式で定義される \\(V\\) から \\(W\\) への演算子である。\n\\begin{equation} (|w\\rangle\\langle v|)(|v^{\\prime}) \\equiv |w\\rangle\\langle v|v^{\\prime}\\rangle = \\langle v | v^{\\prime} \\rangle | w \\rangle \\end{equation}\nここで \\(|w\\rangle\\langle v|v^{\\prime}\\rangle\\) は次の 2 つの意味を持つ:\n 演算子 \\(|w\\rangle\\langle v|\\) が \\(|v^{\\prime}\\rangle\\) に働いたときの結果 \\(|w\\rangle\\) に複素数 \\(\\langle v | v^{\\prime} \\rangle\\) を掛けた結果  ここで 2 の内積の計算で 1 の演算子の計算ができることに注意。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406090438-%E5%AE%8C%E5%85%A8%E6%80%A7%E9%96%A2%E4%BF%82/",
                "title": "完全性関係",
                "section": "post",
                "date" : "2021.04.06",
                "body": "\\(\\ket{i}\\) をベクトル空間 \\(V\\) における任意の正規直交基底とすると、\n\\[\\sum_i \\ket{i}\\bra{i} = I\\]\nが成り立つ。この式を完全性関係と呼ぶ。\n導出 外積表現を使う。任意のベクトル \\(|v\\rangle\\) はある複素数の集合 \\(v_i\\) と正規直交基底 \\(|i\\rangle\\) を用いて \\(|v\\rangle = \\sum_i v_i|i\\rangle\\) と書ける。\\(\\langle i|v\\rangle = v_i\\) であるから、\n\\[\\left(\\sum_i |i\\rangle \\langle i|\\right)|v\\rangle = \\sum_i |i\\rangle \\langle i|v\\rangle = \\sum_i v_i|i\\rangle = |v\\rangle\\]\nつまり \\(\\left(\\sum_i |i\\rangle \\langle i|\\right)|v\\rangle = |v\\rangle\\) であり、これが任意のベクトル \\(|v\\rangle\\) について成り立つということは \\(\\sum_i |i\\rangle \\langle i|\\) は恒等演算子であるから、\n\\[\\sum_i |i\\rangle \\langle i| = I\\]\nが成り立つ。\n関連ノート  演算子の外積表現  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406154403-%E5%AF%BE%E8%A7%92%E5%8C%96%E5%8F%AF%E8%83%BD/",
                "title": "対角化可能",
                "section": "post",
                "date" : "2021.04.06",
                "body": "演算子の対角表現ができるとき、その演算子は対角化可能であるという\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406152433-%E5%AF%BE%E8%A7%92%E8%A1%A8%E7%8F%BE/",
                "title": "対角表現",
                "section": "post",
                "date" : "2021.04.06",
                "body": "ベクトル空間 \\(V\\) 上の演算子に対する対角表現は表現 \\(A = \\sum_i \\lambda |i\\rangle\\langle i|\\) である。ここでベクトル \\(|i\\rangle\\) は \\(A\\) の固有値 \\(\\lambda_i\\) に対する固有ベクトルであり、この固有ベクトルは正規直交集合を形成する。\n対角表現の例としてパウリ行列の \\(Z\\) 行列は次のように書ける。\n\\begin{equation} Z = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} = |0\\rangle\\langle 0| - |1\\rangle\\langle 1| \\end{equation}\nここで行列表現は正規直交ベクトル \\(|0\\rangle, |1\\rangle\\) に基いている。\n関連ノート  QCQI/演習 2.9 演算子の外積表現  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406153608-%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E5%88%86%E8%A7%A3/",
                "title": "正規直交分解",
                "section": "post",
                "date" : "2021.04.06",
                "body": "対角表現の別名\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406093454-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%A4%96%E7%A9%8D%E8%A1%A8%E7%8F%BE/",
                "title": "演算子の外積表現",
                "section": "post",
                "date" : "2021.04.06",
                "body": "\\(A: V \\rightarrow W\\) を演算子、\\(\\ket{v_i}\\) を \\(V\\) に対する正規直交基底、\\(\\ket{w_i}\\) を \\(W\\) に対する正規直交基底とする。このとき、\n\\begin{equation*} A = I_W A I_{V} \\phantom{\\sum_{ij} |w_j\\rangle \\langle w_j|A|v_i\\rangle\\langle v_i|} \\end{equation*}\nと書ける。\\(I_W\\), \\(I_V\\) を完全性関係を使ってそれぞれ書き直すと、\n\\begin{equation*} \\phantom{A} = \\sum_{ij} \\ket{w_j}\\braket{w_j|A|v_i}\\bra{v_i} \\phantom{I_W A I_{V}} \\end{equation*}\n\\(\\braket{w_j|A|v_i}\\) は定数だから、\n\\begin{equation*} \\phantom{A} = \\sum_{ij} \\braket{w_j|A|v_i}\\ket{w_j}\\bra{v_i} \\phantom{I_W A I_{V}} \\end{equation*}\nこれを演算子 \\(A\\) の外積表現と呼ぶ。\nまたこの式から、入力基底 \\(\\ket{v_i}\\), 出力基底 \\(\\ket{w_i}\\) に対して行列 \\(A\\) の \\(i\\) 行 \\(j\\) 列の行列要素は \\(\\braket{w_j|A|v_i}\\) であることがわかる。\n関連ノート  パウリ演算子の外積表現  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406151137-%E7%89%B9%E6%80%A7%E6%96%B9%E7%A8%8B%E5%BC%8F/",
                "title": "特性方程式",
                "section": "post",
                "date" : "2021.04.06",
                "body": "特性関数 \\(c(\\lambda) \\equiv det|A - \\lambda I|\\) について、特性方程式 \\(c(\\lambda) = 0\\) の解は演算子 \\(A\\) の固有値である。代数の基礎定理によるとすべての多項式は少なくとも 1 つの複素数の解を持つので、すべての演算子は少なくとも 1 つの固有値とそれに対応する固有ベクトルを持つ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406150501-%E7%89%B9%E6%80%A7%E9%96%A2%E6%95%B0/",
                "title": "特性関数",
                "section": "post",
                "date" : "2021.04.06",
                "body": "ベクトル空間における演算子 \\(A\\) があったとき、特性関数を \\(c(\\lambda) \\equiv det|A - \\lambda I|\\) で定義する。特性関数は演算子 \\(A\\) のみに依存し、\\(A\\) を表す特定の行列表現には依存しない。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405093758-qcqi_%E6%BC%94%E7%BF%92_2_5/",
                "title": "QCQI/演習 2.5",
                "section": "post",
                "date" : "2021.04.05",
                "body": "\\(\\mathcal{C}^n\\) の内積の定義\n\\begin{equation*} ((y_1, \\ldots, y_n), (z_1, \\ldots, z_n)) \\equiv \\sum_i y_i^{\\ast}z_i = \\begin{bmatrix} y_1^{\\ast}, \\ldots, y_n^{\\ast} \\end{bmatrix}\\begin{bmatrix} z_1 \\newline \\vdots \\newline z_n \\end{bmatrix} \\end{equation*}\nが内積の要請をすべて満たすことを確認する。\n線形性\n\\begin{eqnarray*} \\left(\\ket{v}, \\sum_i \\lambda_i\\ket{w_i}\\right) \u0026amp;=\u0026amp; \\sum_j v_j^{\\ast} \\left(\\sum_i \\lambda_i w_{ij}\\right) \\\\\\\n\u0026amp;=\u0026amp; \\sum_i \\lambda_i \\left(\\sum_j v_j^{\\ast} w_{ij}\\right) \\\\\\\n\u0026amp;=\u0026amp; \\sum_i \\lambda_i (\\ket{v}, \\ket{w_i}) \\end{eqnarray*}\n対称性\n\\begin{eqnarray*} (\\ket{v}, \\ket{w}) \u0026amp;=\u0026amp; \\sum_i v_i^{\\ast}w_i \\\\\\\n\u0026amp;=\u0026amp; \\sum_i (v_i w_i^{\\ast})^{\\ast} \\\\\\\n\u0026amp;=\u0026amp; \\sum_i (w_i^{\\ast} v_i)^{\\ast} \\\\\\\n\u0026amp;=\u0026amp; (\\ket{w}, \\ket{v})^{\\ast} \\end{eqnarray*}\n正値性、正定値性\n\\begin{eqnarray*} (\\ket{v}, \\ket{v}) \u0026amp;=\u0026amp; \\sum_i v_i^{\\ast}v_i \\\\\\\n\u0026amp;=\u0026amp; \\sum_i |v_i|^2 \\geq 0 \\end{eqnarray*}\n明らかに、等号が成り立つのは \\(\\ket{v} = 0\\) のときのみ。\n以上より、\\(\\mathcal{C}^n\\) は内積 \\((\\cdot , \\cdot)\\) を備えた内積空間である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405105718-qcqi_%E6%BC%94%E7%BF%92_2_6/",
                "title": "QCQI/演習 2.6",
                "section": "post",
                "date" : "2021.04.05",
                "body": "内積の対称性より、\n\\begin{equation*} \\left(\\sum_i \\lambda_i \\ket{w_i}, \\ket{v}\\right) = \\left(\\ket{v}, \\sum_i \\lambda_i \\ket{w_i}\\right)^{\\ast} \\end{equation*}\n内積は第 2 引数に関して線形だから、\n\\begin{equation*} \\phantom{\\left(\\sum_i \\lambda_i \\ket{w_i}, \\ket{v}\\right)} = \\left(\\sum_i \\lambda_i (\\ket{v}, \\ket{w_i})\\right)^{\\ast} \\end{equation*}\n内積の出力は複素数だから、\n\\begin{equation*} \\phantom{\\left(\\sum_i \\lambda_i \\ket{w_i}, \\ket{v}\\right)} = \\sum_i \\lambda_i^{\\ast} (\\ket{v}, \\ket{w_i})^{\\ast} \\end{equation*}\n内積の対称性より、\n\\begin{equation*} \\phantom{\\left(\\sum_i \\lambda_i \\ket{w_i}, \\ket{v}\\right)} = \\sum_i \\lambda_i^{\\ast} (\\ket{w_i}, \\ket{v}) \\end{equation*}\nよって任意の内積 \\((\\cdot , \\cdot)\\) は第 1 引数に関して共役線形。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405132421-qcqi_%E6%BC%94%E7%BF%92_2_7/",
                "title": "QCQI/演習 2.7",
                "section": "post",
                "date" : "2021.04.05",
                "body": "\\(\\ket{w}\\) と \\(\\ket{v}\\) の内積を計算すると、\n\\begin{equation} \\braket{w|v} = \\begin{bmatrix} 1 \u0026amp; 1 \\end{bmatrix}^{\\ast}\\begin{bmatrix} 1 \\newline -1 \\end{bmatrix} = 1\\times1 + 1 \\times (-1) = 0 \\end{equation}\nよって \\(\\ket{w}\\) と \\(\\ket{v}\\) は直交している。\n\\(\\|\\ket{w}\\| = \\sqrt{\\braket{w|w}} = \\sqrt{2},\\ \\|\\ket{v}\\| = \\sqrt{\\braket{v|v}} = \\sqrt{2}\\) なので、それぞれを正規化すると、\n\\begin{equation*} \\frac{\\ket{w}}{\\|\\ket{w}\\|} = \\frac{1}{\\sqrt{2}}\\ket{w},\\ \\frac{\\ket{v}}{\\|\\ket{v}\\|} = \\frac{1}{\\sqrt{2}}\\ket{v} \\end{equation*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405144551-qcqi_%E6%BC%94%E7%BF%92_2_8/",
                "title": "QCQI/演習 2.8",
                "section": "post",
                "date" : "2021.04.05",
                "body": "グラム・シュミット直交化によって、内積を持つベクトル空間 \\(V\\) に対する正規直交基底 \\(\\ket{v_1}, \\ldots, \\ket{v_d}\\) が得られることを数学的帰納法で示す。\nベースケースとして \\(V\\) の正規直交基底の元が 1 つのとき、\\(\\ket{v_1}\\) は、\n\\begin{eqnarray*} \\ket{v_1} \u0026amp;=\u0026amp; \\frac{\\ket{w_1}}{\\|\\ket{w_1}\\|} \\end{eqnarray*}\nこれは正規化されていて、ベクトルが 1 つだけなので直交性も明らか。よって \\(\\{\\ket{v_1}\\}\\) は \\(V\\) の正規直交基底である。\nグラム・シュミット直交化によって \\(k\\) 個の元を持つ正規直交基底 \\(\\ket{v_1}, \\ldots, \\ket{v_k}\\) が作られると仮定する。\nこのとき、グラム・シュミット直交化によって作った \\(k+1\\) 番目のベクトル \\(\\ket{v_{k+1}}\\) が正規であり、\\(\\ket{v_1}, \\ldots, \\ket{v_k}\\) のそれぞれと直交することを示す。\n\\begin{eqnarray*} \\ket{v_{k+1}} = \\frac{\\ket{w_{k+1}} - \\sum_{i=1}^k\\braket{v_i|w_{k+1}}\\ket{v_i}}{\\|\\ket{w_{k+1}} - \\sum_{i=1}^k\\braket{v_i|w_{k+1}}\\ket{v_i}\\|} \\end{eqnarray*}\n定義よりこれが正規であることは明らか。\\(\\ket{v_1}, \\ldots, \\ket{v_k}\\) との直交性は、\\(1 \\leq j \\leq k\\) とすると、\n\\begin{eqnarray*} \\braket{v_j|v_{k+1}} \u0026amp;=\u0026amp; \\bra{v_j} \\left(\\frac{\\ket{w_{k+1}} - \\sum_{i=1}^{n} \\braket{v_i|w_{k+1}}\\ket{v_i}}{\\|\\ket{w_{k+1}} - \\sum_{i=1}^{n} \\braket{v_i|w_{k+1}}\\ket{v_i}\\|}\\right) \\\\\\\n\u0026amp;=\u0026amp; \\frac{\\braket{v_j|w_{k+1}} - \\sum_{i=1}^{n} \\braket{v_i|w_{k+1}} \\braket{v_j|v_i}}{\\|\\ket{w_{k+1}} - \\sum_{i=1}^{n} \\braket{v_i|w_{k+1}}\\ket{v_i}\\|} \\\\\\\n\u0026amp;=\u0026amp; \\frac{\\braket{v_j|w_{k+1}} - \\sum_{i=1}^{n} \\braket{v_i|w_{k+1}} \\delta_{ij}}{\\|\\ket{w_{k+1}} - \\sum_{i=1}^{n} \\braket{v_i|w_{k+1}}\\ket{v_i}\\|} \\\\\\\n\u0026amp;=\u0026amp; \\frac{\\braket{v_j|w_{k+1}} - \\braket{v_j|w_{k+1}}}{\\|\\ket{w_{k+1}} - \\sum_{i=1}^{n} \\braket{v_i|w_{k+1}}\\ket{v_i}\\|} \\\\\\\n\u0026amp;=\u0026amp; 0 \\end{eqnarray*}\nよって数学的帰納法によって、グラム・シュミット直交化によって \\(V\\) に対する正規直交基底が得られることが示された。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405141728-%E3%82%AF%E3%83%A9%E3%83%A0_%E3%82%B7%E3%83%A5%E3%83%9F%E3%83%83%E3%83%88%E7%9B%B4%E4%BA%A4%E5%8C%96/",
                "title": "グラム・シュミット直交化",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル空間の基底集合から正規直交基底集合を作るための方法。おおまかには次の手順で行われる:\n 基底集合の 1 番目のベクトルを正規化する 基底集合の 2 番目のベクトルを、正規化した 1 番目のベクトルと垂直 (内積 = 0) にし、正規化する 基底集合の 3 番目のベクトルを、正規直交化した 1, 2 番目のベクトルと垂直にし、正規化する (繰り返し)  一般化すると次のようになる。\\(\\ket{w_1}, \\ldots, \\ket{w_d}\\) がベクトル空間 \\(V\\) に対する基底集合、作りたい正規直交基底集合を \\(\\ket{v_1}, \\ldots, \\ket{v_d}\\) とする。\\(\\ket{v_1} \\equiv \\ket{w_1} / \\|\\ket{w_1}\\|\\) と定義し、\\(1 \\leq k \\leq d - 1\\) に対して帰納的に \\(\\ket{v_{k_1}}\\) を次のように定義する。\n\\begin{equation*} \\ket{v_{k+1}} \\equiv \\frac{\\ket{w_{k+1}} - \\sum^k_{i=1} \\braket{v_i|w_{k+1}}\\ket{v_i}}{\\|\\ket{w_{k+1}} - \\sum^k_{i=1}\\braket{v_i|w_{k+1}}\\ket{v_i}\\|} \\end{equation*}\nこの方法によって正規直交基底集合が作れるので、任意の (有限) \\(d\\) 次元のベクトル空間は正規直交基底 \\(\\ket{v_1}, \\ldots, \\ket{v_d}\\) を持つ。\n関連ノート  グラム・シュミット直交化の証明 (QCQI/演習 2.8)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405113237-%E3%83%8E%E3%83%AB%E3%83%A0/",
                "title": "ノルム",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル \\(\\ket{v}\\) のノルムを内積を使って次式で定義する\n\\begin{equation*} \\|\\ket{v}\\| \\equiv \\sqrt{\\braket{v|v}} \\end{equation*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405084714-%E3%83%8F%E3%82%A6%E3%83%AA%E8%A1%8C%E5%88%97/",
                "title": "パウリ行列",
                "section": "post",
                "date" : "2021.04.05",
                "body": "量子コンピュータ分野で頻出する行列で、下記のようにいろいろな記号での表し方がある。とにかくよく使うので暗記してしまおう。\n\\begin{align*} \\sigma_{0} \\equiv I \u0026amp;\\equiv \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} \u0026amp; \\sigma_{1} \\equiv \\sigma_{x} \\equiv X \u0026amp;\\equiv \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\newline\\newline \\sigma_{2} \\equiv \\sigma{y} \\equiv Y \u0026amp;\\equiv \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \u0026amp; \\sigma_{3} \\equiv \\sigma_{z} \\equiv Z \u0026amp;\\equiv \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\end{align*}\n関連ノート  パウリ演算子の外積表現  参照  Quantum Computation and Quantum Information 2.1.3  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405112448-%E3%83%92%E3%83%AB%E3%83%98%E3%83%AB%E3%83%88%E7%A9%BA%E9%96%93/",
                "title": "ヒルベルト空間",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル空間のうち内積を備えており (= 内積空間)、かつベクトルの要素が実数か複素数の範囲であり連続 (数学の言葉で「完備性を持つ」と言う) つまり微分などの計算もできるベクトル空間のこと。平たく言うと和、スカラー倍、内積、微分などの「ふつうの計算」には困らないベクトル空間をヒルベルト空間と呼ぶ。\n量子コンピュータではふつう、有限次元の複素ベクトル空間についてのみ扱う。この場合「内積空間 = ヒルベルト空間」。なので、ヒルベルト空間と聞けばそれは内積空間のことだと思ってよい。\n参考ページ  EMAN の物理学 ヒルベルト空間  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405091552-%E5%86%85%E7%A9%8D/",
                "title": "内積",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル空間の 2 つのベクトル \\(|v\\rangle\\) と \\(|w\\rangle\\) を入力とし複素数を出力として作り出す関数を内積と呼ぶ。\nベクトル空間 \\(V\\) について、\\(V \\times V\\) から \\(\\mathcal{C}\\) への関数 \\((\\cdot , \\cdot)\\) が次の要請を満たすなら内積:\n 内積は第 2 引数に関して線形 内積の対称性 内積の正値性  内積が定義できると、ノルムや直交などが定義できる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405093150-%E5%86%85%E7%A9%8D%E7%A9%BA%E9%96%93/",
                "title": "内積空間",
                "section": "post",
                "date" : "2021.04.05",
                "body": "内積を備えたベクトル空間を内積空間と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405113700-%E5%8D%98%E4%BD%8D%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/",
                "title": "単位ベクトル",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ノルム \\(\\||v\\rangle\\| = 1\\) となるベクトル \\(|v\\rangle\\) を単位ベクトルと呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405113900-%E6%AD%A3%E8%A6%8F%E5%8C%96/",
                "title": "正規化",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル \\(|v\\rangle\\) について、もしノルム \\(\\|v\\rangle\\| = 1\\) ならば、\\(|v\\rangle\\) は正規化 (または規格化) されているという。ゼロでないベクトル \\(|v\\rangle\\) について \\(|v\\rangle / \\||v\\rangle\\|\\) は \\(|v\\rangle\\) を正規化した形。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405131650-%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4/",
                "title": "正規直交",
                "section": "post",
                "date" : "2021.04.05",
                "body": "インデックス \\(i\\) を持つベクトルの集合 \\(|i\\rangle\\) の各々が単位ベクトルであり、その集合のうち互いに異なるベクトルが直交しているとき、つまりインデックスの集合から選んだ \\(i\\) と \\(j\\) に対して \\(\\langle i|j \\rangle = \\delta_{ij}\\) のとき、集合 \\(|i\\rangle\\) は正規直交であるという。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405112937-%E7%9B%B4%E4%BA%A4/",
                "title": "直交",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル \\(|w\\rangle\\) とベクトル \\(|v\\rangle\\) の内積が \\(0\\) のとき両ベクトルは直交しているという。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402160012-qcqi_%E6%BC%94%E7%BF%92_2_1/",
                "title": "QCQI/演習 2.1",
                "section": "post",
                "date" : "2021.04.02",
                "body": "ベクトル \\((1, -1)\\), \\((1, 2)\\) および \\((2, 1)\\) は\n\\begin{equation*} \\begin{bmatrix} 2 \\newline 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\newline -1 \\end{bmatrix} + \\begin{bmatrix} 1 \\newline 2 \\end{bmatrix} \\end{equation*}\nを満たすので、これら 3 つのベクトルは線形従属。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402160242-qcqi_%E6%BC%94%E7%BF%92_2_2/",
                "title": "QCQI/演習 2.2",
                "section": "post",
                "date" : "2021.04.02",
                "body": "\\(A\\) の行列表現 演算子は行列で表現できることから、\\(\\ket{v_i}\\) を \\(V\\) の基底、\\(A_{ij}\\) を演算子 \\(A\\) の行列表現の要素とすると、\n\\[A\\ket{v_j} = \\sum_i A_{ij}\\ket{v_i}\\]\n\\(A\\ket{0} = \\ket{1}\\) だから、\n\\begin{eqnarray*} A\\ket{0} \u0026amp;=\u0026amp; \\sum_i A_{i1}\\ket{v_i} \\\\\\\n\u0026amp;=\u0026amp; A_{11}\\ket{0} + A_{21}\\ket{1} \\\\\\\n\u0026amp;=\u0026amp; \\ket{1} \\end{eqnarray*}\nよって \\(A_{11} = 0\\), \\(A_{21} = 1\\).\n同様に、\\(A\\ket{1} = \\ket{0}\\) だから、\n\\begin{eqnarray*} A\\ket{1} \u0026amp;=\u0026amp; \\sum_i A_{i2}\\ket{v_i} \\\\\\\n\u0026amp;=\u0026amp; A_{12}\\ket{0} + A_{22}\\ket{1} \\\\\\\n\u0026amp;=\u0026amp; \\ket{0} \\end{eqnarray*}\nよって \\(A_{12} = 1\\), \\(A_{22} = 0\\)\n以上より \\(A\\) の行列表現は、\n\\begin{equation*} A = \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\end{equation*}\n\\(A\\) の異なる行列表現を与える入力と出力の基底 \\(V\\) の基底として次を選ぶ:\n\\begin{eqnarray*} \\ket{+} \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1}) \\\\\\\n\\ket{-} \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(\\ket{0} - \\ket{1}) \\end{eqnarray*}\nここで \\(A\\ket{+}\\) と \\(A\\ket{-}\\) を計算すると、\n\\begin{eqnarray*} A\\ket{+} \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(A\\ket{0} + A\\ket{1}) \\\\\\\n\u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(\\ket{1} + \\ket{0}) \\\\\\\n\u0026amp;=\u0026amp; \\ket{+} \\end{eqnarray*}\n\\begin{eqnarray*} A\\ket{-} \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(A\\ket{0} - A\\ket{1}) \\\\\\\n\u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(\\ket{1} - \\ket{0}) \\\\\\\n\u0026amp;=\u0026amp; -\\ket{-} \\end{eqnarray*}\nこれらの結果と行列 \\(A\\) の要素 \\(A_{ij}\\) を求める式から、\n\\begin{eqnarray*} A\\ket{+} \u0026amp;=\u0026amp; \\sum_i A_{i1}\\ket{v_i} \\\\\\\n\u0026amp;=\u0026amp; A_{11}\\ket{+} + A_{21}\\ket{-} \\\\\\\n\u0026amp;=\u0026amp; \\ket{+} \\end{eqnarray*}\nよって \\(A_{11} = 1\\), \\(A_{21} = 0\\)\n\\begin{eqnarray*} A\\ket{-} \u0026amp;=\u0026amp; \\sum_i A_{i2}\\ket{v_i} \\newline \u0026amp;=\u0026amp; A_{12}\\ket{+} + A_{22}\\ket{-} \\newline \u0026amp;=\u0026amp; -\\ket{-} \\end{eqnarray*}\nよって \\(A_{12} = 0\\), \\(A_{22} = -1\\)\n以上より \\(A\\) の行列表現は\n\\begin{equation} A = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\end{equation}\nとなり、異なる行列表現を持つ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402160643-qcqi_%E6%BC%94%E7%BF%92_2_3/",
                "title": "QCQI/演習 2.3",
                "section": "post",
                "date" : "2021.04.02",
                "body": "演算子は行列で表現できることから、演算子 \\(A\\), \\(B\\) それぞれの行列表現の要素について次が成り立つ。\n\\begin{equation*} A\\ket{v_j} = \\sum_i A_{ij}\\ket{w_i} \\end{equation*}\n\\begin{equation*} B\\ket{w_i} = \\sum_k A_{ki}\\ket{x_k} \\end{equation*}\nここで線形変換 \\(BA\\) の行列表現は、\n\\begin{eqnarray*} BA\\ket{v_j} \u0026amp;=\u0026amp; B(A\\ket{v_j}) \\\\\\\n\u0026amp;=\u0026amp; B\\left(\\sum_i A_{ij}\\ket{w_i}\\right) \\\\\\\n\u0026amp;=\u0026amp; \\sum_i A_{ij}\\sum_k B_{ki}\\ket{x_k} \\end{eqnarray*}\nシグマの分解公式より\n\\begin{eqnarray*} \\phantom{BA\\ket{v_j}} \u0026amp;=\u0026amp; \\sum_i\\sum_k A_{ij}B_{ki}\\ket{x_k} \\\\\\\n\u0026amp;=\u0026amp; \\sum_k\\sum_i A_{ij}B_{ki}\\ket{x_k} \\\\\\\n\u0026amp;=\u0026amp; \\sum_k\\sum_i B_{ki}A_{ij}\\ket{x_k} \\\\\\\n\u0026amp;=\u0026amp; \\sum_k\\left(\\sum_i B_{ki}A_{ij}\\right)\\ket{x_k} \\\\\\\n\u0026amp;=\u0026amp; \\sum_k(BA)_{kj}\\ket{x_k} \\end{eqnarray*}\nと変形でき、これは \\(B\\) と \\(A\\) の行列表現の行列積である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402161917-qcqi_%E6%BC%94%E7%BF%92_2_4/",
                "title": "QCQI/演習 2.4",
                "section": "post",
                "date" : "2021.04.02",
                "body": "\\(V\\) の基底 \\(\\ket{v_1}, \\ldots, \\ket{v_m}\\) について、演算子は行列で表現できることから、恒等演算子 \\(I\\) の要素 \\(I_{ij}\\) について次が成り立つ。\n\\begin{equation*} I\\ket{v_j} = \\sum_i I_{ij}\\ket{v_i} \\end{equation*}\nここで \\(I\\ket{v_i} = \\ket{v_i}\\ (i = 1, \\ldots, m)\\) なので、\n\\begin{equation*} I_{ij}= \\begin{cases} 1 \u0026amp; (i = j) \\newline 0 \u0026amp; (otherwise) \\end{cases} \\end{equation*}\nよって、\\(I\\) は対角成分が \\(1\\) で他がすべて \\(0\\) の行列表現 (単位行列) を持つ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402105729-quantum_computation_and_quantum_information/",
                "title": "Quantum Computation and Quantum Information",
                "section": "post",
                "date" : "2021.04.02",
                "body": "  演習と問題の解答 1 Introduction and overview 1.6.2 Quantum information in a wider context  QCQI/問題 1.1 QCQI/問題 1.2  2 Introduction to quantum mechanics 2.1.1 Bases and linear independence  QCQI/演習 2.1  2.1.2 Linear operators and matrices  QCQI/演習 2.2 QCQI/演習 2.3 QCQI/演習 2.4  2.1.4 Inner products  QCQI/演習 2.5 QCQI/演習 2.6 QCQI/演習 2.7 QCQI/演習 2.8 QCQI/演習 2.9 QCQI/演習 2.10  2.1.5 Eigenvectors and eigenvalues  QCQI/演習 2.11 QCQI/演習 2.12  2.1.6 Adjoints and Hermitian operators  QCQI/演習 2.13 QCQI/演習 2.14 QCQI/演習 2.15 QCQI/演習 2.16 QCQI/演習 2.17 QCQI/演習 2.18 QCQI/演習 2.19 QCQI/演習 2.20 QCQI/演習 2.21 QCQI/演習 2.22 QCQI/演習 2.23 QCQI/演習 2.24 QCQI/演習 2.25  2.1.7 Tensor products  QCQI/演習 2.26 QCQI/演習 2.27 QCQI/演習 2.28 QCQI/演習 2.29 QCQI/演習 2.30 QCQI/演習 2.31 QCQI/演習 2.32 QCQI/演習 2.33  2.1.8 Operator functions  QCQI/演習 2.34 QCQI/演習 2.35 QCQI/演習 2.36 QCQI/演習 2.37 QCQI/演習 2.38 QCQI/演習 2.39  2.1.9 The commutator and anti-commutator  QCQI/演習 2.40 QCQI/演習 2.41 QCQI/演習 2.42 QCQI/演習 2.43 QCQI/演習 2.44 QCQI/演習 2.45 QCQI/演習 2.46 QCQI/演習 2.47  2.1.10 The polar and singular value decompositions  QCQI/演習 2.48 QCQI/演習 2.49 QCQI/演習 2.50  2.2.2 Evolution  QCQI/演習 2.51 QCQI/演習 2.52 QCQI/演習 2.53 QCQI/演習 2.54 QCQI/演習 2.55 QCQI/演習 2.56  2.2.3 Quantum measurement  QCQI/演習 2.57  2.2.5 Projective measurements  QCQI/演習 2.58 QCQI/演習 2.59 QCQI/演習 2.60 QCQI/演習 2.61  2.2.6 POVM measurements  QCQI/演習 2.62 QCQI/演習 2.63 QCQI/演習 2.64  2.2.7 Phase  QCQI/演習 2.65  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402153637-%E3%82%B7%E3%82%AF%E3%83%9E%E3%81%AE%E5%88%86%E8%A7%A3%E5%85%AC%E5%BC%8F/",
                "title": "シグマの分解公式",
                "section": "post",
                "date" : "2021.04.02",
                "body": "分配法則 \\(a_1 b_1 + a_1 b_2 + a_2 b_1 + a_2 b_2 = (a_1 + a_2)(b_1 + b_2)\\) の一般化として、二重和について次の公式がある。\n\\begin{equation} \\sum_{i=1}^{m} \\sum_{j=1}^n a_i b_j = \\sum_{i=1}^m a_i \\sum_{j=1}^n b_j \\end{equation}\n証明 \\begin{eqnarray} \\sum_{i=1}^{m} \\sum_{j=1}^n a_i b_j \u0026amp;=\u0026amp; a_1 \\sum_{j=1}^n b_j + a_2 \\sum_{j=1}^n b_j + \\ldots + a_m \\sum_{j=1}^n b_j \\newline \u0026amp;=\u0026amp; (a_1 + a_2 + \\ldots + a_m) \\sum_{j=1}^n b_j \\newline \u0026amp;=\u0026amp; \\sum_{i=1}^m a_i \\sum_{j=1}^n b_j \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401101150-%E6%81%92%E7%AD%89%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "恒等演算子",
                "section": "post",
                "date" : "2021.04.01",
                "body": "恒等演算子は任意のベクトル空間 \\(V\\) における演算子のひとつで、すべてのベクトル \\(|v\\rangle\\) に対して\n\\[I_{V}\\ket{v} \\equiv \\ket{v}\\]\nで定義する。単位オペレータとも呼ぶ。\nほとんどの場合、混乱が生じなければ下添字 \\(V\\) を省略して単に \\(I\\) と書く。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401105504-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%A8%E8%A1%8C%E5%88%97%E3%81%AF%E7%AD%89%E4%BE%A1/",
                "title": "演算子と行列は等価",
                "section": "post",
                "date" : "2021.04.01",
                "body": "行列は演算子とみなせることと、演算子は行列で表現できることから、演算子と行列は完全に等価。\nただし演算子の行列表現で見たように、行列と演算子を関連付けるには、演算子の入力ベクトル空間の基底と出力空間の基底を指定しなければならない。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401102640-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%90%88%E6%88%90/",
                "title": "演算子の合成",
                "section": "post",
                "date" : "2021.04.01",
                "body": "\\(V\\), \\(W\\), および \\(X\\) がベクトル空間であり、\\(A: V \\rightarrow W\\) と \\(B: W \\rightarrow X\\) が演算子であるとする。このとき \\(A\\) と \\(B\\) の合成を記号 \\(BA\\) で表し、\n\\[(BA)(\\ket{v}) \\equiv B(A\\ket{v})\\]\nで定義する。\n演算子と行列は等価なので、\\((BA)(|v\\rangle)\\) は括弧を省略して \\(BA|v\\rangle\\) と書ける。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401104202-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AF%E8%A1%8C%E5%88%97%E3%81%A6%E8%A1%A8%E7%8F%BE%E3%81%A6%E3%81%8D%E3%82%8B/",
                "title": "演算子は行列で表現できる",
                "section": "post",
                "date" : "2021.04.01",
                "body": "演算子 \\(A\\) の入力ベクトル空間の基底と出力空間の基底を指定すると、次のように \\(A\\) の行列表現を決めることができる。\n\\(A: V \\rightarrow W\\) がベクトル空間 \\(V\\) と \\(W\\) との間の演算子であるとする。さらに \\(V\\) の基底が \\(\\ket{v_1}, \\ldots, \\ket{v_m}\\), \\(W\\) の基底が \\(\\ket{w_1}, \\ldots, \\ket{w_n}\\) であるとする。\\(1, \\ldots, m\\) の範囲の各 \\(j\\) に対して、\n\\[A\\ket{v_j} = \\sum_i A_{ij}\\ket{w_i}\\]\nを満たす複素数 \\(A_{1j}, \\ldots, A_{nj}\\) が存在する。要素 \\(A_{ij}\\) をもつ行列 \\(A\\) を演算子 \\(A\\) の行列表現と呼ぶ。\n関連ノート  演算子の行列表現の例 (QCQI/演習 2.2) 演算子の積の行列表現 (QCQI/演習 2.3) 単位元の行列表現 (QCQI/演習 2.4)  参照  Quantum Computation and Quantum Information 2.1.2  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401101005-%E7%B7%9A%E5%BD%A2%E3%82%AA%E3%83%98%E3%83%AC%E3%83%BC%E3%82%BF/",
                "title": "線形オペレータ",
                "section": "post",
                "date" : "2021.04.01",
                "body": "演算子を参照\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401103405-%E8%A1%8C%E5%88%97%E3%81%AF%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%A8%E3%81%BF%E3%81%AA%E3%81%9B%E3%82%8B/",
                "title": "行列は演算子とみなせる",
                "section": "post",
                "date" : "2021.04.01",
                "body": "要素 \\(A_{ij}\\) を持つ \\(m \\times n\\) の複素行列 \\(A\\) は、行列 \\(A\\) と \\(\\mathcal{C}^n\\) のベクトルとの行列積により、ベクトル空間 \\(\\mathcal{C}^n\\) からベクトル空間 \\(\\mathcal{C}^m\\) に移すので、行列 \\(A\\) は演算子である。\nより正確には行列 \\(A\\) が演算子であるということは、演算子の定義で見た\n\\[A\\left(\\sum_i a_i\\ket{v_i}\\right) = \\sum_i a_i A(\\ket{v_i})\\]\nが行列 \\(A\\) と列ベクトルの行列積で成り立つことを意味し、行列の性質からこれは明らかに正しい。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401105821-%E8%A1%8C%E5%88%97%E8%A1%A8%E7%8F%BE/",
                "title": "行列表現",
                "section": "post",
                "date" : "2021.04.01",
                "body": "参照: 演算子は行列で表現できる\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401101830-%E9%9B%B6%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "零演算子",
                "section": "post",
                "date" : "2021.04.01",
                "body": "零演算子はすべてのベクトルをゼロベクトルに移す演算子で、\\(0\\) と書く。\n\\[0\\ket{v} \\equiv 0\\]\n零演算子はゼロオペレータとも呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210331111403-%E3%82%B9%E3%83%8F%E3%83%B3%E9%9B%86%E5%90%88/",
                "title": "スパン集合",
                "section": "post",
                "date" : "2021.03.31",
                "body": "ベクトル空間のスパン集合とは、その空間の任意のベクトル \\(\\ket{v}\\) が線形結合 \\(\\ket{v} = \\sum_{i}a_i\\ket{v_i}\\) で表せるようなベクトル集合 \\(\\ket{v_1}, \\ldots, \\ket{v_n}\\) のこと。\nたとえば、ベクトル空間 \\(\\mathcal{C}^2\\) のスパン集合の 1 つは、\n\\begin{equation*} \\ket{v_1} \\equiv \\begin{bmatrix} 1 \\newline 0 \\end{bmatrix};~ \\ket{v_2} \\equiv \\begin{bmatrix} 0 \\newline 1 \\end{bmatrix} \\end{equation*}\nなぜなら \\(\\mathcal{C}^2\\) の任意のベクトル\n\\begin{equation*} \\ket{v} = \\begin{bmatrix} a_1 \\newline a_2 \\end{bmatrix} \\end{equation*}\nはベクトル \\(\\ket{v_1}\\) と \\(\\ket{v_2}\\) の線形結合 \\(\\ket{v} = a_1\\ket{v_1} + a_2\\ket{v_2}\\) で書けるから。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210331121800-%E5%9F%BA%E5%BA%95/",
                "title": "基底",
                "section": "post",
                "date" : "2021.03.31",
                "body": "ベクトル空間 \\(V\\) の元の集合 \\(\\ket{v_1}, \\ldots, \\ket{v_n}\\) が次の 2 つの性質をみたすとき、これを \\(V\\) の基底と呼ぶ。\n \\(\\ket{v_1}, \\ldots, \\ket{v_n}\\) は線形独立 \\(V\\) の任意の元は \\(\\ket{v_1}, \\ldots, \\ket{v_n}\\) の線形結合で表せる  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210331122717-%E6%AC%A1%E5%85%83/",
                "title": "次元",
                "section": "post",
                "date" : "2021.03.31",
                "body": "ベクトル空間 \\(V\\) の基底の要素の数を次元と呼び、\\(\\mathrm{dim}V\\) と表す。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210331120144-%E7%B7%9A%E5%BD%A2%E5%BE%93%E5%B1%9E/",
                "title": "線形従属",
                "section": "post",
                "date" : "2021.03.31",
                "body": "\\(0\\) でないベクトル \\(\\ket{v_1}, \\ldots, \\ket{v_n}\\) について、少なくとも 1 つの \\(i\\) に対して \\(a_i \\neq 0\\) であり、\n\\[a_1\\ket{v_1} + a_2\\ket{v_2} + \\ldots + a_n\\ket{v_n} = 0\\]\nを満たす複素数の集合 \\(a_1, \\ldots, a_n\\) が存在するならば、ベクトル \\(\\ket{v_1}, \\ldots, \\ket{v_n}\\) は線形従属であるという。\n関連ノート  線形従属の例 (QCQI/演習 2.1) 線形独立  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210331120821-%E7%B7%9A%E5%BD%A2%E7%8B%AC%E7%AB%8B/",
                "title": "線形独立",
                "section": "post",
                "date" : "2021.03.31",
                "body": "\\(0\\) でないベクトルの集合 \\(\\ket{v_1}, \\ldots, \\ket{v_n}\\) が線形従属でなければ、それは線形独立であるという。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330141705-%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC%E5%80%8D%E6%BC%94%E7%AE%97/",
                "title": "スカラー倍演算",
                "section": "post",
                "date" : "2021.03.30",
                "body": "ベクトル空間上の演算の一つ。たとえば \\(\\mathcal{C}^n\\) 空間では次式で定義される。\n\\begin{equation*} z \\begin{bmatrix} z_1 \\newline \\vdots \\newline z_n \\end{bmatrix} \\equiv \\begin{bmatrix} zz_1 \\newline \\vdots \\newline zz_n \\end{bmatrix} \\end{equation*}\n関連ノート  和演算  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330142839-%E3%82%BB%E3%83%AD%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/",
                "title": "ゼロベクトル",
                "section": "post",
                "date" : "2021.03.30",
                "body": "あるベクトル空間について、任意のベクトル \\(\\ket{v}\\) に対して \\(\\ket{v} + \\ket{\\theta} = \\ket{v}\\) を満たすベクトル \\(\\ket{\\theta}\\) をゼロベクトルと呼び、\\(0\\) で表す。\nつまり、ゼロベクトルはベクトル空間の零元である。\nちなみになぜ \\(\\ket{0}\\) と書かないかと言うと、\\(\\ket{0}\\) は通常、基底状態のひとつ\n\\begin{equation*} \\begin{bmatrix} 1 \\newline 0 \\end{bmatrix} \\end{equation*}\nを表すのに使うから。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330140009-%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/",
                "title": "ベクトル",
                "section": "post",
                "date" : "2021.03.30",
                "body": "次のような数の組をベクトルと呼ぶ。\n\\begin{equation*} \\begin{bmatrix} z_1 \\newline \\vdots \\newline z_n \\end{bmatrix} \\end{equation*}\n量子力学的な慣用記号 (ディラック記法) では、\\(\\psi\\) をラベルとしてベクトルを\n\\[\\ket{\\psi}\\]\nと表す。\nベクトルはベクトル空間の要素 (元) である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330135536-%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB%E7%A9%BA%E9%96%93/",
                "title": "ベクトル空間",
                "section": "post",
                "date" : "2021.03.30",
                "body": "和とスカラー倍が定義されている集合で、線形空間とも呼ぶ。ベクトル空間の要素をベクトルと呼ぶ。たとえば次はどれもベクトル空間。\n \\(\\mathcal{R}\\) 実数全体 \\(\\mathcal{R}\\) からなるベクトル空間 \\(\\mathcal{C}\\) 複素数全体 \\(\\mathcal{C}\\) からなるベクトル空間 \\(\\mathcal{R}^n\\) \\(n\\) 次元実数ベクトル全体 \\(\\mathcal{R}^n\\) からなるベクトル空間 \\(\\mathcal{C}^n\\) \\(n\\) 次元複素ベクトル全体 \\(\\mathcal{C}^n\\) からなるベクトル空間 \\(\\mathcal{M}\\) \\(2\\) 次の正方行列全体からなるベクトル空間 \\(\\mathcal{F}\\) 実数関数 \\(f(x)\\) のすべてからなるベクトル空間 \\(\\mathcal{Z}\\) ゼロベクトルからのみなるベクトル空間  このようにベクトル空間にはいろいろあって、空間によってはベクトルが行列であったり関数であったりもすることに注意。\n厳密には、ある集合がベクトル空間となるには次の 8 つの条件を満たす必要がある (ただ、普通は問題にはならない)。\n集合 \\(V\\) の任意の元 \\(\\ket{\\psi}\\) と \\(\\ket{\\phi}\\) について、\n和の性質  交換則 \\(\\ket{\\psi} + \\ket{\\phi} = \\ket{\\phi} + \\ket{\\psi}\\) 結合則 \\(\\ket{\\psi} + (\\ket{\\phi} + \\ket{\\xi}) = (\\ket{\\psi} + \\ket{\\phi}) + \\ket{\\xi}\\) 零元の存在 \\(\\exists1\\ \\ket{\\theta} \\in V\\ \\mathrm{s.t.}\\ \\forall\\ket{\\psi} \\in V,\\ \\ket{\\psi} + \\ket{\\theta} = \\ket{\\psi}\\) 逆元の存在 \\(\\forall\\ket{\\psi} \\in V,\\ \\exists1\\ \\ket{\\xi} \\in V\\ \\mathrm{s.t.}\\ \\ket{\\psi} + \\ket{\\xi} = \\ket{\\theta}\\)  スカラー倍の性質  単位元の存在 \\(1\\cdot\\ket{\\psi} = \\ket{\\psi}\\) 結合則 \\(a\\cdot(b\\cdot \\ket{\\psi}) = (ab)\\cdot\\ket{\\psi}\\) 分配則 1 \\(a\\cdot(\\ket{\\psi} + \\ket{\\phi}) = a\\cdot\\ket{\\psi} + a\\cdot\\ket{\\phi}\\) 分配則 2 \\((a + b)\\cdot\\ket{\\psi} = a\\cdot\\ket{\\psi} + b\\cdot\\ket{\\psi}\\)  参考文献  線形代数セミナー ストラング: 線形代数イントロダクション 量子情報科学入門  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330140453-%E5%92%8C%E6%BC%94%E7%AE%97/",
                "title": "和演算",
                "section": "post",
                "date" : "2021.03.30",
                "body": "2 つのベクトルの組を 1 つのベクトルに変換する演算。\nベクトル空間 \\(\\mathcal{C}^n\\) ではベクトルの和演算は次式で定義する。\n\\begin{equation*} \\begin{bmatrix} z_1 \\newline \\vdots \\newline z_n \\end{bmatrix} + \\begin{bmatrix} z^{\\prime}_1 \\newline \\vdots \\newline z^{\\prime}_n \\end{bmatrix} \\equiv \\begin{bmatrix} z_1 + z^{\\prime}_1 \\newline \\vdots \\newline z_n + z^{\\prime}_n \\end{bmatrix} \\end{equation*}\n関連ノート  スカラー倍演算  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330134827-%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "演算子",
                "section": "post",
                "date" : "2021.03.30",
                "body": "量子論では、ベクトル空間 \\(V\\) と \\(W\\) の間の線形な関数 \\(A: V \\rightarrow W\\) を演算子またはオペレータ (operator) と呼び、次のように定義する。\n\\[A\\left(\\sum_i a_i\\ket{v_i}\\right) = \\sum_i a_i A(\\ket{v_i})\\]\n演算子と行列は等価なので、通常は \\(A(\\ket{v})\\) を \\(A\\ket{v}\\) とカッコを省略して書く。\nちなみに、数学の分野では同じ用語 operator を作用素と訳すので注意。\n関連ノート  恒等演算子 零演算子  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210224132528-doom_emacs/",
                "title": "Doom Emacs",
                "section": "post",
                "date" : "2021.03.29",
                "body": "Emacs の設定フレームワークの一種。その他の設定フレームワークとしては Spacemacs などもあるが、Doom Emacs はパッケージの安定度が高く、起動が早いという特長がある。\n関連ノート  Effective Emacs  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210324153839-effective_emacs/",
                "title": "Effective Emacs",
                "section": "post",
                "date" : "2021.03.29",
                "body": "https://sites.google.com/site/steveyegge2/effective-emacs\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210327132024-emacs/",
                "title": "Emacs",
                "section": "post",
                "date" : "2021.03.29",
                "body": "私が大学以来メインで使っているエディタ。\nEmacs に関連して主に使っているツールはこちら::\n Doom Emacs 設定フレームワーク Org Mode 設定ファイルを文芸的プログラミングぽく書くのに使用 Org-Roam 普段のメモやノート全般を書くのに使用。このデジタル・ガーデンは Org-Roam から Hugo に変換している  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210329095350-org_transclusion/",
                "title": "org-transclusion",
                "section": "post",
                "date" : "2021.03.29",
                "body": "Org Mode で Roam Research 的なブロック参照を行うためのパッケージ。\nOrg-Roam で書いたノートの一部を、他のノートや Doom Emacs の config.org から参照したくなったので導入。\n設定 ~/.doom.d/packages.el の設定\n(package! org-transclusion :recipe (:host github :repo \u0026#34;nobiot/org-transclusion\u0026#34; :branch \u0026#34;main\u0026#34;)) ~/.doom.d/config.el の設定\n(use-package! org-transclusion :hook (org-roam-mode . org-transclusion-mode)) リンク  nobiot/org-transclusion  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210329114625-%E3%82%A8%E3%83%AB%E3%83%9F%E3%83%BC%E3%83%88%E5%85%B1%E5%BD%B9/",
                "title": "エルミート共役",
                "section": "post",
                "date" : "2021.03.29",
                "body": "転置共役の別名。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210329140322-%E3%82%A8%E3%83%AB%E3%83%9F%E3%83%BC%E3%83%88%E8%A1%8C%E5%88%97/",
                "title": "エルミート行列",
                "section": "post",
                "date" : "2021.03.29",
                "body": "複素行列 \\(A\\) とそのエルミート共役 \\(A^{\\dagger}\\) について \\(A^{\\dagger} = A\\) を満たすとき、行列 \\(A\\) をエルミート行列と呼ぶ。\nその性質からエルミート行列の対角成分は実数であり、かつ、対角線に関して対称な位置にある成分は互いに共役な複素数となる。\n2 次のエルミート行列の例\n\\[A = \\begin{bmatrix} 3 \u0026amp; 1 + i \\\\\\\n1 -i \u0026amp; -2 \\end{bmatrix}\\]\n3 次のエルミート行列の例\n\\[A = \\begin{bmatrix} 1 \u0026amp; i \u0026amp; 2-i \\\\\\\n-i \u0026amp; 2 \u0026amp; -3i \\\\\\\n2+i \u0026amp; 3i \u0026amp; -1 \\end{bmatrix}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210329160516-%E5%85%B1%E5%BD%B9/",
                "title": "共役",
                "section": "post",
                "date" : "2021.03.29",
                "body": "2 つのものがセットになって結びついていること、同様の働きをすること。もともと共軛と書き、「軛」(くびき) は、人力車や馬車において 2 本の梶棒 (かじぼう) を結びつけて同時に動かすようにするための棒のこと。\n数学では、二つの角・線・点・図形・数などが互いに対称的あるいは相補的関係にあり、入れ換えてもその関係に変化のないこと。\n「軛」が常用漢字表外であったため、音読みの同じ「役」の字で代用され、現在では共役と書かれることが多い。\n    関連ノート  エルミート共役  Source  共役 (Weblio) 共役 (Wikipedia) 人力車の各パーツの呼び方知ってる？  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210329133439-%E9%96%93%E9%9A%94%E5%8F%8D%E5%BE%A9%E8%A8%98%E6%86%B6%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/",
                "title": "間隔反復記憶システム",
                "section": "post",
                "date" : "2021.03.29",
                "body": "実装  Supermemo Anki Mnemosyne Execute Program  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210223202810-anki_editor/",
                "title": "anki-editor",
                "section": "post",
                "date" : "2021.03.27",
                "body": "Org Mode や Org-Roam で書いたノートから Anki カードを生成するためのパッケージ。\n参考  louietan/anki-editor  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210327120037-deft/",
                "title": "Deft",
                "section": "post",
                "date" : "2021.03.27",
                "body": "https://github.com/jrblevin/deft\nEmacs を Notational Velocity 的に使うためのパッケージ。Org Mode や Org-Roam のノート一覧をファイル内容も含めてインクリメンタルサーチできるのが便利。ただし SKK が使えないので日本語が使えない。なんとかしたいところ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210224155908-qni/",
                "title": "Qni",
                "section": "post",
                "date" : "2021.03.27",
                "body": "ブラウザ上で動く量子回路シミュレータ。初心者が量子コンピュータをライブプログラミングで直感的に学べる環境を目指している。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210310110827-%E5%9C%8F%E8%AB%96%E7%9A%84%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E5%85%A5%E9%96%80/",
                "title": "圏論的量子力学入門",
                "section": "post",
                "date" : "2021.03.27",
                "body": "https://www.morikita.co.jp/books/book/3316\n関連ノート  量子コンピュータ 図式的線形代数  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323114201-assoc/",
                "title": "Assoc",
                "section": "post",
                "date" : "2021.03.23",
                "body": "Assoc は Associativity (結合性) の略。図式的線形代数では足し算を扱うので、単に Assoc と書いた場合それは足し算の結合性を表す。\n図式で足し算の結合性を表すと次のようになる。\n  これが正しいことは、変数 \\(x\\), \\(y\\), \\(z\\) を使うことで次のように示せる。\nAssoc の左辺に \\(x\\), \\(y\\), \\(z\\) を入力すると、\n  Assoc の右辺に \\(x\\), \\(y\\), \\(z\\) を入力すると、\n  ここで足し算の結合性より \\((x + y) + z = x + (y + z)\\) だから、\n  が成り立つ。\n参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323094041-identity/",
                "title": "Identity",
                "section": "post",
                "date" : "2021.03.23",
                "body": "図式的線形代数で一本の結線をアイデンティティ (identity) と呼ぶ。\n  入力は 1 つ、出力も同じく 1 つなので \\((1, 1)\\) である。\n参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323095806-twist/",
                "title": "Twist",
                "section": "post",
                "date" : "2021.03.23",
                "body": "図式的線形代数で交差する二本の結線をツイスト (twist) と呼ぶ。\n  入力は 2 つ、出力も同じく 2 つなので \\((2, 2)\\) である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323090747-unit/",
                "title": "Unit",
                "section": "post",
                "date" : "2021.03.23",
                "body": "ゼロジェネレータ (Zero) の振舞いから、図式的線形代数における次の単位元 (identity element) 方程式に辿り着く。右辺は Identity。\n  なぜこうなるかは、次のようにワイヤに 0 と変数を振ってみれば分かりやすい。\n  参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323084442-zero/",
                "title": "Zero",
                "section": "post",
                "date" : "2021.03.23",
                "body": "ゼロは加法の単位元。語源は、位取り筆算をヨーロッパに紹介したフィボナッチがゼロを zephryum と呼んだことに由来する。\nゼロを図式的線形代数で表すと、次のジェネレータになる。\n  参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323110948-%E5%9B%B3%E5%BC%8F%E3%81%AE%E5%90%88%E6%88%90/",
                "title": "図式の合成",
                "section": "post",
                "date" : "2021.03.23",
                "body": "図式の合成では、次のように第 1 引数の右に第 2 引数を置いて結線同士をつなげる:\n  合成のルールを式で書くと次の通り:\n  参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323102643-%E5%9B%B3%E5%BC%8F%E3%81%AE%E7%9B%B4%E5%92%8C/",
                "title": "図式の直和",
                "section": "post",
                "date" : "2021.03.23",
                "body": "図式の直和では、次のように第 1 引数を第 2 引数の上に重ねる:\n  直和のルールを式で書くと次の通り:\n  下の Identity を曲げているが、これは曲げても曲げなくても良い。図式の重要な情報はルールからも明らかなように、\n 左から右に向かって何が何につながっているか 上から下に向かってどの順番でジェネレータが並んでいるか  なので、それを変えなければ結線を曲げても良い。\nもちろん、直和は可換でないことに注意。\n  参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210322140545-comm/",
                "title": "Comm",
                "section": "post",
                "date" : "2021.03.22",
                "body": "Comm は Commutativity (可換性) の略。図式的線形代数では足し算を扱うので、単に Comm と書いた場合それは足し算の可換性を表す。\n図式で足し算の可換性を表すと次のようになる。\n  これが正しいことは、変数 \\(x\\), \\(y\\) を使うことで次のように示せる。\nComm の左辺に \\(x\\) と \\(y\\) を入力すると、\n  Comm の右辺に \\(x\\) と \\(y\\) を入力すると、\n  ここで足し算の可換性より \\(x + y = y + x\\) だから、\n  が成り立つ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210322104014-%E5%9B%B3%E5%BC%8F%E7%9A%84%E7%B7%9A%E5%BD%A2%E4%BB%A3%E6%95%B0/",
                "title": "図式的線形代数",
                "section": "post",
                "date" : "2021.03.22",
                "body": "グラフィカル (図式的) に線形代数を計算する方法を説明したブログ。\nhttps://graphicallinearalgebra.net/\n ジェネレータ  Identity Twist Zero   方程式  Comm Assoc   演算  図式の直和 図式の合成    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210320155430-void/",
                "title": "void",
                "section": "post",
                "date" : "2021.03.20",
                "body": "return 文を含まない関数の戻り値の型はなんでしょうか?\nTypeScript では、そういう関数の戻り値の型は void です。あえて型エラーを起こしてエラーメッセージを見ればわかります。\nfunction f() { } const n: number = f(); // → type error: Type \u0026#39;void\u0026#39; is not assignable to type \u0026#39;number\u0026#39;. void の使いみちは、明示的に何も返さない関数を表現したい場合です。たとえば console.log はその一例です。\nvoid 型は、値を一切持たないことを示します。他の多くの静的言語では、例外はなく、 void は本当に値を持つことはできません。しかし、TypeScript では不思議なことに、 void 型の変数を作ることができます。この変数には undefined という値しか入りません。\nconst aVoid: void = undefined; // → undefined だからといって、その void を undefined 型の変数に代入できるわけではありません。 void は何にも代入できないので、型エラーになります。\nconst aVoid: void = undefined; const u: undefined = aVoid; // → type error: Type \u0026#39;void\u0026#39; is not assignable to type \u0026#39;undefined\u0026#39;. 実際には、 void 型の変数に出会うことはないでしょう。しかし、多くの void 関数を目にすることになるでしょう。なぜなら、戻り値のない関数は自動的に void と推論されるからです。\n参考  void (Execute Program)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210320161559-%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF%E5%AD%A6%E7%BF%92%E3%81%AE_srs_%E5%8C%96/",
                "title": "プログラミング学習の SRS 化",
                "section": "post",
                "date" : "2021.03.20",
                "body": "SRS の回答方式による効果の違いを確認するために、Execute Program を参考にいくつかレッスンを作り、Anki カードを起こしてみる。\n  void never  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210319115727-anki/",
                "title": "Anki",
                "section": "post",
                "date" : "2021.03.19",
                "body": "人気の間隔反復記憶システムのひとつ。オープンソースとして開発されており、ソースコードは ankitects/anki から取得できる。\nリンク  ホームページ https://apps.ankiweb.net/ ドキュメント https://docs.ankiweb.net/ 共有デッキ https://ankiweb.net/shared/decks/  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210319132742-duolingo/",
                "title": "Duolingo",
                "section": "post",
                "date" : "2021.03.19",
                "body": "https://en.duolingo.com/\n世界で最も人気のある外国語学習サービス。単語や文法の学習に SRS を採用している。\nSRS として見たときの Duolingo のユニークな点 (たとえばExecute Program との違い) は、すべての学習がカードのみで完結しているところ。Execute Program ではプログラミング言語の解説を読みながらクイズに答えていく。一方で Duolingo では外国語に対する知識ゼロの状態からいきなりクイズが始まり、正解/不正解を繰り返しながら (試行錯誤を繰り返しながら) 外国語を学んでいくことができる。\n外国語学習の場合、文法や単語の説明を読むのはダルい/集中力が続かないという人が圧倒的に多いはずなので、正式な学習法と比べてどのくらい効果があるかどうかは分からないが、ひとつの妥当なデザインチョイスだと思う。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210319113717-srs_%E3%81%AE%E5%9B%9E%E7%AD%94%E6%96%B9%E5%BC%8F%E3%81%AB%E3%82%88%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%AE%E9%81%95%E3%81%84/",
                "title": "SRS の回答方式による効果の違い",
                "section": "post",
                "date" : "2021.03.19",
                "body": "SRS のユーザ回答方式には、Anki のようにユーザが裏面を見て自分で答合わせをする方式と、Duolingo や Execute Program のようにユーザが入力した答をシステムが答合わせする方式の 2 つがある。どちらが記憶効果が高いだろうか？\nこの論文 (Probabilistic Models of Student Learning and Forgetting) では実験から次のことを導き出している:\n ひとつひとつの単体のレビューの効果については、ユーザが入力する方式の方が効果が高い 長期的な効果については、入力のためのタイピングにはかなり時間がかかるため、自分で答合わせをする方式のほうがレビューを多くこなせ、結果的に効果が高くなる  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210318110047-never/",
                "title": "never",
                "section": "post",
                "date" : "2021.03.18",
                "body": "関数の中には、決して戻らないものがあります。例えば、常に例外を投げる関数は決して戻りません。\n// この関数は戻らない function throws() { throw new Error(\u0026#39;oh no\u0026#39;); } この関数の戻り値の型はどうすればよいでしょうか？ TypeScript は、この関数の戻り値の型を void と推論します。しかし、それではコードで何が起こっているのかをコンパイラは完全には把握できていません。\nvoid 型は、何らかの処理を行い終了するが、値を返さない関数のための型です。上の関数はこれとは異なり、この関数を呼び出しても、その後のコードは全く実行されません。\n幸いなことに、TypeScript にはそのための型があります: never です。\n// 戻らない関数の返り値は never と指定する function throws(): never { throw new Error(\u0026#39;oh no\u0026#39;); } never 型はちょっと不思議です。他のどの型にも割り当て可能です1。例えば、 number 型の変数に割り当てることができます (ただし、実行すると例外が投げられます)。\nfunction throws(): never { throw new Error(\u0026#39;oh no\u0026#39;); } // never はどんな型にも割り当てられる const n: number = throws(); // → Error: oh no 最初は、 never が any のように振る舞っているように見えます。なぜなら、 never を number （または string 、その他何でも）に割り当てることができるからです。しかし、 any と違って、これは安全です。\nコンパイラは throws 関数が決して戻らないことを知っているので、変数 n には何も代入されないことも知っています。型は実行時にデータが正しいことを保証するために存在します。もし、実行時に代入が実際に行われることがなく、コンパイラが事前にそのことを確実に知っているのであれば、 never を代入する変数の型は重要ではありません。\nしかし、 never に他の型を割り当てることはできません。そうすると、 never のルールである「実際に値を保持することはない」を破ってしまいます。 never に何らかの値を代入しようとすると、常に型エラーになります。\n// never には何も割り当てられない const aNever: never = 5; // → type error: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;never\u0026#39;. 絶対に never には何も割り当てられません。 any ですらも!\nconst anAny: any = 5; // never には any ですら割り当てられない const aNever: never = anAny; // → type error: Type \u0026#39;any\u0026#39; is not assignable to type \u0026#39;never\u0026#39;. 関数が常に例外をスローするが、明示的な戻り値の型を持たない場合、TypeScript は戻り値の型を void と推論します。これは悪いことではありませんが、明示的に never とマークしたほうが、TypeScript にもう少し多くの情報を与えることができます。\n例えば、ある関数が never を返す別の関数を呼び出したとします。TypeScript は外側の関数の型も never と正しく推論します。\nfunction throws(): never { throw new Error(\u0026#39;oh no\u0026#39;); } // この戻り値の型は never と推論される function alsoThrows() { return throws(); } // never は number に割り当てることができる const n: number = alsoThrows(); このコードがコンパイルされたことで、 alsoThrows の戻り値の型が never であることがわかりました。もし戻り値の型が void であれば、数値に割り当てることはできません。\n次の関数の戻り値の型を never に変更するとどうなるでしょうか。結果は型エラーが発生します。なぜなら、この関数は戻るからです。TypeScript は never 関数が値を返すことを許可しません。\nfunction f(): number { return 5; } 戻り値を never に変更すると:\nfunction f(): never { return 5; } // → type error: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;never\u0026#39;. TypeScript では、 never 関数が条件付きで戻ることもできません（例: if の中）。関数が値を返す方法があるならば、その戻り値の型は never であってはならないのです。(この関数は型エラーを発生させます)\nfunction forcePositive(x: number): never { if (x \u0026gt; 0) { // 型エラー  return x; } else { throw new Error(\u0026#39;Number was negative!\u0026#39;); } } // → type error: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;never\u0026#39;. never 型が適用されるのは、例外を発生させる関数だけではありません。例えば、無限ループを持つ関数は、 never 型の戻り値を持つことができます（そうすべきです！）。\n残念ながら、ここではその動く実例を示すことはできません。なぜなら、それは決して終了しないからです。しかし、その逆の例を示すことはできます。つまり、無限ループのように見える関数で、絶対に終わらないと主張していますが、時々戻ってくることがあるようなものです。これは型エラーです。\nfunction f(): never { while (true) { // 型エラー  if (Math.random() \u0026lt; 0.000001) { break; } } } // → type error: A function returning \u0026#39;never\u0026#39; cannot have a reachable end point. never 型の代表的なユースケースとして網羅性チェックがあります。到達不能な部分で never を返す関数を呼び出すことで、実行時エラーをチェックできます。\nfunction fail(message: string): never { throw new Error(message); } function foo(x: string | number): boolean { if (typeof x === \u0026#34;string\u0026#34;) { return true; } else if (typeof x === \u0026#34;number\u0026#34;) { return false; } // never 型のない言語では、次のいずれかでエラーになる  // - すべてのコードパスで値を返していない (厳密な null チェック)  // - または、到達不能コードの検出  // しかし TypeScript は fail 関数が never を返すことを知っているので、  // プログラマは実行時の安全性/網羅性チェックのために fail を呼び出すことができる  return fail(\u0026#34;Unexhaustive!\u0026#34;); } 最後に、 void と never について簡単にまとめておきます。\nvoid は、関数が最終的に終了して戻ることを意味します。単に、何の値も返さないということです。関数には return 文がないか、または return 文の後に値がない状態になっています。 void 型は、値がないことを表すので、何にも代入できません。\nnever は、関数が決して正常に終了しないことを意味します。例外が発生したり、無限ループに陥ったりするかもしれません。Node のようなサーバーサイドのシステムであれば、 process.exit() を呼び出してプロセスを終了させるかもしれません。いずれにしても、実行が関数の最後に到達することはありません。 never 型は何にでも代入可能です。なぜならコンパイラは、実行時には実際には代入が行われないことを知っているからです。\n参考  never (Execute Program)    never はすべての型のサブタイプ (派生型) であり、これをボトム型 (bottom type) と呼ぶ。つまり、他のすべての型に割り当てることができ、 never 型の値はどこでも安全に使えるという意味である。理論的な意味としては、ボトム型は値を持たない型としてとらえることができ、常に偽である数学的命題に相当する。 \u0026#x21a9;\u0026#xfe0e;\n   "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210318171123-%E3%83%86%E3%82%B7%E3%82%BF%E3%83%AB_%E3%82%AB%E3%83%BC%E3%83%86%E3%83%B3/",
                "title": "デジタル・ガーデン",
                "section": "post",
                "date" : "2021.03.18",
                "body": "個人的なメモをインターネット上に公開したもの。多くの場合はメモ間にリンクが貼ってあり、Wiki のように関連するメモを読むことができる。\n一般的な作り方としては、Roam Research や Obsidian といった個人用のメモツールで書いたメモを外部ツールでインターネット上に公開する場合が多い。\n MaggieAppleton/digital-gardeners デジタル・ガーデン用ツール、作りかたチュートリアル、各種ノート法などの基礎知識、個別のデジタル・ガーデンサイトへのリンク集 Andyʼs working notes デジタル・ガーデン流行の火付け役となったサイトであり、多くの人がお手本にしている Andy Matuschak のサイト 効率的なノートを作成できるドイツの社会学者が生み出した方法「Zettelkasten」とは？ ノート法の一種で、多くのデジタル・ガーデンはこの方法に則って書かれている  関連ノート  保存版メモの数  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210317113230-%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC%E8%A1%8C%E5%88%97/",
                "title": "スカラー行列",
                "section": "post",
                "date" : "2021.03.17",
                "body": "単位行列の定数倍をスカラー行列という。\nたとえば、\n\\[\\begin{bmatrix} \\lambda \u0026amp; 0 \u0026amp; 0 \\\\\\\n0 \u0026amp; \\lambda \u0026amp; 0 \\\\\\\n0 \u0026amp; 0 \u0026amp; \\lambda \\end{bmatrix}\\]\nはスカラー行列である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210317101558-%E5%AF%BE%E8%A7%92%E8%A1%8C%E5%88%97/",
                "title": "対角行列",
                "section": "post",
                "date" : "2021.03.17",
                "body": "\\(n\\) 次正方行列で、その対角線上にない成分がすべて \\(0\\) である行列のこと。\n\\[\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\\\\n0 \u0026amp; 2 \u0026amp; 0 \\\\\\\n0 \u0026amp; 0 \u0026amp; -1 \\end{bmatrix}\\]\n注意点として、行列の対角線は右下がりのもののみを言う。右上がりのものは対角線とは呼ばない。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210317105154-%E6%AD%A3%E6%96%B9%E8%A1%8C%E5%88%97/",
                "title": "正方行列",
                "section": "post",
                "date" : "2021.03.17",
                "body": "\\(m \\times m\\) 行列は正方形状に成分が並ぶので \\(m\\) 次正方行列と呼ぶ。\n\\(2\\) 次正方行列の例\n\\[\\begin{bmatrix} 1 \u0026amp; 2 \\\\\\\n2 \u0026amp; -1 \\end{bmatrix}\\]\n\\(3\\) 次正方行列の例\n\\[\\begin{bmatrix} -1 \u0026amp; 2 \u0026amp; 3 \\\\\\\n1 \u0026amp; 1 \u0026amp; 0 \\\\\\\n2 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210311082809-%E3%83%86%E3%82%A3%E3%83%A9%E3%83%83%E3%82%AF%E8%A8%98%E6%B3%95/",
                "title": "ディラック記法",
                "section": "post",
                "date" : "2021.03.11",
                "body": "ディラック記法は、物理学者ポール・ディラックがとくに量子論を記述する目的で導入した記法。量子論のほとんどの教科書で今日でも使われている。\n   名前 記号     ディラックのケット (ket) \\(\\ket{\\psi}\\)   ディラックのブラ (bra) \\(\\bra{\\pi}\\)   ディラックのブラケット (braket) \\(\\langle\\pi\\vert{}\\psi\\rangle\\)    Quantum Computation and Quantum Information によると、量子力学の難しさの原因はそれ自体が難しいというわけではなく、ディラック記法をはじめ物理学特有の記号がたくさんあることにあるようだ。\n 量子力学の公理の理解を阻む主な要因は公理それ自体にあるのではなく、それを理解するのに必要な線形代数の表記法の多さにある。物理学者が量子力学に用いている見慣れない Dirac の表記法と相まって、それは (間違って) とても恐ろしい印象を与える。\n 量子力学で使う標準的な記号のまとめ    記号 意味     \\(z^{\\ast}\\) 複素数 \\(z\\) の複素共役。\\((1 + i)^{\\ast} = 1 - i\\)   \\(\\vert{}\\psi\\rangle\\) ベクトル。ケット (ket) とも呼ばれる。   \\(\\langle\\psi\\vert{}\\) \\(\\vert{}\\psi\\rangle\\) に双対 (dual) なベクトル。ブラ (bra) とも呼ばれる   \\(\\langle\\varphi\\vert{}\\psi\\rangle\\) \\(\\vert{}\\varphi\\rangle\\) と \\(\\vert{}\\psi\\rangle\\) の内積   \\(\\vert{}\\varphi\\rangle \\otimes \\vert{}\\psi\\rangle\\) \\(\\vert{}\\varphi\\rangle\\) と \\(\\vert{}\\psi\\rangle\\) のテンソル積   \\(\\vert{}\\varphi\\rangle\\vert{}\\psi\\rangle\\) \\(\\vert{}\\varphi\\rangle\\) と \\(\\vert{}\\psi\\rangle\\) のテンソル積に対する簡略記号   \\(A^{\\ast}\\) 行列 \\(A\\) の複素共役   \\(A^T\\) 行列 \\(A\\) の転置   \\(A^{\\dagger}\\) 行列 \\(A\\) のエルミート共役   \\(\\langle\\varphi\\vert{}A\\vert{}\\psi\\rangle\\) \\(\\vert{}\\varphi\\rangle\\) と \\(A\\vert{}\\psi\\rangle\\) の内積。\\(A^{\\dagger}\\vert{}\\varphi\\rangle\\) と \\(\\vert{}\\psi\\rangle\\) の内積に等しい。    参考文献  P. A. M. Dirac (1939). A new notation for quantum mechanics. Mathematical Proceedings of the Cambridge Philosophical Society, 35, pp 416-418  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210223135036-org_mode/",
                "title": "Org Mode",
                "section": "post",
                "date" : "2021.03.10",
                "body": "メモや論文など書くこと全般に使える Emacs のメジャーモード。Org-Roam を使うと、Roam Research 的なスマートノートを作ることができる。このノート上には Anki のカードも定義できるので、スマートノートと SRS をスムーズに組み合わせることができる。そのほか、文芸的プログラミングをサポートしているので、Emacs の設定ファイルを Org のドキュメントから生成できる。\nOrg mode for Emacs\nOrg のインライン記法  強調 **強調** 斜体 /斜体/ 下線 _下線_ 打ち消し +打ち消し+ verbatim =verbatim= inline code ~inline code~  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210310093010-%E6%96%87%E8%8A%B8%E7%9A%84%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF/",
                "title": "文芸的プログラミング",
                "section": "post",
                "date" : "2021.03.10",
                "body": "Donald E. Knuth が提唱したプログラミング手法の一つで、テキストファイル内にドキュメントとコードを埋めこみ、これから完全なドキュメントとコンパイル可能なソースコードを生成する方法。驚くことに TeX はこの方法で書かれていて、生成されたドキュメントは本として出版されている (TeX: The Program)。\nTeX 以外に実用的なソフトウェアで文芸的プログラミングを採用した例は見当たらないが、最近では Org ファイルから Emacs や Bash などの設定ドキュメントとドットファイルを生成するという限定的な用途で文芸的プログラミングが使われている。\n極端な例では、Org-Mode 内で論文を書く際に、本文だけでなくテーブルやグラフなど論文の構成要素をすべて生成するという Reproducible Research という手法もある。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210228111127-how_to_take_smart_notes/",
                "title": "How to Take Smart Notes",
                "section": "post",
                "date" : "2021.03.03",
                "body": " How to Take Smart Notes (Scribd) How to Take Smart Notes (Amazon)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210303105204-powers_of_10_time_scales_in_user_experience/",
                "title": "Powers of 10: Time Scales in User Experience",
                "section": "post",
                "date" : "2021.03.03",
                "body": "Powers of 10: Time Scales in User Experience\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210303082924-%E3%81%99%E3%81%B8%E3%81%A6%E3%81%AE%E7%9F%A5%E7%9A%84%E5%8A%AA%E5%8A%9B%E3%81%AF%E3%83%A1%E3%83%A2%E3%81%8B%E3%82%89/",
                "title": "すべての知的努力はメモから",
                "section": "post",
                "date" : "2021.03.03",
                "body": "学習、勉強、研究、小説などあらゆる種類の知的活動や創作は、すべてメモを取ることから始まる。書くことについての話題となると、論文や小説といった「書きかけの作品」をいかに完成させるかという議論になりやすい。しかし、これらは「書く」という活動から見ればどれも例外的な瞬間にすぎない。書くことの大部分を占めるのは日常的なメモ書きであり、論文や小説などといった長い作品はメモを書く作業の積み重ねによって生まれる。\n文章を書くプロセスは、真っ白な画面よりもはるかに早い段階から始まっていて、実際に議論を書き留めることは、全体のプロセスの中では最小の部分である。\n参考文献  How to Take Smart Notes  関連ノート  保存版メモの数  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210303103710-%E7%9B%B4%E6%84%9F%E6%80%A7%E3%81%A8%E5%BF%9C%E7%AD%94%E6%99%82%E9%96%93/",
                "title": "直感性と応答時間",
                "section": "post",
                "date" : "2021.03.03",
                "body": "ライブプログラミング環境の直感性は、応答時間に大きく依存する。ユーザビリティ研究で有名な Jakob Nielsen の記事 \u0026ldquo;Powers of 10: Time Scales in User Experience\u0026rdquo; によると、ユーザーが何かを操作してから結果が返るまでの応答時間と、ユーザが感じる直感性の関係には、次の一般的な指標がある。\n 応答時間 0.1 秒未満 操作が直感的だと感じる。ユーザは自分の行動が直接画面上で何かを引き起したという「直接操作」という錯覚を感じ、操作に集中できる。 応答時間 0.1 〜 1 秒 直感性がやや失われる。ユーザはコンピュータ側で何らかの処理が発生していることに気付き、処理を待つ間に集中力を失いはじめる。 応答時間 1 秒以上 直感性がなくなる。ユーザは反応が遅すぎると感じ、操作をためらうようになる。また、目の前の問題への集中力を完全に失う。  つまり直感性のためには、0.1 秒以内の応答時間を達成する必要がある。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210303084450-%E7%9C%9F%E3%81%A3%E7%99%BD%E3%81%AA%E7%94%BB%E9%9D%A2/",
                "title": "真っ白な画面",
                "section": "post",
                "date" : "2021.03.03",
                "body": "論文や小説などを書くときには何もないところから始めるという誤った考えかた。ほとんどの文章指南本や自己啓発本はこれを前提にしており、締切の間に合わせかたやその他心理的テクニックなどに終始している (やる気の出しかた、締切との向き合いかた etc.)。そうではなく、すべての知的努力はメモから始まることを理解していて、普段からスマートメモを取っていれば、そもそも真っ白な画面にぶつかることはない。\n参考文献  How to Take Smart Notes  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210303094727-%E9%87%8F%E5%AD%90%E3%82%B3%E3%83%B3%E3%83%92%E3%83%A5%E3%83%BC%E3%82%BF/",
                "title": "量子コンピュータ",
                "section": "post",
                "date" : "2021.03.03",
                "body": "量子コンピュータは量子力学に基いた新しいタイプのコンピュータである。線形重ね合わせのできる量子ビットを量子ゲートで操作し、量子ビットを測定することで計算結果が得られる。特定の問題について従来のコンピュータより高速に計算できることが知られており、実際、フーリエ変換、素因数分解、データ探索、位相推定をはじめとした量子コンピュータ向けのアルゴリズムが多数存在する (Quantum Algorithm Zoo)。\nこうした線形重ね合わせや測定は量子コンピュータ特有の操作であり，従来の開発者にとっては直感的でないという問題がある．そのため，試行錯誤を容易に行える直感的な量子プログラミング環境の構築が重要である。\n参考文献  Quantum Computation and Quantum Information Thinking Too Classically: Research Topics in Human-Quantum Computer Interaction  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302131638-andy_matuschak/",
                "title": "Andy Matuschak",
                "section": "post",
                "date" : "2021.03.02",
                "body": "Andyʼs working notes\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302115454-api_%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%88%E3%83%AB/",
                "title": "API としてのタイトル",
                "section": "post",
                "date" : "2021.03.02",
                "body": "エバーグリーンノートのタイトル付けは API 設計によく似ている。\n 単機能にする (例: Object#inspect) キャッチーな名詞にする (例: \u0026ldquo;囚人のジレンマ\u0026rdquo;、\u0026ldquo;割れ窓理論\u0026rdquo;) 一発で決まらない時は、時間とともに改善 (リファクタリング)  参考文献  Evergreen note titles are like APIs  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302122859-bret_victor/",
                "title": "Bret Victor",
                "section": "post",
                "date" : "2021.03.02",
                "body": " 本人のサイト  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302155222-execute_program/",
                "title": "Execute Program",
                "section": "post",
                "date" : "2021.03.02",
                "body": "https://www.executeprogram.com/\n間隔反復記憶システム (SRMS) で JavaScript などの API を学習できるサービス。SRMS が外国語学習だけでなく API の習得にも有効なのは、Michael Nielsen の Augmenting Long-term Memory でも実証されていることである。\nビジネス的には、SRMS は長期 (数年〜) に渡って使うものなので、こういうサービスは個人利用であっても契約期間が長くなる → 収益化しやすい、と予想できる。\n使ってみた感想として、回答では必ずキー入力を求められるので、Anki のようにサクサク進められず、レビューセッションを始める前の心理的バリアが少し高いと感じた。キー入力が必要な要因として、問題と回答がアトミックな質問と答になっていないことが考えられる。\nキー入力を使わない SRMS でプログラミング API を習得することは可能だろうか？ Execute Program の問題を SRMS に起こし、自分を実験台にして確認してみる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302123555-%E3%82%A2%E3%83%88%E3%83%9F%E3%83%83%E3%82%AF%E3%81%AA%E8%B3%AA%E5%95%8F%E3%81%A8%E7%AD%94/",
                "title": "アトミックな質問と答",
                "section": "post",
                "date" : "2021.03.02",
                "body": "Anki のカードを作るときは、問題と答がたった一つの概念を表すようになるまで、つまりそれ以上分けられない単位 (=アトミック) まで分解する。\nたとえば次の Anki カードがあった場合、\n 問題: Unix でリンク名からファイル名へのソフトリンクを作るには? 答: ln -s ファイル名 リンク名  これは次の 2 つのカードに分割できる:\n  問題: Unix ソフトリンクを作るための基本的コマンドとオプションは?\n  答: ln -s\n  問題: Unix ソフトリンクを作る時、リンク名とファイル名を指定する順番は?\n  答: ファイル名 リンク名\n  このようにすると、覚えやすくなり正解率も上がる。答も短くなるため、レビューがテンポ良く進むという利点もある。\nもし間違えた場合でも、ミスをした箇所は明らかなため次からは間違えにくい。一方で、2 つ以上の要素が入ったアトミックでない問題で間違えた場合、ミスをした箇所がはっきりしないため、何度も間違えることが多い。\n日常的に問題をアトミックに分割する癖を付けておくことは、学んだ事柄ひとつひとつを鋭く結晶化してくれる。手間はかかるが、それだけの価値はある。\n注: アトミックな問題に分割した時、元のカードも取っておいたほうが良い。一つ上のレベルの問題として使える場合があるから。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302115056-%E3%82%A2%E3%83%88%E3%83%9F%E3%83%83%E3%82%AF_%E3%82%BF%E3%82%A4%E3%83%88%E3%83%AB/",
                "title": "アトミック・タイトル",
                "section": "post",
                "date" : "2021.03.02",
                "body": "エバーグリーンノートのタイトルは、それ以上分割できない概念を名詞で表したもの (例: \u0026ldquo;囚人のジレンマ\u0026rdquo;、\u0026ldquo;割れ窓理論\u0026rdquo; etc.) にする。\nこれをアトミック・タイトルと呼ぶ。アトミック・タイトルはノート内からリンクを貼りやすく、覚えやすい。また一言で言えるので、複雑な概念を表す \u0026ldquo;ハンドル\u0026rdquo; として便利 (API としてのタイトル)。\nタイトルがアトミック・タイトルかどうかは、少ない語の名詞になっているかどうかが良い判断基準になると思う。\n参考文献  Evergreen notes should be atomic  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302120815-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%BC%E8%A1%8C%E5%88%97/",
                "title": "ユニタリー行列",
                "section": "post",
                "date" : "2021.03.02",
                "body": "\\(U^{\\dagger}U = I\\) ならば行列 \\(U\\) はユニタリーであるという。\n古典コンピュータでは単一ビットゲートは NOT ゲート 1 つしかなかったが、量子コンピュータではユニタリー性を満たす行列はすべて量子ゲートとなることができる。そして、ユニタリー行列であることが量子ゲートに対する唯一の制約である。\n参照  Quantum Computation and Quantum Information  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302145631-%E3%83%A9%E3%82%A4%E3%83%86%E3%82%A3%E3%83%B3%E3%82%AF_%E3%82%A4%E3%83%B3%E3%83%9B%E3%83%83%E3%82%AF%E3%82%B9/",
                "title": "ライティング・インボックス",
                "section": "post",
                "date" : "2021.03.02",
                "body": "保存版メモの作業場所としてライティング・インボックスを持っておく。一時的なメモや書きかけのメモは何でも、このインボックスにつっこむ。書きかけがすべてが入っているので、ライティング・インボックスは今までの洞察を蓄積した容れ物だと考えることができる。\nこのインボックスを漁ることで、次にとりかかるメモを決め、いつでも続きを書きはじめることができる。インボックスの中で保存版メモを仕上げ、アトミック・タイトルをつけ保存版メモとして保存する。つまらないメモはアーカイブする。\nOrg-Mode での実装 現在は、TODO アイテムに writing タグを付けることでライティング・インボックスを実装している。 練りあげてできあがった保存版メモは、Org-Roam の独立したノートを作ってそこに保存する。\n参考文献  My morning writing practice by Andy Matuschak  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302122628-%E3%83%A9%E3%82%A4%E3%83%95%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF/",
                "title": "ライブプログラミング",
                "section": "post",
                "date" : "2021.03.02",
                "body": "ライブプログラミングとは、プログラムの実行時の情報を参照しながらコーディングできるようにするインタラクションデザインの一種。\n従来の開発環境では、プログラマはソースコード (死んだ状態) を編集しながら実行時 (生きた状態) を頭の中でエミュレーションする必要があった。一方ライブプログラミングでは、開発環境が提示する生きたプログラムの状態を確認しながらソースコードを直感的に編集できる。\nライブプログラミング環境は、頭の中だけでは想像しにくい、抽象的な記号操作をメインとするシステムの理解や開発に有効である。\n Bret Victor らの Interactive Exploration of a Dynamic System では、微分方程式の初期値やパラメータを変えながら結果をインタラクティブに確認できる。 機械学習分野でユーザの多い Jupyter Notebook は文芸的プログラミングとライブプログラミングの組み合わせである。ドキュメント内に埋め込んだソースコードの実行結果をグラフなどに可視化することで，機械学習アルゴリズムの直感的理解を支援する。 量子コンピュータも非常に複雑なシステムの一種であり、直感的には理解しづらい量子プログラミングのためのライブプログラミング環境がいくつか提案されてきた (Quirk, Davy Wybiral の量子回路シミュレータ)。  このように、ライブプログラミングは具体的なモデリング、シミュレーション、可視化をベースにした新しい実践の形を提供する。\n参考文献  Live Programming について (LIVE 2017 で基調講演します)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302120102-%E4%BF%9D%E5%AD%98%E7%89%88%E3%83%A1%E3%83%A2%E3%81%AE%E6%95%B0/",
                "title": "保存版メモの数",
                "section": "post",
                "date" : "2021.03.02",
                "body": "一日に書いた保存版メモの数\u0026quot; が、研究者の生産性指標として使える。たとえば、毎日コンスタントに 5 〜 10 個の保存版メモを書いている人は、かなり生産的である。\n保存版メモを書かなければ、せっかくの読書のほとんどが無駄になってしまう。保存版メモを書くことは、読書に役立つだけでなくそれ自体が利益になる。たとえば、洞察力を育む、執筆そのものを加速する、など。つまり「書くことは考えること」。\n自分はどのくらい一日に書いているだろうか? どのようにすれば計測できるだろうか?\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210301083537-ox_hugo/",
                "title": "Ox-Hugo",
                "section": "post",
                "date" : "2021.03.01",
                "body": "Org-Mode のファイルを Hugo 形式の Markdown に変換するためのプラグイン。\n保存版メモをまとめてエクスポート 次の関数を使って \u0026quot;permanent notes\u0026quot; とタグのついた Org-Roam の保存版ノートを Markdown に一括エクスポートできる。\n(after! (org org-roam) (defun my/org-roam-export-all () \u0026#34;Re-exports all Org-roam files to Hugo markdown.\u0026#34; (interactive) (dolist (f (org-roam--list-all-files)) (with-current-buffer (find-file f) (when (s-contains? \u0026#34;permanent notes\u0026#34; (buffer-string)) (org-hugo-export-wim-to-md)))))) 参考文献  Ox-Hugo (GitHub)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210301113146-%E5%AF%BE%E8%A7%92%E5%8C%96/",
                "title": "対角化",
                "section": "post",
                "date" : "2021.03.01",
                "body": "ある行列 \\(A\\) を正則行列 \\(P\\) によって相似変換して結果を対角行列にすること。 あるいは、そのような行列 \\(P\\) を見つけること\n\\[P^{-1}AP = \\begin{bmatrix} a^{\\prime}_{11} \u0026amp; 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \\\\\\\n0 \u0026amp; a^{\\prime}_{22} \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \\\\\\\n0 \u0026amp; 0 \u0026amp; \\ddots \u0026amp; \u0026amp; 0 \\\\\\\n\\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\ddots \u0026amp; 0 \\\\\\\n0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \u0026amp; a^{\\prime}_{nn} \\end{bmatrix}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210301112911-%E6%AD%A3%E5%89%87%E8%A1%8C%E5%88%97/",
                "title": "正則行列",
                "section": "post",
                "date" : "2021.03.01",
                "body": "\\(n\\) 次正方行列 \\(A\\) について、\n\\[AB = BA = I\\]\nとなる \\(n\\) 次正方行列 \\(B\\) が存在するとき、\\(A\\) は正則行列という。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210228145035-hugo/",
                "title": "Hugo",
                "section": "post",
                "date" : "2021.02.28",
                "body": "Markdown で静的サイトを作るためのツール。Ox-Hugo を使って、Org-Roam の .org ファイルから自動的に yasuhito.github.io を生成する。\nHugo 公式サイト\n.org ファイルの設定 .org ファイルの冒頭で #+SETUPFILE: setup.org を指定し setup.org には次の Hugo 共通設定を入れておく。\n#+HUGO_BASE_DIR: ~/Documents/Zettel #+HUGO_SECTION: ./posts/ テーマ Mathjax が始めから入っている cactus をとりあえず使っている。\n https://github.com/monkeyWzr/hugo-theme-cactus  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210228110804-toeic_l_r_test_%E5%87%BA%E3%82%8B%E5%8D%98%E7%89%B9%E6%80%A5_%E9%87%91%E3%81%AE%E3%83%95%E3%83%AC%E3%83%BC%E3%82%B9/",
                "title": "TOEIC L \u0026 R TEST 出る単特急 金のフレーズ",
                "section": "post",
                "date" : "2021.02.28",
                "body": "Amazon\nAnki カード作りの研究用に買ってみた。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210224084353-%E5%9F%BA%E5%BA%95%E7%8A%B6%E6%85%8B/",
                "title": "基底状態",
                "section": "post",
                "date" : "2021.02.24",
                "body": "\\(\\ket{0}\\) と \\(\\ket{1}\\) は基底状態と呼ばれ、古典コンピュータのビット 0 と 1 に対応する。数学的には、基底状態は状態ベクトル \\(\\ket{\\psi}\\) の正規直交基底を形成するベクトルであり、それぞれ次の列ベクトルで定義される。\n\\begin{equation*} \\ket{0} \\equiv \\begin{bmatrix} 1 \\newline 0 \\end{bmatrix}, \\ket{1} \\equiv \\begin{bmatrix} 0 \\newline 1 \\end{bmatrix} \\end{equation*}\nよって 1 量子ビットの状態 \\(\\ket{\\psi}\\) は、2 次元複素ベクトル空間の単位ベクトルとして表現できる。\n\\begin{equation*} \\ket{\\psi} = \\begin{bmatrix} \\alpha \\newline \\beta \\end{bmatrix} \\end{equation*}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210224083510-%E7%8A%B6%E6%85%8B%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/",
                "title": "状態ベクトル",
                "section": "post",
                "date" : "2021.02.24",
                "body": "閉じた量子系の状態を完全に記述できる単位ベクトルを状態ベクトルと呼ぶ。\nたとえば簡単な量子系である 1 つの量子ビットの任意の状態ベクトルを記号 \\(\\ket{\\psi}\\) で表すと、\\(\\ket{\\psi}\\) は基底状態 \\(\\ket{0}\\) と \\(\\ket{1}\\) の線形結合として次のように書ける。\n\\[\\ket{\\psi} = a\\ket{0} + b\\ket{1}\\]\nここで係数 \\(a\\), \\(b\\) は複素数であり、振幅と呼ぶ。また、状態ベクトルは単位ベクトルとなるための正規化条件を満たす。\n関連ノート  閉じた量子系の状態は状態ベクトルで記述できる  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210223123752-html_over_the_wire/",
                "title": "HTML Over the Wire",
                "section": "post",
                "date" : "2021.02.23",
                "body": "React や Vue.js などの Web プログラミングフレームワークでは、ネイティブアプリと同様の UX を提供するために処理の大半をブラウザ側で行う。サーバは HTML ではなくデータを JSON として返す API/GraphQL サーバーとして動作し、HTML の生成はクライアントサイドのブラウザで動作する JavaScript フレームワーク上で行う。\nこれは、従来の Rails などのフレームワークと比較して複雑である。従来は、サーバ側で MVC フレームワークが動作し、データとプレゼンテーションを HTML としてサーバ側で生成し、ブラウザへ送っていた。一方で、近年の Web フレームワークはブラウザ上で MVC フレームワークが動作する。画面遷移を高速にするために、DOM ツリーの差分を取り、仮想 DOM という仕組みで最小の書き換えで画面遷移を実現する。\nしかし、従来の単純なフレームワークでもネイティブアプリと同等の UX を達成することは可能である。DOM のうち動的な部分のみ JavaScript で書き換える。画面遷移についても、マウスオーバー時のプリフェッチによってソースコードを変更せずに高速化が可能である。\nこのための代表的なフレームワークが HOTwire。元々 Turbolinks や Stimulus.js だったものをまとめたもの。HTML の data 属性を使うことで、JavaScript 部分と HTML を結合することができる。JavaScript 部分は、サーバ側の MVC 実装や HTML にほとんど染み出さない。\n参考文献  HTML over the wire  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210223134834-org_roam/",
                "title": "Org-Roam",
                "section": "post",
                "date" : "2021.02.23",
                "body": "Org-Roam は Org Mode の上に構築された、Roam Research ライクなノート環境。\nクラウドへのバックアップ iCloud で同期すれば、ソフトウェアの追加インストールなしで iPhone や Mac と org ファイルを同期できる。とにかく手軽なので、なにか問題が出るまではしばらく iCloud でバックアップを取ることにする。\niCloud に org ディレクトリを作るには、iPhone に beorg をインストールするのが手っ取り早い。インストールすると iCloud Drive 上に beorg 用のディレクトリが作られるので、ここから ~/org にシンボリックリンクを張る。\ncd ~ ln -s ~/Library/Mobile\\ Documents/iCloud~com~appsonthemove~beorg/Documents/org org "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210223212225-%E7%B7%9A%E5%BD%A2%E7%B5%90%E5%90%88/",
                "title": "線形結合",
                "section": "post",
                "date" : "2021.02.23",
                "body": "和演算とスカラー倍演算を組合わせることで、ベクトル \\(|v_1\\rangle\\) と \\(|v_2\\rangle\\) の線形結合を作ることができる。\\(|v_1\\rangle\\) に \\(c\\) を掛け、\\(|v_2\\rangle\\) に \\(d\\) を掛け、さらに和 \\(c|v_1\\rangle + d|v_2\\rangle\\) を求める。これが \\(|v_1\\rangle\\) と \\(|v_2\\rangle\\) の線形結合。\n"
            }
        
    
]