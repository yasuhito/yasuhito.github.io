[
    
        
            {
                "ref": "https://yasuhito.github.io/post/20210409103428-qcqi_%E6%BC%94%E7%BF%92_2_18/",
                "title": "QCQI/演習 2.18",
                "section": "post",
                "date" : "2021.04.09",
                "body": "ユニタリー行列 \\(U\\) の固有値を \\(v\\), 固有ベクトルを \\(|v\\rangle\\) とすると、ユニタリー演算子は内積を保存することから、\n\\begin{eqnarray} \\langle v|v \\rangle \u0026amp;=\u0026amp; (U|v\\rangle, U|v\\rangle) \\newline \u0026amp;=\u0026amp; (v|v\\rangle, v|v\\rangle) \\newline \u0026amp;=\u0026amp; vv^{\\ast}(|v\\rangle, |v\\rangle) \\newline \u0026amp;=\u0026amp; vv^{\\ast}\\langle v|v \\rangle \\end{eqnarray}\n(式変形の \\(v\\) と \\(v^{\\ast}\\) を前にくくり出す部分では、内積は第 1 引数に関して共役線形であることと、内積は第 2 引数に関して線形であることを使った)\nよって \\(vv^{\\ast} = 1\\) であるから、\\(|v| = \\sqrt{vv^{\\ast}} = 1\\). つまり固有値はある実数 \\(\\theta\\) を用いて \\(e^{i\\theta}\\) の形で書ける。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409120432-qcqi_%E6%BC%94%E7%BF%92_2_19/",
                "title": "QCQI/演習 2.19",
                "section": "post",
                "date" : "2021.04.09",
                "body": "パウリ行列それぞれについて、\\(A^{\\dagger} = A\\) (エルミート行列) と \\(A^{\\dagger}A = I\\) (ユニタリー) を示す。\nI \\begin{equation} I^{\\dagger} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} = I \\end{equation}\n\\begin{equation} I^{\\dagger}I = II = I \\end{equation}\nX \\begin{equation} X^{\\dagger} = \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} = X \\end{equation}\n\\begin{equation} X^{\\dagger}X = XX = \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} = I \\end{equation}\nY \\begin{equation} Y^{\\dagger} = \\begin{bmatrix} 0 \u0026amp; i \\newline -i \u0026amp; 0 \\end{bmatrix}^T = \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} = Y \\end{equation}\n\\begin{equation} Y^{\\dagger}Y = YY = \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} = I \\end{equation}\nZ \\begin{equation} Z^{\\dagger} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} = Z \\end{equation}\n\\begin{equation} Z^{\\dagger}Z = ZZ = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} = I \\end{equation}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409140256-qcqi_%E6%BC%94%E7%BF%92_2_20/",
                "title": "QCQI/演習 2.20",
                "section": "post",
                "date" : "2021.04.09",
                "body": "\\(A^{\\prime}_{ij} = \\langle v_i|A|v_j\\rangle\\) について、\\(|w_i\\rangle\\) に対する完全性関係を使うと、\n\\[\\begin{align} A^{\\prime}_{ij} = \\langle v_i|A|v_j\\rangle = \\sum_{k,l} \\langle v_i|w_k\\rangle\\langle w_k|A|w_l\\rangle\\langle w_l|v_j\\rangle \\end{align}\\]\nここで、\\(U = \\sum_i |w_i\\rangle\\langle v_i|\\) とおくと、\\(|w_i\\rangle = U|v_i\\rangle\\) から、\n\\[\\begin{align} \\phantom{A^{\\prime}_{ij} = \\langle v_i|A|v_j\\rangle} \u0026amp;= \\sum_{k,l} \\langle v_i|U|v_k\\rangle\\langle w_k|A|w_l\\rangle\\langle v_l|U^{\\dagger}|v_j\\rangle \\newline \\end{align}\\]\nよって、基底 \\(|v_i\\rangle\\) に関する \\(U\\) の行列表現を \\(U^{\\prime}\\), \\(U^{\\dagger}\\) の行列表現を \\(U^{\\dagger\\prime}\\) とすると、\n\\[A_{ij}^{\\prime} = \\sum_{k,l} U_{i,k}^{\\prime} A_{kl}^{\\prime\\prime} U_{lj}^{\\dagger\\prime}\\]\nしたがって、\n\\[A^{\\prime} = U^{\\prime}A^{\\prime\\prime}U^{\\dagger\\prime}\\]\nという関係が得られる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409164921-qcqi_%E6%BC%94%E7%BF%92_2_23/",
                "title": "QCQI/演習 2.23",
                "section": "post",
                "date" : "2021.04.09",
                "body": "\\(P\\) の固有値を \\(v\\), \\(v\\) に対する固有ベクトルを \\(|v\\rangle\\) とすると、\n\\[P^2|v\\rangle = PP|v\\rangle = P(v|v\\rangle) = vP|v\\rangle = v^2|v\\rangle\\]\n一方で \\(P^2 = P\\) (QCQI/演習 2.16) なので\n\\[P^2|v\\rangle = P|v\\rangle = v|v\\rangle\\]\nよって \\(v^2 = v\\) となり、これを解くと \\(v = 0, 1\\) である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409163352-qcqi_%E6%BC%94%E7%BF%92_2_25/",
                "title": "QCQI/演習 2.25",
                "section": "post",
                "date" : "2021.04.09",
                "body": "転置共役の定義と \\((A^{\\dagger})^{\\dagger} = A\\) (QCQI/演習 2.15) より、\n\\[(|v\\rangle, A^{\\dagger}A|v\\rangle) = (|v\\rangle, A^{\\dagger}(A|v\\rangle)) = (A|v\\rangle, A|v\\rangle)\\]\nここで内積の正値性より、\\((A|v\\rangle, A|v\\rangle) \\geq 0\\) よって、\\(A^{\\dagger}A\\) は正の演算子。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409154813-%E3%82%B9%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB%E5%88%86%E8%A7%A3/",
                "title": "スペクトル分解",
                "section": "post",
                "date" : "2021.04.09",
                "body": "ベクトル空間 \\(V\\) 上の任意の正規演算子 \\(M\\) は \\(V\\) のある正規直交基底に関して対角である。逆に任意の対角化可能な演算子は正規である。\n外積表現では、この定理は \\(M\\) が \\(M = \\sum_i \\lambda_i |i\\rangle\\langle i|\\) と書けることを意味する (\\(\\lambda_i\\) は \\(M\\) の固有値、各 \\(|i\\rangle\\) は固有値 \\(\\lambda_i\\) に対応する \\(M\\) の固有ベクトルであり、\\(V\\) の正規直交基底を形成する)。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409100412-%E3%83%86%E3%83%B3%E3%82%BD%E3%83%AB%E7%A9%8D/",
                "title": "テンソル積",
                "section": "post",
                "date" : "2021.04.09",
                "body": ""
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409113657-%E5%86%85%E7%A9%8D%E3%81%AE%E5%AF%BE%E7%A7%B0%E6%80%A7/",
                "title": "内積の対称性",
                "section": "post",
                "date" : "2021.04.09",
                "body": "内積関数を記号 \\((\\cdot, \\cdot)\\) で表したとき、\n\\[(|v\\rangle, |w\\rangle) = (|w\\rangle, |v\\rangle)^{\\ast}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409114109-%E5%86%85%E7%A9%8D%E3%81%AE%E6%AD%A3%E5%80%A4%E6%80%A7/",
                "title": "内積の正値性",
                "section": "post",
                "date" : "2021.04.09",
                "body": "内積関数を記号 \\((\\cdot, \\cdot)\\) で表したとき、\\((|v\\rangle, |v\\rangle) \\geq 0\\) (正値性)、等号が成り立つのは \\(|v\\rangle = 0\\) のときのみ (正定値性)。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409105459-%E5%86%85%E7%A9%8D%E3%81%AF%E7%AC%AC_1_%E5%BC%95%E6%95%B0%E3%81%AB%E9%96%A2%E3%81%97%E3%81%A6%E5%85%B1%E5%BD%B9%E7%B7%9A%E5%BD%A2/",
                "title": "内積は第 1 引数に関して共役線形",
                "section": "post",
                "date" : "2021.04.09",
                "body": "内積の関数を記号 \\((\\cdot, \\cdot)\\) で表したとき、\n\\begin{equation} \\left(\\sum_i \\lambda_i |w_i\\rangle, |v\\rangle\\right) = \\sum_i \\lambda_i^{\\ast} (|w_i\\rangle, |v\\rangle) \\end{equation}\nとなる。証明はQCQI/演習 2.6を参照。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409111356-%E5%86%85%E7%A9%8D%E3%81%AF%E7%AC%AC_2_%E5%BC%95%E6%95%B0%E3%81%AB%E9%96%A2%E3%81%97%E3%81%A6%E7%B7%9A%E5%BD%A2/",
                "title": "内積は第 2 引数に関して線形",
                "section": "post",
                "date" : "2021.04.09",
                "body": "内積関数を記号 \\((\\cdot, \\cdot)\\) で表したとき、\n\\[\\left(|v\\rangle, \\sum_i\\lambda_i|w_i\\rangle\\right) = \\sum_i\\lambda_i(|v\\rangle, |w_i\\rangle)\\]\nとなるのでこれは第 2 引数に関して線形。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409153514-%E6%AD%A3%E3%81%AE%E5%AE%9A%E7%AC%A6%E5%8F%B7/",
                "title": "正の定符号",
                "section": "post",
                "date" : "2021.04.09",
                "body": "ベクトル \\(|v\\rangle \\neq 0\\) に対して \\((|v\\rangle, A|v\\rangle)\\) が厳密に大きければ演算子 \\(A\\) を正の定符号と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210409152203-%E6%AD%A3%E3%81%AE%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "正の演算子",
                "section": "post",
                "date" : "2021.04.09",
                "body": "任意のベクトル \\(|v\\rangle\\) に対して \\((|v\\rangle, A|v\\rangle)\\) が実数で負でない数となる演算子 \\(A\\) を正の演算子と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408084752-qcqi_%E6%BC%94%E7%BF%92_2_12/",
                "title": "QCQI/演習 2.12",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\begin{equation} A = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 1 \u0026amp; 1 \\end{bmatrix} \\end{equation}\nとする。\n\\begin{eqnarray} det|A - \\lambda I| = \\begin{bmatrix} 1 - \\lambda \u0026amp; 0 \\newline 1 \u0026amp; 1 - \\lambda \\end{bmatrix} = (1 - \\lambda)^2 = 0 \\newline \\therefore \\lambda = 1 \\end{eqnarray}\n固有値 \\(\\lambda = 1\\) に対する固有ベクトル \\(|\\lambda_1\\rangle\\) を求めると、\n\\begin{eqnarray} \\begin{bmatrix} 0 \u0026amp; 0 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} a \\newline b \\end{bmatrix} = \\begin{bmatrix} 0 \\newline 0 \\end{bmatrix} \\end{eqnarray}\nよって\n\\begin{equation} |\\lambda_1\\rangle = \\begin{bmatrix} 0 \\newline 1 \\end{bmatrix} \\end{equation}\n\\(A\\) は 1 つの固有ベクトルしか持たないので対角化できない。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408092119-qcqi_%E6%BC%94%E7%BF%92_2_13/",
                "title": "QCQI/演習 2.13",
                "section": "post",
                "date" : "2021.04.08",
                "body": "任意のベクトル \\(|l\\rangle, |m\\rangle\\) に関して、\n\\begin{eqnarray} (|l\\rangle, (|w\\rangle\\langle v|)|m\\rangle) \u0026amp;=\u0026amp; (|l\\rangle, |w\\rangle \\langle v|m\\rangle) \\newline \u0026amp;=\u0026amp; \\langle v|m \\rangle(|l\\rangle, |w\\rangle) \\newline \u0026amp;=\u0026amp; \\langle v|m \\rangle \\langle l|w\\rangle \\end{eqnarray}\nまた、\n\\begin{eqnarray} ((|v\\rangle\\langle w|)|l\\rangle, |m\\rangle) \u0026amp;=\u0026amp; (|v\\rangle \\langle w|l\\rangle, |m\\rangle) \\newline \u0026amp;=\u0026amp; \\langle l|w \\rangle(|v\\rangle, |m\\rangle) \\newline \u0026amp;=\u0026amp; \\langle l|w \\rangle \\langle v|m\\rangle \\end{eqnarray}\nよって転置共役の定義より \\((|l\\rangle, (|w\\rangle\\langle v|)|m\\rangle) = ((|v\\rangle\\langle w|)|l\\rangle, |m\\rangle)\\) だから、\\((|w\\rangle\\langle v|)^{\\dagger} = |v\\rangle\\langle w|\\)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408102838-qcqi_%E6%BC%94%E7%BF%92_2_14/",
                "title": "QCQI/演習 2.14",
                "section": "post",
                "date" : "2021.04.08",
                "body": "任意のベクトル \\(|v\\rangle, |w\\rangle\\) に対して、\n\\begin{eqnarray} \\left(\\left(\\sum_i a_i A_i\\right)^{\\dagger}|v\\rangle, |w\\rangle\\right) \u0026amp;=\u0026amp; \\left(|v\\rangle, \\sum_i a_i A_i|w\\rangle\\right) \\newline \u0026amp;=\u0026amp; \\sum_i a_i (|v\\rangle, A_i|w\\rangle) \\newline \u0026amp;=\u0026amp; \\sum_i a_i (A_i^{\\dagger}|v\\rangle, |w\\rangle) \\newline \u0026amp;=\u0026amp; \\left(\\sum_i a_i^{\\ast} A_i^{\\dagger}|v\\rangle, |w\\rangle \\right) \\end{eqnarray}\n(転置共役の定義、内積の第二引数に関する線形性、第一引数に関する共役線形性 (QCQI/演習 2.6) を使った)\nよって\n\\begin{equation} \\left(\\sum_i a_i A_i\\right)^{\\dagger} = \\sum_i a_i^{\\ast} A_i^{\\dagger} \\end{equation}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408104428-qcqi_%E6%BC%94%E7%BF%92_2_15/",
                "title": "QCQI/演習 2.15",
                "section": "post",
                "date" : "2021.04.08",
                "body": "任意のベクトル \\(|v\\rangle, |w\\rangle\\) に対して、内積の性質 \\((|v\\rangle, |w\\rangle) = (|w\\rangle, |v\\rangle)^{\\ast}\\) と転置共役の定義を使うと、\n\\begin{eqnarray} (|v\\rangle, A^{\\dagger}|w\\rangle) \u0026amp;=\u0026amp; (A^{\\dagger}|w\\rangle, |v\\rangle)^{\\ast} \\newline \u0026amp;=\u0026amp; (|w\\rangle, A|v\\rangle)^{\\ast} \\newline \u0026amp;=\u0026amp; (A|v\\rangle, |w\\rangle) \\end{eqnarray}\nこれより、\n\\begin{eqnarray} (|v\\rangle, (A^{\\dagger})^{\\dagger}|w\\rangle) \u0026amp;=\u0026amp; (A^{\\dagger}|v\\rangle, |w\\rangle) \\newline \u0026amp;=\u0026amp; (|v\\rangle, A|w\\rangle) \\end{eqnarray}\nよって \\((A^{\\dagger})^{\\dagger} = A\\)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408141931-qcqi_%E6%BC%94%E7%BF%92_2_16/",
                "title": "QCQI/演習 2.16",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\begin{eqnarray} P^2 \u0026amp;=\u0026amp; \\sum_i |i \\rangle\\langle i| \\sum_j |j \\rangle\\langle j| \\newline \u0026amp;=\u0026amp; \\sum_{i,j} |i \\rangle\\langle i|j \\rangle\\langle j| \\newline \u0026amp;=\u0026amp; \\sum_{i,j} |i \\rangle\\delta_{i,j}\\langle j| \\newline \u0026amp;=\u0026amp; \\sum_i |i \\rangle\\langle i| \\newline \u0026amp;=\u0026amp; P \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408151328-qcqi_%E6%BC%94%E7%BF%92_2_17/",
                "title": "QCQI/演習 2.17",
                "section": "post",
                "date" : "2021.04.08",
                "body": "まず「\\(A\\) がエルミート行列 \\(\\Rightarrow\\) \\(A\\) の固有値は実数」を示す。\\(A\\) の固有ベクトルを任意にとり、その固有値が \\(\\lambda\\) であるとすると、\n\\begin{eqnarray} \\lambda \\langle v|v \\rangle \u0026amp;=\u0026amp; (|v\\rangle, \\lambda |v\\rangle) \\newline \u0026amp;=\u0026amp; (|v\\rangle, A|v\\rangle) \\newline \u0026amp;=\u0026amp; (A^{\\dagger}|v\\rangle, |v\\rangle) \\newline \u0026amp;=\u0026amp; (A|v\\rangle, |v\\rangle) \\newline \u0026amp;=\u0026amp; (\\lambda|v\\rangle, |v\\rangle) \\newline \u0026amp;=\u0026amp; \\lambda^{\\ast}(|v\\rangle, |v\\rangle) \\newline \u0026amp;=\u0026amp; \\lambda^{\\ast}\\langle v|v \\rangle \\end{eqnarray}\n\\(\\lambda = \\lambda^{\\ast}\\) だから、\\(\\lambda\\) は実数。\nつぎに、「正規行列 \\(A\\) の固有値がすべて実数 \\(\\Rightarrow\\) \\(A\\) はエルミート行列」を示す。スペクトル分解の定理によると、演算子は対角化可能であるときにのみ正規である。よって \\(A\\) は対角化可能だから、\n\\begin{equation} A = \\sum_i \\lambda_i |i \\rangle\\langle i| \\end{equation}\nさらに、転置共役の反線形性とQCQI/演習 2.13の結果を使って、\n\\begin{eqnarray} A^{\\dagger} \u0026amp;=\u0026amp; \\left(\\sum_i \\lambda_i |i\\rangle\\langle i|)\\right)^{\\dagger} \\newline \u0026amp;=\u0026amp; \\sum_i \\lambda_i^{\\ast}(|i\\rangle\\langle i|)^{\\dagger} \\newline \u0026amp;=\u0026amp; \\sum_i \\lambda_i^{\\ast}|i\\rangle\\langle i| \\end{eqnarray}\n仮定の「正規行列 \\(A\\) の固有値がすべて実数」より \\(\\lambda_i = \\lambda_i^{\\ast}\\), よって \\(A = A^{\\dagger}\\) であり、\\(A\\) はエルミート行列である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408114113-%E3%82%A8%E3%83%AB%E3%83%9F%E3%83%BC%E3%83%88%E5%85%B1%E5%BD%B9%E6%BC%94%E7%AE%97%E3%81%AE%E8%A1%8C%E5%88%97%E8%A1%A8%E7%8F%BE/",
                "title": "エルミート共役演算の行列表現",
                "section": "post",
                "date" : "2021.04.08",
                "body": "エルミート共役演算子の行列表現では、エルミート共役演算は行列 \\(A\\) を共役・転置すること、すなわち \\(A^{\\dagger} \\equiv (A^{\\ast})^T\\) である。\nたとえば、\n\\begin{eqnarray} \\begin{bmatrix} 1+3i \u0026amp; 2i \\newline 1_i \u0026amp; 1-4i \\end{bmatrix}^{\\dagger} = \\begin{bmatrix} 1-3i \u0026amp; 1-i \\newline -2i \u0026amp; 1+4i \\end{bmatrix} \\end{eqnarray}\nである。\n参考  正規行列の対角化可能性  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408114955-%E3%82%A8%E3%83%AB%E3%83%9F%E3%83%BC%E3%83%88%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "エルミート演算子",
                "section": "post",
                "date" : "2021.04.08",
                "body": "演算子 \\(A\\) の転置共役が元の演算子 \\(A\\) に等しいとき、その演算子をエルミート演算子または自己共役 (自己随伴) 演算子であるという。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406110144-%E3%82%B3%E3%83%BC%E3%82%B7%E3%83%BC_%E3%82%B7%E3%83%A5%E3%83%AF%E3%83%AB%E3%83%84%E3%81%AE%E4%B8%8D%E7%AD%89%E5%BC%8F/",
                "title": "コーシー・シュワルツの不等式",
                "section": "post",
                "date" : "2021.04.08",
                "body": "ヒルベルト空間の任意の 2 つのベクトル \\(|v\\rangle\\), \\(|w\\rangle\\) に対して \\(|\\langle v|w\\rangle|^2 \\leq \\langle v|v \\rangle \\langle w|w \\rangle\\).\n証明するにはグラム・シュミット直交化でベクトル空間の正規直交基底 \\(|i\\rangle\\) を作り、最初の基底 \\(|i\\rangle\\) を \\(|w\\rangle / \\sqrt{\\langle w|w \\rangle}\\) とする。完全性関係 \\(\\sum_i |i\\rangle\\langle i| = I\\) を用い、\n\\begin{eqnarray} \\langle v|v \\rangle \\langle w|w \\rangle \u0026amp;=\u0026amp; \\sum_i \\langle v|i \\rangle \\langle i | v \\rangle \\langle w|w \\rangle \\end{eqnarray}\nここで、最初の基底 \\(|i\\rangle = |w\\rangle/\\sqrt{\\langle w | w \\rangle}\\ (\\langle i| = \\langle w|/\\sqrt{\\langle w | w \\rangle})\\) の項だけを残すと、\n\\begin{eqnarray} \\sum_i \\langle v|i \\rangle \\langle i | v \\rangle \\langle w|w \\rangle \u0026amp;\\geq\u0026amp; \\frac{\\langle v|w \\rangle \\langle w | v \\rangle}{\\langle w | w \\rangle}\\langle w | w \\rangle \\newline \u0026amp;=\u0026amp; \\langle v | w\\rangle \\langle w | v\\rangle = |\\langle v | w \\rangle |^2 \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408120225-%E3%83%8F%E3%82%A6%E3%83%AA%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%A4%96%E7%A9%8D%E8%A1%A8%E7%8F%BE/",
                "title": "パウリ演算子の外積表現",
                "section": "post",
                "date" : "2021.04.08",
                "body": "QCQI/演習 2.9を参照\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408120013-%E3%83%8F%E3%82%A6%E3%83%AA%E8%A1%8C%E5%88%97%E3%81%AE%E5%9B%BA%E6%9C%89%E5%88%86%E8%A7%A3/",
                "title": "パウリ行列の固有分解",
                "section": "post",
                "date" : "2021.04.08",
                "body": "QCQI/演習 2.11を参照\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408160607-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%BC/",
                "title": "ユニタリー",
                "section": "post",
                "date" : "2021.04.08",
                "body": " ユニタリー行列 \\(U^{\\dagger}U = I\\) ならば行列 \\(U\\) はユニタリーであるという ユニタリー演算子 演算子 \\(U\\) が \\(U^{\\dagger}U = I\\) ならば演算子 \\(U\\) はユニタリー  ユニタリー演算子は \\(UU^{\\dagger} = I\\) も満たすので、\\(U\\) は正規でありスペクトル分解ができる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408161727-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%BC%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%A4%96%E7%A9%8D%E8%A1%A8%E7%8F%BE/",
                "title": "ユニタリー演算子の外積表現",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\(|v_i\\rangle\\) は任意の正規直交基底の集合であるとする。\\(|w_i\\rangle \\equiv U|v_i\\rangle\\) を定義すると、ユニタリー演算子は内積を保存するので \\(|w_i\\rangle\\) も正規直交基底の集合である。したがって \\(U = \\sum_i |w_i\\rangle\\langle v_i|\\) が成り立つ。逆にもし \\(|v\\rangle\\) と \\(|w\\rangle\\) が任意の 2 つの直交基底ならば、\\(U \\equiv \\sum_i |w_i\\rangle\\langle v_i|\\) で定義される演算子 \\(U\\) はユニタリー演算子であることが容易に確認できる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408161455-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%BC%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AF%E5%86%85%E7%A9%8D%E3%82%92%E4%BF%9D%E5%AD%98%E3%81%99%E3%82%8B/",
                "title": "ユニタリー演算子は内積を保存する",
                "section": "post",
                "date" : "2021.04.08",
                "body": "幾何学的にユニタリー演算子はベクトル間の内積を保存する。これを見るために \\(|v\\rangle\\) と \\(|w\\rangle\\) を任意の 2 つのベクトルとすると、\\(U|v\\rangle\\) と \\(U|w\\rangle\\) の内積は \\(|v\\rangle\\) と \\(|w\\rangle\\) の内積に等しい。\n\\begin{equation} (U|v\\rangle, U|w\\rangle) = \\langle v|U^{\\dagger}U|w\\rangle = \\langle v|I|w\\rangle = \\langle v|w\\rangle \\end{equation}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408120345-%E5%8D%98%E4%BD%8D%E5%85%83%E3%81%AE%E8%A1%8C%E5%88%97%E8%A1%A8%E7%8F%BE/",
                "title": "単位元の行列表現",
                "section": "post",
                "date" : "2021.04.08",
                "body": "QCQI/演習 2.4を参照\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408121035-%E5%B0%84%E5%BD%B1%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "射影演算子",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\(W\\) が \\(d\\) 次元ベクトル空間 \\(V\\) 上の \\(k\\) 次元ベクトル部分空間であるとする。グラム・シュミット直交化を用いると、\\(|1\\rangle, \\ldots, |k\\rangle\\) が \\(W\\) の正規直交基底となるように \\(V\\) に対する正規直交基底 \\(|1\\rangle, \\ldots, |d\\rangle\\) を作ることができる。定義により\n\\begin{equation} P \\equiv \\sum_{i=1}^k |i\\rangle\\langle i| \\end{equation}\nは部分空間 \\(W\\) への射影演算子である。\nQCQI/演習 2.13により任意のベクトル \\(|v\\rangle\\) に対して \\((|v\\rangle\\langle v|)^{\\dagger} = |v\\rangle\\langle v|\\) なので、\\(|v\\rangle\\langle v|\\) はエルミート演算子である。したがって \\(P\\) もエルミート演算子、すなわち \\(P^{\\dagger} = P\\) である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408142915-%E6%AD%A3%E8%A6%8F/",
                "title": "正規",
                "section": "post",
                "date" : "2021.04.08",
                "body": "演算子 \\(A\\) が \\(AA^{\\dagger} = A^{\\dagger}A\\) を満たすとき、これを正規であるという。エルミート演算子は正規である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408163416-%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E5%9F%BA%E5%BA%95/",
                "title": "正規直交基底",
                "section": "post",
                "date" : "2021.04.08",
                "body": "正規直交な基底のこと。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408140459-%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E8%A3%9C%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "正規直交補演算子",
                "section": "post",
                "date" : "2021.04.08",
                "body": "射影演算子 \\(P\\) について \\(Q = I - P\\) を正規直交補演算子と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408141226-%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E8%A3%9C%E7%A9%BA%E9%96%93/",
                "title": "正規直交補空間",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\(W\\) が \\(d\\) 次元ベクトル空間 \\(V\\) 上の \\(k\\) 次元ベクトル部分空間であるとする。グラム・シュミット直交化を用いると、\\(|1\\rangle, \\ldots, |k\\rangle\\) が \\(W\\) の正規直交基底となるように \\(V\\) に対する正規直交基底 \\(|1\\rangle, \\ldots, |d\\rangle\\) を作ることができる。\nここで正規直交補演算子 Q は \\(|k+1\\rangle, \\ldots, |d\\rangle\\) で張られたベクトル空間への射影演算子であり、その空間を \\(P\\) の正規直交補空間と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408120450-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E7%A9%8D%E3%81%AE%E8%A1%8C%E5%88%97%E8%A1%A8%E7%8F%BE/",
                "title": "演算子の積の行列表現",
                "section": "post",
                "date" : "2021.04.08",
                "body": "QCQI/演習 2.3を参照\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408091257-%E8%BB%A2%E7%BD%AE%E5%85%B1%E5%BD%B9/",
                "title": "転置共役",
                "section": "post",
                "date" : "2021.04.08",
                "body": "\\(A\\) はヒルベルト空間 \\(V\\) の任意の演算子であるとすると、すべてのベクトル \\(|v\\rangle, |w\\rangle \\in V\\) に対して、\n\\begin{equation} (|v\\rangle, A|w\\rangle) = (A^{\\dagger}|v\\rangle, |w\\rangle) \\end{equation}\nを満たす演算子 \\(A^{\\dagger}\\) が \\(V\\) 上に唯 1 つのみ存在する。この演算子を演算子 \\(A\\) の転置共役またはエルミート共役という。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210408115741-%E8%BB%A2%E7%BD%AE%E5%85%B1%E5%BD%B9%E3%81%AE%E5%8F%8D%E7%B7%9A%E5%BD%A2%E6%80%A7/",
                "title": "転置共役の反線形性",
                "section": "post",
                "date" : "2021.04.08",
                "body": "転置共役演算は次の性質を満たすため、反線形 (anti-linear) である。\n\\begin{equation} \\left(\\sum_i a_i A_i\\right)^{\\dagger} = \\sum_i a_i^{\\ast} A_i^{\\dagger} \\end{equation}\n証明は QCQI/演習 2.14 を参照。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406103502-qcqi_%E6%BC%94%E7%BF%92_2_10/",
                "title": "QCQI/演習 2.10",
                "section": "post",
                "date" : "2021.04.06",
                "body": "演算子の外積表現より、演算子 \\(|v_j\\rangle\\langle v_k|\\) の行列表現 \\(A\\) の行列要素は \\(A_{lm} = \\langle w_l|v_j\\rangle\\langle v_k|v_m\\rangle = \\delta_{lj}\\delta_{km}\\)\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406155031-qcqi_%E6%BC%94%E7%BF%92_2_11/",
                "title": "QCQI/演習 2.11",
                "section": "post",
                "date" : "2021.04.06",
                "body": "\\(X\\) の固有分解 \\(X\\) の固有値を求めると、\n\\begin{eqnarray} det|X - \\lambda I| = \\begin{vmatrix} -\\lambda \u0026amp; 1 \\newline 1 \u0026amp; -\\lambda \\end{vmatrix} = \\lambda^2 - 1 = 0\\ \\therefore \\lambda = \\pm1 \\end{eqnarray}\nよって \\(\\lambda = 1\\) と \\(\\lambda = -1\\) のとき、\\(X\\) の固有ベクトルのうち正規化したものはそれぞれ、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline 1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle),\\newline |\\lambda_{-1}\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline -1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle) \\end{eqnarray}\nよって \\(X\\) の対角表現は、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\lambda_1|\\lambda_1\\rangle\\langle\\lambda_1| + \\lambda_{-1}|\\lambda_{-1}\\rangle\\langle\\lambda_{-1}|\\newline \u0026amp;=\u0026amp; \\frac{1}{2}(|0\\rangle + |1\\rangle)(\\langle 0| + \\langle 1|) - \\frac{1}{2}(|0\\rangle - |1\\rangle)(\\langle 0| - \\langle 1|) \\end{eqnarray}\n\\(Y\\) の固有分解 \\(Y\\) の固有値を求めると、\n\\begin{eqnarray} det|Y - \\lambda I| = \\begin{vmatrix} -\\lambda \u0026amp; -i \\newline i \u0026amp; -\\lambda \\end{vmatrix} = \\lambda^2 - 1 = 0\\ \\therefore \\lambda = \\pm1 \\end{eqnarray}\nよって \\(\\lambda = 1\\) と \\(\\lambda = -1\\) のとき、\\(Y\\) の固有ベクトルのうち正規化したものはそれぞれ、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline i \\end{bmatrix} = \\frac{1}{\\sqrt{2}}(|0\\rangle + i|1\\rangle),\\newline |\\lambda_{-1}\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\newline -i \\end{bmatrix} = \\frac{1}{\\sqrt{2}}(|0\\rangle - i|1\\rangle) \\end{eqnarray}\nよって \\(Y\\) の対角表現は、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\lambda_1|\\lambda_1\\rangle\\langle\\lambda_1| + \\lambda_{-1}|\\lambda_{-1}\\rangle\\langle\\lambda_{-1}|\\newline \u0026amp;=\u0026amp; \\frac{1}{2}(|0\\rangle + i|1\\rangle)(\\langle 0| + i\\langle 1|) - \\frac{1}{2}(|0\\rangle - i|1\\rangle)(\\langle 0| - i\\langle 1|) \\end{eqnarray}\n\\(Z\\) の固有分解 \\(Z\\) の固有値を求めると、\n\\begin{eqnarray} det|Z - \\lambda I| = \\begin{vmatrix} 1 - \\lambda \u0026amp; 0 \\newline 0 \u0026amp; -1 - \\lambda \\end{vmatrix} = - (1 - \\lambda^2) = 0\\ \\therefore \\lambda = \\pm1 \\end{eqnarray}\nよって \\(\\lambda = 1\\) と \\(\\lambda = -1\\) のとき、\\(Z\\) の固有ベクトルのうち正規化したものはそれぞれ、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\begin{bmatrix} 1 \\newline 0 \\end{bmatrix} = |0\\rangle,\\newline |\\lambda_{-1}\\rangle \u0026amp;=\u0026amp; \\begin{bmatrix} 0 \\newline 1 \\end{bmatrix} = |1\\rangle \\end{eqnarray}\nよって \\(Z\\) の対角表現は、\n\\begin{eqnarray} |\\lambda_1\\rangle \u0026amp;=\u0026amp; \\lambda_1|\\lambda_1\\rangle\\langle\\lambda_1| + \\lambda_{-1}|\\lambda_{-1}\\rangle\\langle\\lambda_{-1}|\\newline \u0026amp;=\u0026amp; |0\\rangle\\langle 0| - |1\\rangle\\langle 1| \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406095636-qcqi_%E6%BC%94%E7%BF%92_2_9/",
                "title": "QCQI/演習 2.9",
                "section": "post",
                "date" : "2021.04.06",
                "body": "演算子の外積表現とパウリ行列を使う。\n\\(I\\) の外積表現 \\begin{eqnarray} I \u0026amp;=\u0026amp; \\sum_{i,j=0}^1 \\langle j|I|i\\rangle|j\\rangle\\langle i| \\\\\\\n\u0026amp;=\u0026amp; 1\\cdot|0 \\rangle\\langle 0| + 0\\cdot|0 \\rangle\\langle 1| + 0\\cdot|1 \\rangle\\langle 0| + 1\\cdot|1 \\rangle\\langle 1| \\\\\\\n\u0026amp;=\u0026amp; |0 \\rangle\\langle 0| + |1 \\rangle\\langle 1| \\end{eqnarray}\n\\(X\\) の外積表現 \\begin{eqnarray} X \u0026amp;=\u0026amp; \\sum_{i,j=0}^1 \\langle j|X|i\\rangle|j\\rangle\\langle i| \\\\\\\n\u0026amp;=\u0026amp; 0\\cdot|0 \\rangle\\langle 0| + 1\\cdot|0 \\rangle\\langle 1| + 1\\cdot|1 \\rangle\\langle 0| + 0\\cdot|1 \\rangle\\langle 1| \\\\\\\n\u0026amp;=\u0026amp; |0 \\rangle\\langle 1| + |1 \\rangle\\langle 0| \\end{eqnarray}\n\\(Y\\) の外積表現 \\begin{eqnarray} Y \u0026amp;=\u0026amp; \\sum_{i,j=0}^1 \\langle j|Y|i\\rangle|j\\rangle\\langle i| \\\\\\\n\u0026amp;=\u0026amp; 0\\cdot|0 \\rangle\\langle 0| + (-i)\\cdot|0 \\rangle\\langle 1| + i\\cdot|1 \\rangle\\langle 0| + 0\\cdot|1 \\rangle\\langle 1| \\\\\\\n\u0026amp;=\u0026amp; -i|0 \\rangle\\langle 1| + i|1 \\rangle\\langle 0| \\end{eqnarray}\n\\(Z\\) の外積表現 \\begin{eqnarray} Z \u0026amp;=\u0026amp; \\sum_{i,j=0}^1 \\langle j|Z|i\\rangle|j\\rangle\\langle i| \\\\\\\n\u0026amp;=\u0026amp; 1\\cdot|0 \\rangle\\langle 0| + 0\\cdot|0 \\rangle\\langle 1| + 0\\cdot|1 \\rangle\\langle 0| + (-1)\\cdot|1 \\rangle\\langle 1| \\\\\\\n\u0026amp;=\u0026amp; |0 \\rangle\\langle 0| - |1 \\rangle\\langle 1| \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406144840-%E5%9B%BA%E6%9C%89%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/",
                "title": "固有ベクトル",
                "section": "post",
                "date" : "2021.04.06",
                "body": "ベクトル空間における演算子 \\(A\\) の固有ベクトルとは、\\(A|v\\rangle = v|v\\rangle\\) を満たす \\(0\\) でないベクトル \\(|v\\rangle\\) のこと。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406145445-%E5%9B%BA%E6%9C%89%E5%80%A4/",
                "title": "固有値",
                "section": "post",
                "date" : "2021.04.06",
                "body": "ベクトル空間における演算子 \\(A\\) について、\\(A|v\\rangle = v|v\\rangle\\) を満たす固有ベクトル \\(|v\\rangle\\) に対応する複素数 \\(v\\) を \\(A\\) の固有値と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406155458-%E5%9B%BA%E6%9C%89%E6%96%B9%E7%A8%8B%E5%BC%8F/",
                "title": "固有方程式",
                "section": "post",
                "date" : "2021.04.06",
                "body": "特性方程式の別名\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406151942-%E5%9B%BA%E6%9C%89%E7%A9%BA%E9%96%93/",
                "title": "固有空間",
                "section": "post",
                "date" : "2021.04.06",
                "body": "固有値 \\(v\\) に対応する固有空間とは固有値 \\(v\\) を持つベクトルの集合であり、\\(A\\) が作用するベクトル空間のベクトル部分空間になる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406083525-%E5%A4%96%E7%A9%8D%E8%A1%A8%E7%8F%BE/",
                "title": "外積表現",
                "section": "post",
                "date" : "2021.04.06",
                "body": "外積表現とは、内積を使って演算子を表現する便利な方法。 \\(|v\\rangle\\) を内積空間 \\(V\\) のベクトル、\\(|w\\rangle\\) を内積空間 \\(W\\) のベクトルとしたとき、\\(|w \\rangle\\langle v|\\) は次式で定義される \\(V\\) から \\(W\\) への演算子である。\n\\begin{equation} (|w\\rangle\\langle v|)(|v^{\\prime}) \\equiv |w\\rangle\\langle v|v^{\\prime}\\rangle = \\langle v | v^{\\prime} \\rangle | w \\rangle \\end{equation}\nここで \\(|w\\rangle\\langle v|v^{\\prime}\\rangle\\) は次の 2 つの意味を持つ:\n 演算子 \\(|w\\rangle\\langle v|\\) が \\(|v^{\\prime}\\rangle\\) に働いたときの結果 \\(|w\\rangle\\) に複素数 \\(\\langle v | v^{\\prime} \\rangle\\) を掛けた結果  ここで 2 の内積の計算で 1 の演算子の計算ができることに注意。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406090438-%E5%AE%8C%E5%85%A8%E6%80%A7%E9%96%A2%E4%BF%82/",
                "title": "完全性関係",
                "section": "post",
                "date" : "2021.04.06",
                "body": "\\(|i\\rangle\\) をベクトル空間 \\(V\\) における任意の正規直交基底とすると、\n\\[\\sum_i |i\\rangle \\langle i| = I\\]\nが成り立つ。この式を完全性関係と呼ぶ。\n導出 外積表現を使う。任意のベクトル \\(|v\\rangle\\) はある複素数の集合 \\(v_i\\) と正規直交基底 \\(|i\\rangle\\) を用いて \\(|v\\rangle = \\sum_i v_i|i\\rangle\\) と書ける。\\(\\langle i|v\\rangle = v_i\\) であるから、\n\\[\\left(\\sum_i |i\\rangle \\langle i|\\right)|v\\rangle = \\sum_i |i\\rangle \\langle i|v\\rangle = \\sum_i v_i|i\\rangle = |v\\rangle\\]\nつまり \\(\\left(\\sum_i |i\\rangle \\langle i|\\right)|v\\rangle = |v\\rangle\\) であり、これが任意のベクトル \\(|v\\rangle\\) について成り立つということは \\(\\sum_i |i\\rangle \\langle i|\\) は恒等演算子であるから、\n\\[\\sum_i |i\\rangle \\langle i| = I\\]\nが成り立つ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406154403-%E5%AF%BE%E8%A7%92%E5%8C%96%E5%8F%AF%E8%83%BD/",
                "title": "対角化可能",
                "section": "post",
                "date" : "2021.04.06",
                "body": "演算子の対角表現ができるとき、その演算子は対角化可能であるという\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406152433-%E5%AF%BE%E8%A7%92%E8%A1%A8%E7%8F%BE/",
                "title": "対角表現",
                "section": "post",
                "date" : "2021.04.06",
                "body": "ベクトル空間 \\(V\\) 上の演算子に対する対角表現は表現 \\(A = \\sum_i \\lambda |i\\rangle\\langle i|\\) である。ここでベクトル \\(|i\\rangle\\) は \\(A\\) の固有値 \\(\\lambda_i\\) に対する固有ベクトルであり、この固有ベクトルは正規直交集合を形成する。\n対角表現の例としてパウリ行列の \\(Z\\) 行列は次のように書ける。\n\\begin{equation} Z = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} = |0\\rangle\\langle 0| - |1\\rangle\\langle 1| \\end{equation}\nここで行列表現は正規直交ベクトル \\(|0\\rangle, |1\\rangle\\) に基いている。\n関連ノート  QCQI/演習 2.9 演算子の外積表現  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406153608-%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E5%88%86%E8%A7%A3/",
                "title": "正規直交分解",
                "section": "post",
                "date" : "2021.04.06",
                "body": "対角表現の別名\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406093454-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%A4%96%E7%A9%8D%E8%A1%A8%E7%8F%BE/",
                "title": "演算子の外積表現",
                "section": "post",
                "date" : "2021.04.06",
                "body": "\\(A: V \\rightarrow W\\) を演算子、\\(|v_i\\rangle\\) を \\(V\\) に対する正規直交基底、\\(|w_i\\rangle\\) を \\(W\\) に対する正規直交基底とする。完全性関係を使うと、\n\\begin{eqnarray} A \u0026amp;=\u0026amp; I_W AI_{V} \\\\\\\n\u0026amp;=\u0026amp; \\sum_{ij} |w_j\\rangle \\langle w_j|A|v_i\\rangle\\langle v_i| \\\\\\\n\u0026amp;=\u0026amp; \\sum_{ij} \\langle w_j|A|v_i\\rangle|w_j\\rangle\\langle v_i| \\end{eqnarray}\nこれは \\(A\\) の外積表現。この式から入力基底 \\(|v_i\\rangle\\), 出力基底 \\(|w_i\\rangle\\) に対して行列 \\(A\\) の \\(i\\) 行 \\(j\\) 列の行列要素は \\(\\langle w_j|A|v_i\\rangle\\) であることがわかる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406151137-%E7%89%B9%E6%80%A7%E6%96%B9%E7%A8%8B%E5%BC%8F/",
                "title": "特性方程式",
                "section": "post",
                "date" : "2021.04.06",
                "body": "特性関数 \\(c(\\lambda) \\equiv det|A - \\lambda I|\\) について、特性方程式 \\(c(\\lambda) = 0\\) の解は演算子 \\(A\\) の固有値である。代数の基礎定理によるとすべての多項式は少なくとも 1 つの複素数の解を持つので、すべての演算子は少なくとも 1 つの固有値とそれに対応する固有ベクトルを持つ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210406150501-%E7%89%B9%E6%80%A7%E9%96%A2%E6%95%B0/",
                "title": "特性関数",
                "section": "post",
                "date" : "2021.04.06",
                "body": "ベクトル空間における演算子 \\(A\\) があったとき、特性関数を \\(c(\\lambda) \\equiv det|A - \\lambda I|\\) で定義する。特性関数は演算子 \\(A\\) のみに依存し、\\(A\\) を表す特定の行列表現には依存しない。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405093758-qcqi_%E6%BC%94%E7%BF%92_2_5/",
                "title": "QCQI/演習 2.5",
                "section": "post",
                "date" : "2021.04.05",
                "body": "\\(\\mathcal{C}^n\\) の内積の定義\n\\begin{equation} ((y_1, \\ldots, y_n), (z_1, \\ldots, z_n)) \\equiv \\sum_i y_i^{\\ast}z_i = \\begin{bmatrix} y_1^{\\ast}, \\ldots, y_n^{\\ast} \\end{bmatrix}\\begin{bmatrix} z_1 \\newline \\vdots \\newline z_n \\end{bmatrix} \\end{equation}\nについて、内積の定義をすべて満たすことを確認する。\n線形性について、\n\\begin{eqnarray} \\left(|v\\rangle, \\sum_i \\lambda_i|w_i\\rangle\\right) \u0026amp;=\u0026amp; \\sum_j v_j^{\\ast} \\left(\\sum_i \\lambda_i w_{ij}\\right) \\\\\\\n\u0026amp;=\u0026amp; \\sum_i \\lambda_i \\left(\\sum_j v_j^{\\ast} w_{ij}\\right) \\\\\\\n\u0026amp;=\u0026amp; \\sum_i \\lambda_i (|v\\rangle, |w_i\\rangle) \\end{eqnarray}\n対称性について、\n\\begin{eqnarray} (|v\\rangle, |w\\rangle) \u0026amp;=\u0026amp; \\sum_i v_i^{\\ast}w_i \\\\\\\n\u0026amp;=\u0026amp; \\sum_i (v_i w_i^{\\ast})^{\\ast} \\\\\\\n\u0026amp;=\u0026amp; \\sum_i (w_i^{\\ast} v_i)^{\\ast} \\\\\\\n\u0026amp;=\u0026amp; (|w\\rangle, |v\\rangle)^{\\ast} \\end{eqnarray}\n正値性、正定値性について、\n\\begin{eqnarray} (|v\\rangle, |v\\rangle) \u0026amp;=\u0026amp; \\sum_i v_i^{\\ast}v_i \\\\\\\n\u0026amp;=\u0026amp; \\sum_i |v_i|^2 \\geq 0 \\end{eqnarray}\n明らかに、等号が成り立つのは \\(|v\\rangle = 0\\) のときのみ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405105718-qcqi_%E6%BC%94%E7%BF%92_2_6/",
                "title": "QCQI/演習 2.6",
                "section": "post",
                "date" : "2021.04.05",
                "body": "内積の定義より、\n\\begin{eqnarray} \\left(\\sum_i \\lambda_i |w_i\\rangle, |v\\rangle\\right) \u0026amp;=\u0026amp; \\left(|v\\rangle, \\sum_i \\lambda_i |w_i\\rangle\\right)^{\\ast} \\\\\\\n\u0026amp;=\u0026amp; \\left(\\sum_i \\lambda_i (|v\\rangle, |w_i\\rangle)\\right)^{\\ast} \\\\\\\n\u0026amp;=\u0026amp; \\sum_i \\lambda_i^{\\ast} (|v\\rangle, |w_i\\rangle)^{\\ast} \\\\\\\n\u0026amp;=\u0026amp; \\sum_i \\lambda_i^{\\ast} (|w_i\\rangle, |v\\rangle) \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405132421-qcqi_%E6%BC%94%E7%BF%92_2_7/",
                "title": "QCQI/演習 2.7",
                "section": "post",
                "date" : "2021.04.05",
                "body": "\\(|w\\rangle\\) と \\(|v\\rangle\\) の内積を計算すると、\n\\begin{equation} \\langle w|v \\rangle = \\begin{bmatrix} 1 \u0026amp; 1 \\end{bmatrix}^{\\ast}\\begin{bmatrix} 1 \\newline -1 \\end{bmatrix} = 1\\times1 + 1 \\times (-1) = 0 \\end{equation}\nよって \\(|w\\rangle\\) と \\(|v\\rangle\\) は直交している。\n\\(\\||w\\rangle\\| = \\sqrt{\\langle w|w \\rangle} = \\sqrt{2},\\ \\||v\\rangle\\| = \\sqrt{\\langle v|v \\rangle} = \\sqrt{2}\\) なので、それぞれを正規化すると、\n\\begin{eqnarray} \\frac{|w\\rangle}{\\||w\\rangle\\|} \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}|w\\rangle, \\newline\\newline \\frac{|v\\rangle}{\\||v\\rangle\\|} \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}|v\\rangle \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405144551-qcqi_%E6%BC%94%E7%BF%92_2_8/",
                "title": "QCQI/演習 2.8",
                "section": "post",
                "date" : "2021.04.05",
                "body": "グラム・シュミット直交化によって作られたベクトルの集合について、それぞれのベクトルが正規化されていることは明らかなので、その集合のうち互いに異なるベクトルが直交していることを数学的帰納法で示す。\n\\(k = 1\\) のとき、\n\\begin{eqnarray} |v_1\\rangle \u0026amp;=\u0026amp; \\frac{|w_1\\rangle}{\\||w_1\\rangle\\|} \\newline |v_2\\rangle \u0026amp;=\u0026amp; \\frac{|w_2\\rangle - \\langle v_1 | w_2 \\rangle |v_1\\rangle}{\\||w_2\\rangle - \\langle v_1 | w_2 \\rangle |v_1\\rangle\\|} \\newline \\langle v_1|v_2\\rangle \u0026amp;=\u0026amp; \\frac{\\langle v_1|w_2\\rangle - \\langle v_1 | w_2 \\rangle \\langle v_1|v_1\\rangle}{\\||w_2\\rangle - \\langle v_1 | w_2 \\rangle |v_1\\rangle\\|} \\newline \u0026amp;=\u0026amp; \\frac{\\langle v_1|w_2\\rangle - \\langle v_1 | w_2 \\rangle \\cdot 1}{\\||w_2\\rangle - \\langle v_1 | w_2 \\rangle |v_1\\rangle\\|} = 0 \\end{eqnarray}\nここで \\(|v_1\\rangle, \\ldots, |v_n\\rangle\\ (n \\leq d-1)\\) が正規直交基底だとする。すると、\n\\begin{align*} \\langle v_j | v_{n+1} \\rangle \u0026amp;= \\langle v_j | \\left(\\frac{|w_{n+1}\\rangle - \\sum_{i=1}^{n} \\langle v_i | w_{n+1} \\rangle|v_i\\rangle}{\\||w_{n+1}\\rangle - \\sum_{i=1}^{n} \\langle v_i | w_{n+1} \\rangle|v_i\\rangle\\|}\\right)~~(j \\leq n) \\newline \u0026amp;= \\frac{\\langle v_j |w_{n+1}\\rangle - \\sum_{i=1}^{n} \\langle v_i | w_{n+1} \\rangle \\langle v_j|v_i\\rangle}{\\||w_{n+1}\\rangle - \\sum_{i=1}^{n} \\langle v_i | w_{n+1} \\rangle|v_i\\rangle\\|} \\newline \u0026amp;= \\frac{\\langle v_j |w_{n+1}\\rangle - \\sum_{i=1}^{n} \\langle v_i | w_{n+1} \\rangle \\delta_{ij}}{\\||w_{n+1}\\rangle - \\sum_{i=1}^{n} \\langle v_i | w_{n+1} \\rangle|v_i\\rangle\\|} \\newline \u0026amp;= \\frac{\\langle v_j |w_{n+1}\\rangle - \\langle v_j | w_{n+1} \\rangle}{\\||w_{n+1}\\rangle - \\sum_{i=1}^{n} \\langle v_i | w_{n+1} \\rangle|v_i\\rangle\\|} \\newline \u0026amp;= 0 \\end{align*}\nよってグラム・シュミット直交化によって正規直交基底が作られる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405141728-%E3%82%AF%E3%83%A9%E3%83%A0_%E3%82%B7%E3%83%A5%E3%83%9F%E3%83%83%E3%83%88%E7%9B%B4%E4%BA%A4%E5%8C%96/",
                "title": "グラム・シュミット直交化",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル空間の基底集合から正規直交基底集合を作るための方法。おおまかには次の手順で行われる:\n 基底集合の 1 番目のベクトルを正規化する 2 番目のベクトルを 1 番目のベクトルと垂直 (内積 = 0) にし、正規化する 3 番目のベクトルを 1, 2 番目のベクトルと垂直にし、正規化する \u0026hellip; n 番目のベクトルを以前のベクトルすべてと垂直にし、正規化する (繰り返し)  一般化すると次のようになる。\\(|w_1\\rangle, \\ldots, |w_d\\rangle\\) がベクトル空間 \\(V\\) に対する基底集合、作りたい正規直交基底集合を \\(|v_1\\rangle, \\ldots, |v_d\\rangle\\) とする。\\(|v_1\\rangle \\equiv |w_1\\rangle / \\||w_1\\rangle\\|\\) と定義し、\\(1 \\leq k \\leq d - 1\\) に対して帰納的に \\(|v_{k_1}\\rangle\\) を次のように定義する。\n\\begin{equation} |v_{k+1}\\rangle \\equiv \\frac{|w_{k+1}\\rangle - \\sum^k_{i=1} \\langle v_i | w_{k+1}\\rangle |v_i\\rangle}{\\||w_{k+1}\\rangle - \\sum^k_{i=1}\\langle v_i|w_{k+1}\\rangle|v_i\\rangle\\|} \\end{equation}\nこの方法によって正規直交基底集合が作れるので、任意の (有限) \\(d\\) 次元のベクトル空間は正規直交基底 \\(|v_1\\rangle, \\ldots, |v_d\\rangle\\) を持つ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405113237-%E3%83%8E%E3%83%AB%E3%83%A0/",
                "title": "ノルム",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル \\(|v\\rangle\\) のノルムを次式で定義する\n\\begin{equation} \\||v\\rangle\\| = \\sqrt{\\langle v|v \\rangle} \\end{equation}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405084714-%E3%83%8F%E3%82%A6%E3%83%AA%E8%A1%8C%E5%88%97/",
                "title": "パウリ行列",
                "section": "post",
                "date" : "2021.04.05",
                "body": "量子計算や量子情報で頻出する行列で、下記のようにいろいろな記号での表し方がある。とにかくよく使うので暗記してしまうのがよい。\n\\begin{align} \\sigma_{0} \\equiv I \u0026amp;\\equiv \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\end{bmatrix} \u0026amp; \\sigma_{1} \\equiv \\sigma_{x} \\equiv X \u0026amp;\\equiv \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\newline\\newline \\sigma_{2} \\equiv \\sigma{y} \\equiv Y \u0026amp;\\equiv \\begin{bmatrix} 0 \u0026amp; -i \\newline i \u0026amp; 0 \\end{bmatrix} \u0026amp; \\sigma_{3} \\equiv \\sigma_{z} \\equiv Z \u0026amp;\\equiv \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\end{align}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405112448-%E3%83%92%E3%83%AB%E3%83%98%E3%83%AB%E3%83%88%E7%A9%BA%E9%96%93/",
                "title": "ヒルベルト空間",
                "section": "post",
                "date" : "2021.04.05",
                "body": "量子計算と量子情報ではふつう有限次元の複素ベクトル空間についてのみ扱い、この場合内積空間とヒルベルト空間は同一視できる。なので、ヒルベルト空間 = 内積空間だと思ってよい。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405091552-%E5%86%85%E7%A9%8D/",
                "title": "内積",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル空間の 2 つのベクトル \\(|v\\rangle\\) と \\(|w\\rangle\\) を入力とし複素数を出力として作り出す関数を内積と呼ぶ。\nベクトル空間 \\(V\\) について、\\(V \\times V\\) から \\(\\mathcal{C}\\) への関数 \\((\\cdot , \\cdot)\\) が次の要請を満たすなら内積:\n 内積は第 2 引数に関して線形 内積の対称性 内積の正値性  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405093150-%E5%86%85%E7%A9%8D%E7%A9%BA%E9%96%93/",
                "title": "内積空間",
                "section": "post",
                "date" : "2021.04.05",
                "body": "内積を備えたベクトル空間を内積空間と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405113700-%E5%8D%98%E4%BD%8D%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/",
                "title": "単位ベクトル",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ノルム \\(\\||v\\rangle\\| = 1\\) となるベクトル \\(|v\\rangle\\) を単位ベクトルと呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405113900-%E6%AD%A3%E8%A6%8F%E5%8C%96/",
                "title": "正規化",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル \\(|v\\rangle\\) について、もしノルム \\(\\|v\\rangle\\| = 1\\) ならば、\\(|v\\rangle\\) は正規化 (または規格化) されているという。ゼロでないベクトル \\(|v\\rangle\\) について \\(|v\\rangle / \\||v\\rangle\\|\\) は \\(|v\\rangle\\) を正規化した形。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405131650-%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4/",
                "title": "正規直交",
                "section": "post",
                "date" : "2021.04.05",
                "body": "インデックス \\(i\\) を持つベクトルの集合 \\(|i\\rangle\\) の各々が単位ベクトルであり、その集合のうち互いに異なるベクトルが直交しているとき、つまりインデックスの集合から選んだ \\(i\\) と \\(j\\) に対して \\(\\langle i|j \\rangle = \\delta_{ij}\\) のとき、集合 \\(|i\\rangle\\) は正規直交であるという。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210405112937-%E7%9B%B4%E4%BA%A4/",
                "title": "直交",
                "section": "post",
                "date" : "2021.04.05",
                "body": "ベクトル \\(|w\\rangle\\) とベクトル \\(|v\\rangle\\) の内積が \\(0\\) のとき両ベクトルは直交しているという。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402160012-qcqi_%E6%BC%94%E7%BF%92_2_1/",
                "title": "QCQI/演習 2.1",
                "section": "post",
                "date" : "2021.04.02",
                "body": "ベクトル \\((1, -1)\\), \\((1, 2)\\) および \\((2, 1)\\) は\n\\begin{equation} \\begin{bmatrix} 2 \\newline 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\newline {-1} \\end{bmatrix} + \\begin{bmatrix} 1 \\newline 2 \\end{bmatrix} \\end{equation}\nを満たすので、これら 3 つのベクトルは線形従属。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402160242-qcqi_%E6%BC%94%E7%BF%92_2_2/",
                "title": "QCQI/演習 2.2",
                "section": "post",
                "date" : "2021.04.02",
                "body": "\\(A\\) の行列表現 演算子は行列で表現できることから、\n\\[A|v_j\\rangle = \\sum_i A_{ij}|w_i\\rangle\\]\n\\(j = 1\\) のとき、\n\\begin{eqnarray} A|0\\rangle \u0026amp;=\u0026amp; \\sum_i A_{i1}|w_i\\rangle \\newline \u0026amp;=\u0026amp; A_{11}|0\\rangle + A_{21}|1\\rangle \\end{eqnarray}\n\\(j = 2\\) のとき、\n\\begin{eqnarray} A|1\\rangle \u0026amp;=\u0026amp; \\sum_i A_{i2}|w_i\\rangle \\newline \u0026amp;=\u0026amp; A_{12}|0\\rangle + A_{22}|1\\rangle \\end{eqnarray}\nこれらと \\(A|0\\rangle = |1\\rangle,\\ A|1\\rangle = |0\\rangle\\) より、\n\\(A_{11} = 0\\), \\(A_{21} = 1\\), \\(A_{12} = 1\\), \\(A_{22} = 0\\)\nよって \\(A\\) の行列表現は、\n\\begin{equation} A = \\begin{bmatrix} 0 \u0026amp; 1 \\newline 1 \u0026amp; 0 \\end{bmatrix} \\end{equation}\n\\(A\\) の異なる行列表現を与える入力と出力の基底 基底として次を選ぶ:\n\\begin{eqnarray} |+\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\newline |-\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle) \\end{eqnarray}\nここで \\(A|+\\rangle\\) と \\(A|-\\rangle\\) を計算すると、\n\\begin{eqnarray} A|+\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(A|0\\rangle + A|1\\rangle) \\newline \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(|1\\rangle + |0\\rangle) \\newline \u0026amp;=\u0026amp; |+\\rangle \\end{eqnarray}\n\\begin{eqnarray} A|-\\rangle \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(A|0\\rangle - A|1\\rangle) \\newline \u0026amp;=\u0026amp; \\frac{1}{\\sqrt{2}}(|1\\rangle - |0\\rangle) \\newline \u0026amp;=\u0026amp; -|-\\rangle \\end{eqnarray}\nこれらの結果と行列 \\(A\\) の要素 \\(A_{ij}\\) を求める式から、\n\\begin{eqnarray} A|+\\rangle \u0026amp;=\u0026amp; \\sum_i A_{i1}|w_i\\rangle \\newline \u0026amp;=\u0026amp; A_{11}|+\\rangle + A_{21}|-\\rangle \\newline \u0026amp;=\u0026amp; |+\\rangle \\end{eqnarray}\n\\begin{eqnarray} A|-\\rangle \u0026amp;=\u0026amp; \\sum_i A_{i2}|w_i\\rangle \\newline \u0026amp;=\u0026amp; A_{12}|+\\rangle + A_{22}|-\\rangle \\newline \u0026amp;=\u0026amp; -|-\\rangle \\end{eqnarray}\nよって \\(A_{11} = 1\\), \\(A_{21} = 0\\), \\(A_{12} = 0\\), \\(A_{22} = -1\\) となり、\\(A\\) の行列表現は\n\\begin{equation} A = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; -1 \\end{bmatrix} \\end{equation}\nとなるので、確かに異なる行列表現を持つ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402160643-qcqi_%E6%BC%94%E7%BF%92_2_3/",
                "title": "QCQI/演習 2.3",
                "section": "post",
                "date" : "2021.04.02",
                "body": "演算子は行列で表現できることから、演算子 \\(A\\), \\(B\\) とそれぞれの要素について次が成り立つ。\n\\begin{equation} A|v_j\\rangle = \\sum_i A_{ij}|w_i\\rangle \\end{equation}\n\\begin{equation} B|w_i\\rangle = \\sum_k A_{ki}|x_k\\rangle \\end{equation}\nここで線形変換 \\(BA\\) の行列表現は、\n\\begin{eqnarray} BA|v_j\\rangle \u0026amp;=\u0026amp; B(A|v_j\\rangle) \\newline \u0026amp;=\u0026amp; B(\\sum_i A_{ij}|w_i\\rangle) \\newline \u0026amp;=\u0026amp; \\sum_i A_{ij}\\sum_k B_{ki}|x_k\\rangle \\end{eqnarray}\nシグマの分解公式より\n\\begin{eqnarray} \\sum_i A_{ij}\\sum_k B_{ki}|x_k\\rangle = \\sum_i\\sum_k A_{ij}B_{ki}|x_k\\rangle \\end{eqnarray}\nさらに式変形していくと、\n\\begin{eqnarray} \\sum_i\\sum_k A_{ij}B_{ki}|x_k\\rangle \u0026amp;=\u0026amp; \\sum_k\\sum_i A_{ij}B_{ki}|x_k\\rangle \\newline \u0026amp;=\u0026amp; \\sum_k\\sum_i B_{ki}A_{ij}|x_k\\rangle \\newline \u0026amp;=\u0026amp; \\sum_k(\\sum_i B_{ki}A_{ij})|x_k\\rangle \\newline \u0026amp;=\u0026amp; \\sum_k(BA)_{kj}|x_k\\rangle \\end{eqnarray}\nとなり、これは \\(B\\) と \\(A\\) の行列表現の行列積である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402161917-qcqi_%E6%BC%94%E7%BF%92_2_4/",
                "title": "QCQI/演習 2.4",
                "section": "post",
                "date" : "2021.04.02",
                "body": "\\(V\\) の基底 \\(|v_1\\rangle, \\ldots, |v_m\\rangle\\) について、演算子は行列で表現できることから、\n\\begin{equation} I|v_j\\rangle = \\sum_i I_{ij}|v_i\\rangle \\end{equation}\nここで \\(I|v_i\\rangle = |v_i\\rangle\\ (i = 1, \\ldots, m)\\) なので、\n\\begin{equation} I_{ij}= \\begin{cases} 1 \u0026amp; (i = j) \\newline 0 \u0026amp; (otherwise) \\end{cases} \\end{equation}\nよって、\\(I\\) は対角成分が \\(1\\) で他がすべて \\(0\\) の行列表現 (単位行列) を持つ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402105729-quantum_computation_and_quantum_information/",
                "title": "Quantum Computation and Quantum Information",
                "section": "post",
                "date" : "2021.04.02",
                "body": "  演習の解答  QCQI/演習 2.1 QCQI/演習 2.2 QCQI/演習 2.3 QCQI/演習 2.4 QCQI/演習 2.5 QCQI/演習 2.6 QCQI/演習 2.7 QCQI/演習 2.8 QCQI/演習 2.9 QCQI/演習 2.10 QCQI/演習 2.11 QCQI/演習 2.12 QCQI/演習 2.13 QCQI/演習 2.14 QCQI/演習 2.15 QCQI/演習 2.16 QCQI/演習 2.17 QCQI/演習 2.18 QCQI/演習 2.19 QCQI/演習 2.20 QCQI/演習 2.21 QCQI/演習 2.22 QCQI/演習 2.23 QCQI/演習 2.24 QCQI/演習 2.25  先人達の解答  goropikari/SolutionQCQINielsenChuang Solutions: Quantum Computation and Quantum Information by Nielsen and Chuang QCQI Exercise Solutions (Index)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210402153637-%E3%82%B7%E3%82%AF%E3%83%9E%E3%81%AE%E5%88%86%E8%A7%A3%E5%85%AC%E5%BC%8F/",
                "title": "シグマの分解公式",
                "section": "post",
                "date" : "2021.04.02",
                "body": "分配法則 \\(a_1 b_1 + a_1 b_2 + a_2 b_1 + a_2 b_2 = (a_1 + a_2)(b_1 + b_2)\\) の一般化として、二重和について次の公式がある。\n\\begin{equation} \\sum_{i=1}^{m} \\sum_{j=1}^n a_i b_j = \\sum_{i=1}^m a_i \\sum_{j=1}^n b_j \\end{equation}\n証明 \\begin{eqnarray} \\sum_{i=1}^{m} \\sum_{j=1}^n a_i b_j \u0026amp;=\u0026amp; a_1 \\sum_{j=1}^n b_j + a_2 \\sum_{j=1}^n b_j + \\ldots + a_m \\sum_{j=1}^n b_j \\newline \u0026amp;=\u0026amp; (a_1 + a_2 + \\ldots + a_m) \\sum_{j=1}^n b_j \\newline \u0026amp;=\u0026amp; \\sum_{i=1}^m a_i \\sum_{j=1}^n b_j \\end{eqnarray}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401101150-%E6%81%92%E7%AD%89%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "恒等演算子",
                "section": "post",
                "date" : "2021.04.01",
                "body": "任意のベクトル空間 \\(V\\) における演算子のひとつで、すべてのベクトル \\(|v\\rangle\\) に対して \\(I_{V}|v\\rangle \\equiv |v\\rangle\\) で定義する。単位オペレータとも呼ぶ。ほとんどの場合、混乱が生じなければ下添字 \\(V\\) を省略して単に \\(I\\) と書く。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401105504-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%A8%E8%A1%8C%E5%88%97%E3%81%AF%E7%AD%89%E4%BE%A1/",
                "title": "演算子と行列は等価",
                "section": "post",
                "date" : "2021.04.01",
                "body": "行列は演算子とみなせることと、演算子は行列で表現できることから、演算子と行列は完全に等価。ただし演算子の行列表現で見たように、行列と演算子を関連付けるには、演算子の入力ベクトル空間の基底と出力空間の基底を指定しなければならない。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401102640-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%90%88%E6%88%90/",
                "title": "演算子の合成",
                "section": "post",
                "date" : "2021.04.01",
                "body": "\\(V\\), \\(W\\), および \\(X\\) がベクトル空間であり、\\(A: V \\rightarrow W\\) と \\(B: W \\rightarrow X\\) が演算子であるとする。このとき \\(A\\) と \\(B\\) の合成を記号 \\(BA\\) で表し、\\((BA)(|v\\rangle) \\equiv B(A|v\\rangle)\\) で定義する。\n演算子と行列は等価なので、\\((BA)(|v\\rangle)\\) は括弧を省略して \\(BA|v\\rangle\\) と書ける。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401104202-%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AF%E8%A1%8C%E5%88%97%E3%81%A6%E8%A1%A8%E7%8F%BE%E3%81%A6%E3%81%8D%E3%82%8B/",
                "title": "演算子は行列で表現できる",
                "section": "post",
                "date" : "2021.04.01",
                "body": "\\(A: V \\rightarrow W\\) がベクトル空間 \\(V\\) と \\(W\\) との間の演算子であるとする。さらに \\(V\\) の基底が \\(|v_1\\rangle, \\ldots, |v_m\\rangle\\), \\(W\\) の基底が \\(|w_1\\rangle, \\ldots, |w_n\\rangle\\) であるとする。\\(1, \\ldots, m\\) の範囲の各 \\(j\\) に対して、\n\\[A|v_j\\rangle = \\sum_i A_{ij}|w_i\\rangle\\]\nを満たす複素数 \\(A_{1j}, \\ldots, A_{nj}\\) が存在する。要素 \\(A_{ij}\\) をもつ行列 \\(A\\) を演算子 \\(A\\) の行列表現と呼び、よって演算子は行列で表現できる。\n参照  Quantum Computation and Quantum Information  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401101005-%E7%B7%9A%E5%BD%A2%E3%82%AA%E3%83%98%E3%83%AC%E3%83%BC%E3%82%BF/",
                "title": "線形オペレータ",
                "section": "post",
                "date" : "2021.04.01",
                "body": "演算子を参照\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401103405-%E8%A1%8C%E5%88%97%E3%81%AF%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%A8%E3%81%BF%E3%81%AA%E3%81%9B%E3%82%8B/",
                "title": "行列は演算子とみなせる",
                "section": "post",
                "date" : "2021.04.01",
                "body": "要素 \\(A_{ij}\\) を持つ \\(m \\times n\\) の複素行列 \\(A\\) は、行列 \\(A\\) と \\(\\mathbb{C}^n\\) とのベクトルとの行列積により、ベクトル空間 \\(\\mathbb{C}^n\\) からベクトル空間 \\(\\mathbb{C}^m\\) に移すので、行列 \\(A\\) は演算子である。\n正確には行列 \\(A\\) が演算子であるということは\n\\[A(\\sum_i a_i|v_i\\rangle) = \\sum_i a_i A(|v_i\\rangle)\\]\nが行列 \\(A\\) と列ベクトルの行列積で成り立つことを意味し、行列の性質からこれは明らかに正しい。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401105821-%E8%A1%8C%E5%88%97%E8%A1%A8%E7%8F%BE/",
                "title": "行列表現",
                "section": "post",
                "date" : "2021.04.01",
                "body": "参照: 演算子は行列で表現できる\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210401101830-%E9%9B%B6%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "零演算子",
                "section": "post",
                "date" : "2021.04.01",
                "body": "すべてのベクトルをゼロベクトルに移す演算子で、0 と書く。ゼロオペレータとも呼ぶ。\n\\[0|v\\rangle \\equiv 0\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210331111403-%E3%82%B9%E3%83%8F%E3%83%B3%E9%9B%86%E5%90%88/",
                "title": "スパン集合",
                "section": "post",
                "date" : "2021.03.31",
                "body": "ベクトル空間のスパン集合とは、その空間の任意のベクトル \\(|v\\rangle\\) が線形結合 \\(|v\\rangle = \\sum_{i}a_i|v_i\\rangle\\) で表せるようなベクトル集合 \\(|v_1\\rangle, \\ldots, |v_n\\rangle\\) のこと。\nたとえば、ベクトル空間 \\(\\mathbb{C}^2\\) のスパン集合は、\n\\begin{equation} |v_1\\rangle \\equiv \\begin{bmatrix} 1 \\newline 0 \\end{bmatrix};~ |v_2\\rangle \\equiv \\begin{bmatrix} 0 \\newline 1 \\end{bmatrix} \\end{equation}\nという集合になる。なぜなら \\(\\mathbb{C}^2\\) の任意のベクトル\n\\begin{equation} |v\\rangle = \\begin{bmatrix} a_1 \\newline a_2 \\end{bmatrix} \\end{equation}\nはベクトル \\(|v_1\\rangle\\) と \\(|v_1\\rangle\\) の線形結合 \\(|v\\rangle = a_1|v_1\\rangle + a_2|v_2\\rangle\\) で書けるから。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210331121800-%E5%9F%BA%E5%BA%95/",
                "title": "基底",
                "section": "post",
                "date" : "2021.03.31",
                "body": "ベクトル空間 \\(V\\) の元の集合 \\(|v_1\\rangle, \\ldots, |v_n\\rangle\\) が次の 2 つの性質をみたすとき、これを \\(V\\) の基底と呼ぶ。\n \\(|v_1\\rangle, \\ldots, |v_n\\rangle\\) は線形独立 \\(V\\) の任意の元は \\(|v_1\\rangle, \\ldots, |v_n\\rangle\\) の線形結合で表せる  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210331122717-%E6%AC%A1%E5%85%83/",
                "title": "次元",
                "section": "post",
                "date" : "2021.03.31",
                "body": "ベクトル空間 \\(V\\) の基底の要素の数を次元と呼び、\\(dimV\\) と表す。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210331120144-%E7%B7%9A%E5%BD%A2%E5%BE%93%E5%B1%9E/",
                "title": "線形従属",
                "section": "post",
                "date" : "2021.03.31",
                "body": "\\(0\\) でないベクトル \\(|v_1\\rangle, \\ldots, |v_n\\rangle\\) について、少なくとも 1 つの \\(i\\) に対して \\(a_i \\neq 0\\) であり、\n\\[a_1|v_1\\rangle + a_2|v_2\\rangle + \\ldots + a_n|v_n\\rangle = 0\\]\nを満たす複素数の集合 \\(a_1, \\ldots, a_n\\) が存在するならば、ベクトル \\(|v_1\\rangle, \\ldots, |v_n\\rangle\\) は線形従属であるという。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210331120821-%E7%B7%9A%E5%BD%A2%E7%8B%AC%E7%AB%8B/",
                "title": "線形独立",
                "section": "post",
                "date" : "2021.03.31",
                "body": "\\(0\\) でないベクトルの集合 \\(|v_1\\rangle, \\ldots, |v_n\\rangle\\) が線形従属でなければ、それは線形独立であるという。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330141705-%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC%E5%80%8D%E6%BC%94%E7%AE%97/",
                "title": "スカラー倍演算",
                "section": "post",
                "date" : "2021.03.30",
                "body": "ベクトル空間上の演算の一つ。\\(\\mathbb{C}^n\\) 空間では次式で定義される。\n\\begin{equation} z \\begin{bmatrix} z_1 \\newline \\vdots \\newline z_n \\end{bmatrix} \\equiv \\begin{bmatrix} zz_1 \\newline \\vdots \\newline zz_n \\end{bmatrix} \\end{equation}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330142839-%E3%82%BB%E3%83%AD%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/",
                "title": "ゼロベクトル",
                "section": "post",
                "date" : "2021.03.30",
                "body": "あるベクトル空間について、任意のベクトル \\(|v\\rangle\\) に対して \\(|v\\rangle + |\\theta\\rangle = |v\\rangle\\) を満たすベクトル \\(|\\theta\\rangle\\) をゼロベクトルと呼び、\\(0\\) で表す。\nつまり、ゼロベクトルはベクトル空間の零元である。\nちなみになぜ \\(|0\\rangle\\) と書かないかと言うと、\\(|0\\rangle\\) は通常基底状態のひとつ \\begin{bmatrix}1 \\\\ 0 \\end{bmatrix} を表すのに使うから。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330140009-%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/",
                "title": "ベクトル",
                "section": "post",
                "date" : "2021.03.30",
                "body": "次のような数の組をベクトルと呼ぶ。\n\\[\\begin{bmatrix} z_1 \\\\\\\n\\vdots \\\\\\\nz_n \\end{bmatrix}\\]\n量子力学的な慣用記号では、\\(\\psi\\) をラベルとしてベクトルを\n\\[|\\psi\\rangle\\]\nと表す。\nベクトルはベクトル空間の要素 (元) である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330135536-%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB%E7%A9%BA%E9%96%93/",
                "title": "ベクトル空間",
                "section": "post",
                "date" : "2021.03.30",
                "body": "定義 集合 \\(V\\) に和演算とスカラー倍演算があり、\\(V\\) の任意の元 \\(|\\psi\\rangle\\) と \\(|\\phi\\rangle\\) が次の 8 つの性質を満たすとき \\(V\\) をベクトル空間 (または、線形空間) と呼ぶ。\n和の性質  交換則 \\(|\\psi\\rangle + |\\phi\\rangle = |\\phi\\rangle + |\\psi\\rangle\\) 結合則 \\(|\\psi\\rangle + (|\\phi\\rangle + |\\xi\\rangle) = (|\\psi\\rangle + |\\phi\\rangle) + |\\xi\\rangle\\) 零元の存在 \\(\\exists1\\ |\\theta\\rangle \\in V\\ s.t.\\ \\forall|\\psi\\rangle \\in V,\\ |\\psi\\rangle + |\\theta\\rangle = |\\psi\\rangle\\) 逆元の存在 \\(\\forall|\\psi\\rangle \\in V,\\ \\exists1\\ |\\xi\\rangle \\in V\\ s.t.\\ |\\psi\\rangle + |\\xi\\rangle = |\\theta\\rangle\\)  スカラー倍の性質  単位元の存在 \\(1\\cdot|\\psi\\rangle = |\\psi\\rangle\\) 結合則 \\(a\\cdot(b\\cdot |\\psi\\rangle) = (ab)\\cdot|\\psi\\rangle\\) 分配則 1 \\(a\\cdot(|\\psi\\rangle + |\\phi\\rangle) = a\\cdot|\\psi\\rangle + a\\cdot|\\phi\\rangle\\) 分配則 2 \\((a + b)\\cdot|\\psi\\rangle = a\\cdot|\\psi\\rangle + b\\cdot|\\psi\\rangle\\)  具体例  実数全体 \\(\\mathbb{R}\\) からなるベクトル空間 複素数全体 \\(\\mathbb{C}\\) からなるベクトル空間 \\(n\\) 次元実数ベクトル全体 \\(\\mathbb{R}^n\\) からなるベクトル空間 \\(n\\) 次元複素ベクトル全体 \\(\\mathbb{C}^n\\) からなるベクトル空間 2 次の正方行列全体からなるベクトル空間 実数関数 \\(f(x)\\) のすべてからなるベクトル空間 ゼロベクトルからのみなるベクトル空間  このようにさまざまなものがベクトル空間を作れることに注意。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330140453-%E5%92%8C%E6%BC%94%E7%AE%97/",
                "title": "和演算",
                "section": "post",
                "date" : "2021.03.30",
                "body": "2 つのベクトルの組を 1 つのベクトルに変換する演算。\nベクトル空間 \\(\\mathbb{C}^n\\) ではベクトルの和演算は次式で定義する。\n\\begin{equation} \\begin{bmatrix} z_1 \\\\\\\n\\vdots \\\\\\\nz_n \\end{bmatrix} + \\begin{bmatrix} z^{\\prime}_1 \\\\\\\n\\vdots \\\\\\\nz^{\\prime}_n \\end{bmatrix} \\equiv \\begin{bmatrix} z_1 + z^{\\prime}_1 \\\\\\\n\\vdots \\\\\\\nz_n + z^{\\prime}_n \\end{bmatrix} \\end{equation}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210330134827-%E6%BC%94%E7%AE%97%E5%AD%90/",
                "title": "演算子",
                "section": "post",
                "date" : "2021.03.30",
                "body": "量子論では、状態ベクトルに対する線形変換のことを演算子またはオペレータ (operator) と呼ぶ。数学の分野では同じ用語 operator を作用素と訳すので注意。\n演算子は、入力に対して線形な任意の関数 A として次のように定義できる。\n\\[A(\\sum_i a_i|v_i\\rangle) = \\sum_i a_i A(|v_i\\rangle)\\]\n重要な演算子  恒等演算子 零演算子  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210224132528-doom_emacs/",
                "title": "Doom Emacs",
                "section": "post",
                "date" : "2021.03.29",
                "body": "Emacs の設定フレームワークの一種。その他の設定フレームワークとしては Spacemacs などもあるが、Doom Emacs はパッケージの安定度が高く、起動が早いという特長がある。\n関連ノート  Effective Emacs  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210324153839-effective_emacs/",
                "title": "Effective Emacs",
                "section": "post",
                "date" : "2021.03.29",
                "body": "https://sites.google.com/site/steveyegge2/effective-emacs\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210327132024-emacs/",
                "title": "Emacs",
                "section": "post",
                "date" : "2021.03.29",
                "body": "私が大学以来メインで使っているエディタ。\nEmacs に関連して主に使っているツールはこちら::\n Doom Emacs 設定フレームワーク Org Mode 設定ファイルを文芸的プログラミングぽく書くのに使用 Org-Roam 普段のメモやノート全般を書くのに使用。このデジタル・ガーデンは Org-Roam から Hugo に変換している  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210329095350-org_transclusion/",
                "title": "org-transclusion",
                "section": "post",
                "date" : "2021.03.29",
                "body": "Org Mode で Roam Research 的なブロック参照を行うためのパッケージ。\nOrg-Roam で書いたノートの一部を、他のノートや Doom Emacs の config.org から参照したくなったので導入。\n設定 ~/.doom.d/packages.el の設定\n(package! org-transclusion :recipe (:host github :repo \u0026#34;nobiot/org-transclusion\u0026#34; :branch \u0026#34;main\u0026#34;)) ~/.doom.d/config.el の設定\n(use-package! org-transclusion :hook (org-roam-mode . org-transclusion-mode)) リンク  nobiot/org-transclusion  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210329114625-%E3%82%A8%E3%83%AB%E3%83%9F%E3%83%BC%E3%83%88%E5%85%B1%E5%BD%B9/",
                "title": "エルミート共役",
                "section": "post",
                "date" : "2021.03.29",
                "body": "転置共役の別名。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210329140322-%E3%82%A8%E3%83%AB%E3%83%9F%E3%83%BC%E3%83%88%E8%A1%8C%E5%88%97/",
                "title": "エルミート行列",
                "section": "post",
                "date" : "2021.03.29",
                "body": "複素行列 \\(A\\) とそのエルミート共役 \\(A^{\\dagger}\\) について \\(A^{\\dagger} = A\\) を満たすとき、行列 \\(A\\) をエルミート行列と呼ぶ。\nその性質からエルミート行列の対角成分は実数であり、かつ、対角線に関して対称な位置にある成分は互いに共役な複素数となる。\n2 次のエルミート行列の例\n\\[A = \\begin{bmatrix} 3 \u0026amp; 1 + i \\\\\\\n1 -i \u0026amp; -2 \\end{bmatrix}\\]\n3 次のエルミート行列の例\n\\[A = \\begin{bmatrix} 1 \u0026amp; i \u0026amp; 2-i \\\\\\\n-i \u0026amp; 2 \u0026amp; -3i \\\\\\\n2+i \u0026amp; 3i \u0026amp; -1 \\end{bmatrix}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210329160516-%E5%85%B1%E5%BD%B9/",
                "title": "共役",
                "section": "post",
                "date" : "2021.03.29",
                "body": "2 つのものがセットになって結びついていること、同様の働きをすること。もともと共軛と書き、「軛」(くびき) は、人力車や馬車において 2 本の梶棒 (かじぼう) を結びつけて同時に動かすようにするための棒のこと。\n数学では、二つの角・線・点・図形・数などが互いに対称的あるいは相補的関係にあり、入れ換えてもその関係に変化のないこと。\n「軛」が常用漢字表外であったため、音読みの同じ「役」の字で代用され、現在では共役と書かれることが多い。\n    関連ノート  エルミート共役  Source  共役 (Weblio) 共役 (Wikipedia) 人力車の各パーツの呼び方知ってる？  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210329133439-%E9%96%93%E9%9A%94%E5%8F%8D%E5%BE%A9%E8%A8%98%E6%86%B6%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/",
                "title": "間隔反復記憶システム",
                "section": "post",
                "date" : "2021.03.29",
                "body": "実装  Supermemo Anki Mnemosyne Execute Program  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210223202810-anki_editor/",
                "title": "anki-editor",
                "section": "post",
                "date" : "2021.03.27",
                "body": "Org Mode や Org-Roam で書いたノートから Anki カードを生成するためのパッケージ。\n参考  louietan/anki-editor  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210327120037-deft/",
                "title": "Deft",
                "section": "post",
                "date" : "2021.03.27",
                "body": "https://github.com/jrblevin/deft\nEmacs を Notational Velocity 的に使うためのパッケージ。Org Mode や Org-Roam のノート一覧をファイル内容も含めてインクリメンタルサーチできるのが便利。ただし SKK が使えないので日本語が使えない。なんとかしたいところ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210224155908-qni/",
                "title": "Qni",
                "section": "post",
                "date" : "2021.03.27",
                "body": "ブラウザ上で動く量子回路シミュレータ。初心者が量子コンピュータをライブプログラミングで直感的に学べる環境を目指している。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210310110827-%E5%9C%8F%E8%AB%96%E7%9A%84%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E5%85%A5%E9%96%80/",
                "title": "圏論的量子力学入門",
                "section": "post",
                "date" : "2021.03.27",
                "body": "https://www.morikita.co.jp/books/book/3316\n関連ノート  量子コンピュータ 図式的線形代数  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323114201-assoc/",
                "title": "Assoc",
                "section": "post",
                "date" : "2021.03.23",
                "body": "Assoc は Associativity (結合性) の略。図式的線形代数では足し算を扱うので、単に Assoc と書いた場合それは足し算の結合性を表す。\n図式で足し算の結合性を表すと次のようになる。\n  これが正しいことは、変数 \\(x\\), \\(y\\), \\(z\\) を使うことで次のように示せる。\nAssoc の左辺に \\(x\\), \\(y\\), \\(z\\) を入力すると、\n  Assoc の右辺に \\(x\\), \\(y\\), \\(z\\) を入力すると、\n  ここで足し算の結合性より \\((x + y) + z = x + (y + z)\\) だから、\n  が成り立つ。\n参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323094041-identity/",
                "title": "Identity",
                "section": "post",
                "date" : "2021.03.23",
                "body": "図式的線形代数で一本の結線をアイデンティティ (identity) と呼ぶ。\n  入力は 1 つ、出力も同じく 1 つなので \\((1, 1)\\) である。\n参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323095806-twist/",
                "title": "Twist",
                "section": "post",
                "date" : "2021.03.23",
                "body": "図式的線形代数で交差する二本の結線をツイスト (twist) と呼ぶ。\n  入力は 2 つ、出力も同じく 2 つなので \\((2, 2)\\) である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323090747-unit/",
                "title": "Unit",
                "section": "post",
                "date" : "2021.03.23",
                "body": "ゼロジェネレータ (Zero) の振舞いから、図式的線形代数における次の単位元 (identity element) 方程式に辿り着く。右辺は Identity。\n  なぜこうなるかは、次のようにワイヤに 0 と変数を振ってみれば分かりやすい。\n  参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323084442-zero/",
                "title": "Zero",
                "section": "post",
                "date" : "2021.03.23",
                "body": "ゼロは加法の単位元。語源は、位取り筆算をヨーロッパに紹介したフィボナッチがゼロを zephryum と呼んだことに由来する。\nゼロを図式的線形代数で表すと、次のジェネレータになる。\n  参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323110948-%E5%9B%B3%E5%BC%8F%E3%81%AE%E5%90%88%E6%88%90/",
                "title": "図式の合成",
                "section": "post",
                "date" : "2021.03.23",
                "body": "図式の合成では、次のように第 1 引数の右に第 2 引数を置いて結線同士をつなげる:\n  合成のルールを式で書くと次の通り:\n  参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210323102643-%E5%9B%B3%E5%BC%8F%E3%81%AE%E7%9B%B4%E5%92%8C/",
                "title": "図式の直和",
                "section": "post",
                "date" : "2021.03.23",
                "body": "図式の直和では、次のように第 1 引数を第 2 引数の上に重ねる:\n  直和のルールを式で書くと次の通り:\n  下の Identity を曲げているが、これは曲げても曲げなくても良い。図式の重要な情報はルールからも明らかなように、\n 左から右に向かって何が何につながっているか 上から下に向かってどの順番でジェネレータが並んでいるか  なので、それを変えなければ結線を曲げても良い。\nもちろん、直和は可換でないことに注意。\n  参考  Graphical Linear Algebra  5. Spoilers, Adding (Part 2) and Zero    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210322140545-comm/",
                "title": "Comm",
                "section": "post",
                "date" : "2021.03.22",
                "body": "Comm は Commutativity (可換性) の略。図式的線形代数では足し算を扱うので、単に Comm と書いた場合それは足し算の可換性を表す。\n図式で足し算の可換性を表すと次のようになる。\n  これが正しいことは、変数 \\(x\\), \\(y\\) を使うことで次のように示せる。\nComm の左辺に \\(x\\) と \\(y\\) を入力すると、\n  Comm の右辺に \\(x\\) と \\(y\\) を入力すると、\n  ここで足し算の可換性より \\(x + y = y + x\\) だから、\n  が成り立つ。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210322104014-%E5%9B%B3%E5%BC%8F%E7%9A%84%E7%B7%9A%E5%BD%A2%E4%BB%A3%E6%95%B0/",
                "title": "図式的線形代数",
                "section": "post",
                "date" : "2021.03.22",
                "body": "グラフィカル (図式的) に線形代数を計算する方法を説明したブログ。\nhttps://graphicallinearalgebra.net/\n ジェネレータ  Identity Twist Zero   方程式  Comm Assoc   演算  図式の直和 図式の合成    "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210320155430-void/",
                "title": "void",
                "section": "post",
                "date" : "2021.03.20",
                "body": "return 文を含まない関数の戻り値の型はなんでしょうか?\nTypeScript では、そういう関数の戻り値の型は void です。あえて型エラーを起こしてエラーメッセージを見ればわかります。\nfunction f() { } const n: number = f(); // → type error: Type \u0026#39;void\u0026#39; is not assignable to type \u0026#39;number\u0026#39;. void の使いみちは、明示的に何も返さない関数を表現したい場合です。たとえば console.log はその一例です。\nvoid 型は、値を一切持たないことを示します。他の多くの静的言語では、例外はなく、 void は本当に値を持つことはできません。しかし、TypeScript では不思議なことに、 void 型の変数を作ることができます。この変数には undefined という値しか入りません。\nconst aVoid: void = undefined; // → undefined だからといって、その void を undefined 型の変数に代入できるわけではありません。 void は何にも代入できないので、型エラーになります。\nconst aVoid: void = undefined; const u: undefined = aVoid; // → type error: Type \u0026#39;void\u0026#39; is not assignable to type \u0026#39;undefined\u0026#39;. 実際には、 void 型の変数に出会うことはないでしょう。しかし、多くの void 関数を目にすることになるでしょう。なぜなら、戻り値のない関数は自動的に void と推論されるからです。\n参考  void (Execute Program)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210320161559-%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF%E5%AD%A6%E7%BF%92%E3%81%AE_srs_%E5%8C%96/",
                "title": "プログラミング学習の SRS 化",
                "section": "post",
                "date" : "2021.03.20",
                "body": "SRS の回答方式による効果の違いを確認するために、Execute Program を参考にいくつかレッスンを作り、Anki カードを起こしてみる。\n  void never  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210319115727-anki/",
                "title": "Anki",
                "section": "post",
                "date" : "2021.03.19",
                "body": "人気の間隔反復記憶システムのひとつ。オープンソースとして開発されており、ソースコードは ankitects/anki から取得できる。\nリンク  ホームページ https://apps.ankiweb.net/ ドキュメント https://docs.ankiweb.net/ 共有デッキ https://ankiweb.net/shared/decks/  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210319132742-duolingo/",
                "title": "Duolingo",
                "section": "post",
                "date" : "2021.03.19",
                "body": "https://en.duolingo.com/\n世界で最も人気のある外国語学習サービス。単語や文法の学習に SRS を採用している。\nSRS として見たときの Duolingo のユニークな点 (たとえばExecute Program との違い) は、すべての学習がカードのみで完結しているところ。Execute Program ではプログラミング言語の解説を読みながらクイズに答えていく。一方で Duolingo では外国語に対する知識ゼロの状態からいきなりクイズが始まり、正解/不正解を繰り返しながら (試行錯誤を繰り返しながら) 外国語を学んでいくことができる。\n外国語学習の場合、文法や単語の説明を読むのはダルい/集中力が続かないという人が圧倒的に多いはずなので、正式な学習法と比べてどのくらい効果があるかどうかは分からないが、ひとつの妥当なデザインチョイスだと思う。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210319113717-srs_%E3%81%AE%E5%9B%9E%E7%AD%94%E6%96%B9%E5%BC%8F%E3%81%AB%E3%82%88%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%AE%E9%81%95%E3%81%84/",
                "title": "SRS の回答方式による効果の違い",
                "section": "post",
                "date" : "2021.03.19",
                "body": "SRS のユーザ回答方式には、Anki のようにユーザが裏面を見て自分で答合わせをする方式と、Duolingo や Execute Program のようにユーザが入力した答をシステムが答合わせする方式の 2 つがある。どちらが記憶効果が高いだろうか？\nこの論文 (Probabilistic Models of Student Learning and Forgetting) では実験から次のことを導き出している:\n ひとつひとつの単体のレビューの効果については、ユーザが入力する方式の方が効果が高い 長期的な効果については、入力のためのタイピングにはかなり時間がかかるため、自分で答合わせをする方式のほうがレビューを多くこなせ、結果的に効果が高くなる  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210318110047-never/",
                "title": "never",
                "section": "post",
                "date" : "2021.03.18",
                "body": "関数の中には、決して戻らないものがあります。例えば、常に例外を投げる関数は決して戻りません。\n// この関数は戻らない function throws() { throw new Error(\u0026#39;oh no\u0026#39;); } この関数の戻り値の型はどうすればよいでしょうか？ TypeScript は、この関数の戻り値の型を void と推論します。しかし、それではコードで何が起こっているのかをコンパイラは完全には把握できていません。\nvoid 型は、何らかの処理を行い終了するが、値を返さない関数のための型です。上の関数はこれとは異なり、この関数を呼び出しても、その後のコードは全く実行されません。\n幸いなことに、TypeScript にはそのための型があります: never です。\n// 戻らない関数の返り値は never と指定する function throws(): never { throw new Error(\u0026#39;oh no\u0026#39;); } never 型はちょっと不思議です。他のどの型にも割り当て可能です1。例えば、 number 型の変数に割り当てることができます (ただし、実行すると例外が投げられます)。\nfunction throws(): never { throw new Error(\u0026#39;oh no\u0026#39;); } // never はどんな型にも割り当てられる const n: number = throws(); // → Error: oh no 最初は、 never が any のように振る舞っているように見えます。なぜなら、 never を number （または string 、その他何でも）に割り当てることができるからです。しかし、 any と違って、これは安全です。\nコンパイラは throws 関数が決して戻らないことを知っているので、変数 n には何も代入されないことも知っています。型は実行時にデータが正しいことを保証するために存在します。もし、実行時に代入が実際に行われることがなく、コンパイラが事前にそのことを確実に知っているのであれば、 never を代入する変数の型は重要ではありません。\nしかし、 never に他の型を割り当てることはできません。そうすると、 never のルールである「実際に値を保持することはない」を破ってしまいます。 never に何らかの値を代入しようとすると、常に型エラーになります。\n// never には何も割り当てられない const aNever: never = 5; // → type error: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;never\u0026#39;. 絶対に never には何も割り当てられません。 any ですらも!\nconst anAny: any = 5; // never には any ですら割り当てられない const aNever: never = anAny; // → type error: Type \u0026#39;any\u0026#39; is not assignable to type \u0026#39;never\u0026#39;. 関数が常に例外をスローするが、明示的な戻り値の型を持たない場合、TypeScript は戻り値の型を void と推論します。これは悪いことではありませんが、明示的に never とマークしたほうが、TypeScript にもう少し多くの情報を与えることができます。\n例えば、ある関数が never を返す別の関数を呼び出したとします。TypeScript は外側の関数の型も never と正しく推論します。\nfunction throws(): never { throw new Error(\u0026#39;oh no\u0026#39;); } // この戻り値の型は never と推論される function alsoThrows() { return throws(); } // never は number に割り当てることができる const n: number = alsoThrows(); このコードがコンパイルされたことで、 alsoThrows の戻り値の型が never であることがわかりました。もし戻り値の型が void であれば、数値に割り当てることはできません。\n次の関数の戻り値の型を never に変更するとどうなるでしょうか。結果は型エラーが発生します。なぜなら、この関数は戻るからです。TypeScript は never 関数が値を返すことを許可しません。\nfunction f(): number { return 5; } 戻り値を never に変更すると:\nfunction f(): never { return 5; } // → type error: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;never\u0026#39;. TypeScript では、 never 関数が条件付きで戻ることもできません（例: if の中）。関数が値を返す方法があるならば、その戻り値の型は never であってはならないのです。(この関数は型エラーを発生させます)\nfunction forcePositive(x: number): never { if (x \u0026gt; 0) { // 型エラー  return x; } else { throw new Error(\u0026#39;Number was negative!\u0026#39;); } } // → type error: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;never\u0026#39;. never 型が適用されるのは、例外を発生させる関数だけではありません。例えば、無限ループを持つ関数は、 never 型の戻り値を持つことができます（そうすべきです！）。\n残念ながら、ここではその動く実例を示すことはできません。なぜなら、それは決して終了しないからです。しかし、その逆の例を示すことはできます。つまり、無限ループのように見える関数で、絶対に終わらないと主張していますが、時々戻ってくることがあるようなものです。これは型エラーです。\nfunction f(): never { while (true) { // 型エラー  if (Math.random() \u0026lt; 0.000001) { break; } } } // → type error: A function returning \u0026#39;never\u0026#39; cannot have a reachable end point. never 型の代表的なユースケースとして網羅性チェックがあります。到達不能な部分で never を返す関数を呼び出すことで、実行時エラーをチェックできます。\nfunction fail(message: string): never { throw new Error(message); } function foo(x: string | number): boolean { if (typeof x === \u0026#34;string\u0026#34;) { return true; } else if (typeof x === \u0026#34;number\u0026#34;) { return false; } // never 型のない言語では、次のいずれかでエラーになる  // - すべてのコードパスで値を返していない (厳密な null チェック)  // - または、到達不能コードの検出  // しかし TypeScript は fail 関数が never を返すことを知っているので、  // プログラマは実行時の安全性/網羅性チェックのために fail を呼び出すことができる  return fail(\u0026#34;Unexhaustive!\u0026#34;); } 最後に、 void と never について簡単にまとめておきます。\nvoid は、関数が最終的に終了して戻ることを意味します。単に、何の値も返さないということです。関数には return 文がないか、または return 文の後に値がない状態になっています。 void 型は、値がないことを表すので、何にも代入できません。\nnever は、関数が決して正常に終了しないことを意味します。例外が発生したり、無限ループに陥ったりするかもしれません。Node のようなサーバーサイドのシステムであれば、 process.exit() を呼び出してプロセスを終了させるかもしれません。いずれにしても、実行が関数の最後に到達することはありません。 never 型は何にでも代入可能です。なぜならコンパイラは、実行時には実際には代入が行われないことを知っているからです。\n参考  never (Execute Program)    never はすべての型のサブタイプ (派生型) であり、これをボトム型 (bottom type) と呼ぶ。つまり、他のすべての型に割り当てることができ、 never 型の値はどこでも安全に使えるという意味である。理論的な意味としては、ボトム型は値を持たない型としてとらえることができ、常に偽である数学的命題に相当する。 \u0026#x21a9;\u0026#xfe0e;\n   "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210318171123-%E3%83%86%E3%82%B7%E3%82%BF%E3%83%AB_%E3%82%AB%E3%83%BC%E3%83%86%E3%83%B3/",
                "title": "デジタル・ガーデン",
                "section": "post",
                "date" : "2021.03.18",
                "body": "個人的なメモをインターネット上に公開したもの。多くの場合はメモ間にリンクが貼ってあり、Wiki のように関連するメモを読むことができる。\n一般的な作り方としては、Roam Research や Obsidian といった個人用のメモツールで書いたメモを外部ツールでインターネット上に公開する場合が多い。\n MaggieAppleton/digital-gardeners デジタル・ガーデン用ツール、作りかたチュートリアル、各種ノート法などの基礎知識、個別のデジタル・ガーデンサイトへのリンク集 Andyʼs working notes デジタル・ガーデン流行の火付け役となったサイトであり、多くの人がお手本にしている Andy Matuschak のサイト 効率的なノートを作成できるドイツの社会学者が生み出した方法「Zettelkasten」とは？ ノート法の一種で、多くのデジタル・ガーデンはこの方法に則って書かれている  関連ノート  保存版メモの数  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210317113230-%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC%E8%A1%8C%E5%88%97/",
                "title": "スカラー行列",
                "section": "post",
                "date" : "2021.03.17",
                "body": "単位行列の定数倍をスカラー行列という。\nたとえば、\n\\[\\begin{bmatrix} \\lambda \u0026amp; 0 \u0026amp; 0 \\\\\\\n0 \u0026amp; \\lambda \u0026amp; 0 \\\\\\\n0 \u0026amp; 0 \u0026amp; \\lambda \\end{bmatrix}\\]\nはスカラー行列である。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210317101558-%E5%AF%BE%E8%A7%92%E8%A1%8C%E5%88%97/",
                "title": "対角行列",
                "section": "post",
                "date" : "2021.03.17",
                "body": "\\(n\\) 次正方行列で、その対角線上にない成分がすべて \\(0\\) である行列のこと。\n\\[\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\\\\n0 \u0026amp; 2 \u0026amp; 0 \\\\\\\n0 \u0026amp; 0 \u0026amp; -1 \\end{bmatrix}\\]\n注意点として、行列の対角線は右下がりのもののみを言う。右上がりのものは対角線とは呼ばない。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210317105154-%E6%AD%A3%E6%96%B9%E8%A1%8C%E5%88%97/",
                "title": "正方行列",
                "section": "post",
                "date" : "2021.03.17",
                "body": "\\(m \\times m\\) 行列は正方形状に成分が並ぶので \\(m\\) 次正方行列と呼ぶ。\n\\(2\\) 次正方行列の例\n\\[\\begin{bmatrix} 1 \u0026amp; 2 \\\\\\\n2 \u0026amp; -1 \\end{bmatrix}\\]\n\\(3\\) 次正方行列の例\n\\[\\begin{bmatrix} -1 \u0026amp; 2 \u0026amp; 3 \\\\\\\n1 \u0026amp; 1 \u0026amp; 0 \\\\\\\n2 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210311082809-%E3%83%86%E3%82%A3%E3%83%A9%E3%83%83%E3%82%AF%E8%A8%98%E6%B3%95/",
                "title": "ディラック記法",
                "section": "post",
                "date" : "2021.03.11",
                "body": "ディラック記法は、物理学者ポール・ディラックがとくに量子論を記述する目的で導入した記法。量子論のほとんどの教科書で今日でも使われている。\n   名前 記号     ディラックのケット (ket) \\(\\vert{}\\psi\\rangle\\)   ディラックのブラ (bra) \\(\\langle\\pi\\vert{}\\)   ディラックのブラケット (braket) \\(\\langle\\pi\\vert{}\\psi\\rangle\\)    Quantum Computation and Quantum Information によると、量子力学の難しさの原因はそれ自体が難しいというわけではなく、ディラック記法やそのほか物理学特有の記号がたくさんあることにあるようだ。\n 量子力学の公理の理解を阻む主な要因は公理それ自体にあるのではなく、それを理解するのに必要な線形代数の表記法の多さにある。物理学者が量子力学に用いている見慣れない Dirac の表記法と相まって、それは (間違って) とても恐ろしい印象を与える。\n 量子力学で用いる標準的な慣用記号のまとめ    記号 意味     \\(z^{\\ast}\\) 複素数 \\(z\\) の複素共役。\\((1 + i)^{\\ast} = 1 - i\\)   \\(\\vert{}\\psi\\rangle\\) ベクトル。ケット (ket) とも呼ばれる。   \\(\\langle\\psi\\vert{}\\) \\(\\vert{}\\psi\\rangle\\) に双対 (dual) なベクトル。ブラ (bra) とも呼ばれる   \\(\\langle\\varphi\\vert{}\\psi\\rangle\\) \\(\\vert{}\\varphi\\rangle\\) と \\(\\vert{}\\psi\\rangle\\) の内積   \\(\\vert{}\\varphi\\rangle \\otimes \\vert{}\\psi\\rangle\\) \\(\\vert{}\\varphi\\rangle\\) と \\(\\vert{}\\psi\\rangle\\) のテンソル積   \\(\\vert{}\\varphi\\rangle\\vert{}\\psi\\rangle\\) \\(\\vert{}\\varphi\\rangle\\) と \\(\\vert{}\\psi\\rangle\\) のテンソル積に対する簡略記号   \\(A^{\\ast}\\) 行列 \\(A\\) の複素共役   \\(A^T\\) 行列 \\(A\\) の転置   \\(A^{\\dagger}\\) 行列 \\(A\\) のエルミート共役   \\(\\langle\\varphi\\vert{}A\\vert{}\\psi\\rangle\\) \\(\\vert{}\\varphi\\rangle\\) と \\(A\\vert{}\\psi\\rangle\\) の内積。\\(A^{\\dagger}\\vert{}\\varphi\\rangle\\) と \\(\\vert{}\\psi\\rangle\\) の内積に等しい。    参考文献  P. A. M. Dirac (1939). A new notation for quantum mechanics. Mathematical Proceedings of the Cambridge Philosophical Society, 35, pp 416-418 \u0026lt;10.1017/S0305004100021162\u0026gt;  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210223135036-org_mode/",
                "title": "Org Mode",
                "section": "post",
                "date" : "2021.03.10",
                "body": "メモや論文など書くこと全般に使える Emacs のメジャーモード。Org-Roam を使うと、Roam Research 的なスマートノートを作ることができる。このノート上には Anki のカードも定義できるので、スマートノートと SRS をスムーズに組み合わせることができる。そのほか、文芸的プログラミングをサポートしているので、Emacs の設定ファイルを Org のドキュメントから生成できる。\nOrg mode for Emacs\nOrg のインライン記法  強調 **強調** 斜体 /斜体/ 下線 _下線_ 打ち消し +打ち消し+ verbatim =verbatim= inline code ~inline code~  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210310093010-%E6%96%87%E8%8A%B8%E7%9A%84%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF/",
                "title": "文芸的プログラミング",
                "section": "post",
                "date" : "2021.03.10",
                "body": "Donald E. Knuth が提唱したプログラミング手法の一つで、テキストファイル内にドキュメントとコードを埋めこみ、これから完全なドキュメントとコンパイル可能なソースコードを生成する方法。驚くことに TeX はこの方法で書かれていて、生成されたドキュメントは本として出版されている (TeX: The Program)。\nTeX 以外に実用的なソフトウェアで文芸的プログラミングを採用した例は見当たらないが、最近では Org ファイルから Emacs や Bash などの設定ドキュメントとドットファイルを生成するという限定的な用途で文芸的プログラミングが使われている。\n極端な例では、Org-Mode 内で論文を書く際に、本文だけでなくテーブルやグラフなど論文の構成要素をすべて生成するという Reproducible Research という手法もある。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210228111127-how_to_take_smart_notes/",
                "title": "How to Take Smart Notes",
                "section": "post",
                "date" : "2021.03.03",
                "body": " How to Take Smart Notes (Scribd) How to Take Smart Notes (Amazon)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210303105204-powers_of_10_time_scales_in_user_experience/",
                "title": "Powers of 10: Time Scales in User Experience",
                "section": "post",
                "date" : "2021.03.03",
                "body": "Powers of 10: Time Scales in User Experience\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210303082924-%E3%81%99%E3%81%B8%E3%81%A6%E3%81%AE%E7%9F%A5%E7%9A%84%E5%8A%AA%E5%8A%9B%E3%81%AF%E3%83%A1%E3%83%A2%E3%81%8B%E3%82%89/",
                "title": "すべての知的努力はメモから",
                "section": "post",
                "date" : "2021.03.03",
                "body": "学習、勉強、研究、小説などあらゆる種類の知的活動や創作は、すべてメモを取ることから始まる。書くことについての話題となると、論文や小説といった「書きかけの作品」をいかに完成させるかという議論になりやすい。しかし、これらは「書く」という活動から見ればどれも例外的な瞬間にすぎない。書くことの大部分を占めるのは日常的なメモ書きであり、論文や小説などといった長い作品はメモを書く作業の積み重ねによって生まれる。\n文章を書くプロセスは、真っ白な画面よりもはるかに早い段階から始まっていて、実際に議論を書き留めることは、全体のプロセスの中では最小の部分である。\n参考文献  How to Take Smart Notes  関連ノート  保存版メモの数  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210303103710-%E7%9B%B4%E6%84%9F%E6%80%A7%E3%81%A8%E5%BF%9C%E7%AD%94%E6%99%82%E9%96%93/",
                "title": "直感性と応答時間",
                "section": "post",
                "date" : "2021.03.03",
                "body": "ライブプログラミング環境の直感性は、応答時間に大きく依存する。ユーザビリティ研究で有名な Jakob Nielsen の記事 \u0026ldquo;Powers of 10: Time Scales in User Experience\u0026rdquo; によると、ユーザーが何かを操作してから結果が返るまでの応答時間と、ユーザが感じる直感性の関係には、次の一般的な指標がある。\n 応答時間 0.1 秒未満 操作が直感的だと感じる。ユーザは自分の行動が直接画面上で何かを引き起したという「直接操作」という錯覚を感じ、操作に集中できる。 応答時間 0.1 〜 1 秒 直感性がやや失われる。ユーザはコンピュータ側で何らかの処理が発生していることに気付き、処理を待つ間に集中力を失いはじめる。 応答時間 1 秒以上 直感性がなくなる。ユーザは反応が遅すぎると感じ、操作をためらうようになる。また、目の前の問題への集中力を完全に失う。  つまり直感性のためには、0.1 秒以内の応答時間を達成する必要がある。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210303084450-%E7%9C%9F%E3%81%A3%E7%99%BD%E3%81%AA%E7%94%BB%E9%9D%A2/",
                "title": "真っ白な画面",
                "section": "post",
                "date" : "2021.03.03",
                "body": "論文や小説などを書くときには何もないところから始めるという誤った考えかた。ほとんどの文章指南本や自己啓発本はこれを前提にしており、締切の間に合わせかたやその他心理的テクニックなどに終始している (やる気の出しかた、締切との向き合いかた etc.)。そうではなく、すべての知的努力はメモから始まることを理解していて、普段からスマートメモを取っていれば、そもそも真っ白な画面にぶつかることはない。\n参考文献  How to Take Smart Notes  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210303094727-%E9%87%8F%E5%AD%90%E3%82%B3%E3%83%B3%E3%83%92%E3%83%A5%E3%83%BC%E3%82%BF/",
                "title": "量子コンピュータ",
                "section": "post",
                "date" : "2021.03.03",
                "body": "量子コンピュータは量子力学に基いた新しいタイプのコンピュータである。線形重ね合わせのできる量子ビットを量子ゲートで操作し、量子ビットを測定することで計算結果が得られる。特定の問題について従来のコンピュータより高速に計算できることが知られており、実際、フーリエ変換、素因数分解、データ探索、位相推定をはじめとした量子コンピュータ向けのアルゴリズムが多数存在する (Quantum Algorithm Zoo)。\nこうした線形重ね合わせや測定は量子コンピュータ特有の操作であり，従来の開発者にとっては直感的でないという問題がある．そのため，試行錯誤を容易に行える直感的な量子プログラミング環境の構築が重要である。\n参考文献  Quantum Computation and Quantum Information Thinking Too Classically: Research Topics in Human-Quantum Computer Interaction  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302131638-andy_matuschak/",
                "title": "Andy Matuschak",
                "section": "post",
                "date" : "2021.03.02",
                "body": "Andyʼs working notes\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302115454-api_%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%88%E3%83%AB/",
                "title": "API としてのタイトル",
                "section": "post",
                "date" : "2021.03.02",
                "body": "エバーグリーンノートのタイトル付けは API 設計によく似ている。\n 単機能にする (例: Object#inspect) キャッチーな名詞にする (例: \u0026ldquo;囚人のジレンマ\u0026rdquo;、\u0026ldquo;割れ窓理論\u0026rdquo;) 一発で決まらない時は、時間とともに改善 (リファクタリング)  参考文献  Evergreen note titles are like APIs  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302122859-bret_victor/",
                "title": "Bret Victor",
                "section": "post",
                "date" : "2021.03.02",
                "body": " 本人のサイト  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302155222-execute_program/",
                "title": "Execute Program",
                "section": "post",
                "date" : "2021.03.02",
                "body": "https://www.executeprogram.com/\n間隔反復記憶システム (SRMS) で JavaScript などの API を学習できるサービス。SRMS が外国語学習だけでなく API の習得にも有効なのは、Michael Nielsen の Augmenting Long-term Memory でも実証されていることである。\nビジネス的には、SRMS は長期 (数年〜) に渡って使うものなので、こういうサービスは個人利用であっても契約期間が長くなる → 収益化しやすい、と予想できる。\n使ってみた感想として、回答では必ずキー入力を求められるので、Anki のようにサクサク進められず、レビューセッションを始める前の心理的バリアが少し高いと感じた。キー入力が必要な要因として、問題と回答がアトミックな質問と答になっていないことが考えられる。\nキー入力を使わない SRMS でプログラミング API を習得することは可能だろうか？ Execute Program の問題を SRMS に起こし、自分を実験台にして確認してみる。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302123555-%E3%82%A2%E3%83%88%E3%83%9F%E3%83%83%E3%82%AF%E3%81%AA%E8%B3%AA%E5%95%8F%E3%81%A8%E7%AD%94/",
                "title": "アトミックな質問と答",
                "section": "post",
                "date" : "2021.03.02",
                "body": "Anki のカードを作るときは、問題と答がたった一つの概念を表すようになるまで、つまりそれ以上分けられない単位 (=アトミック) まで分解する。\nたとえば次の Anki カードがあった場合、\n 問題: Unix でリンク名からファイル名へのソフトリンクを作るには? 答: ln -s ファイル名 リンク名  これは次の 2 つのカードに分割できる:\n  問題: Unix ソフトリンクを作るための基本的コマンドとオプションは?\n  答: ln -s\n  問題: Unix ソフトリンクを作る時、リンク名とファイル名を指定する順番は?\n  答: ファイル名 リンク名\n  このようにすると、覚えやすくなり正解率も上がる。答も短くなるため、レビューがテンポ良く進むという利点もある。\nもし間違えた場合でも、ミスをした箇所は明らかなため次からは間違えにくい。一方で、2 つ以上の要素が入ったアトミックでない問題で間違えた場合、ミスをした箇所がはっきりしないため、何度も間違えることが多い。\n日常的に問題をアトミックに分割する癖を付けておくことは、学んだ事柄ひとつひとつを鋭く結晶化してくれる。手間はかかるが、それだけの価値はある。\n注: アトミックな問題に分割した時、元のカードも取っておいたほうが良い。一つ上のレベルの問題として使える場合があるから。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302115056-%E3%82%A2%E3%83%88%E3%83%9F%E3%83%83%E3%82%AF_%E3%82%BF%E3%82%A4%E3%83%88%E3%83%AB/",
                "title": "アトミック・タイトル",
                "section": "post",
                "date" : "2021.03.02",
                "body": "エバーグリーンノートのタイトルは、それ以上分割できない概念を名詞で表したもの (例: \u0026ldquo;囚人のジレンマ\u0026rdquo;、\u0026ldquo;割れ窓理論\u0026rdquo; etc.) にする。\nこれをアトミック・タイトルと呼ぶ。アトミック・タイトルはノート内からリンクを貼りやすく、覚えやすい。また一言で言えるので、複雑な概念を表す \u0026ldquo;ハンドル\u0026rdquo; として便利 (API としてのタイトル)。\nタイトルがアトミック・タイトルかどうかは、少ない語の名詞になっているかどうかが良い判断基準になると思う。\n参考文献  Evergreen notes should be atomic  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302120815-%E3%83%A6%E3%83%8B%E3%82%BF%E3%83%AA%E8%A1%8C%E5%88%97/",
                "title": "ユニタリ行列",
                "section": "post",
                "date" : "2021.03.02",
                "body": "ユニタリ行列は \\(A^{\\dagger} = A^{-1}\\) を満たす行列 \\(A\\)\n直交行列 \\({}^tA = A^{-1}\\) の複素数版。\n参考文献  正規行列の対角化可能性  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302145631-%E3%83%A9%E3%82%A4%E3%83%86%E3%82%A3%E3%83%B3%E3%82%AF_%E3%82%A4%E3%83%B3%E3%83%9B%E3%83%83%E3%82%AF%E3%82%B9/",
                "title": "ライティング・インボックス",
                "section": "post",
                "date" : "2021.03.02",
                "body": "保存版メモの作業場所としてライティング・インボックスを持っておく。一時的なメモや書きかけのメモは何でも、このインボックスにつっこむ。書きかけがすべてが入っているので、ライティング・インボックスは今までの洞察を蓄積した容れ物だと考えることができる。\nこのインボックスを漁ることで、次にとりかかるメモを決め、いつでも続きを書きはじめることができる。インボックスの中で保存版メモを仕上げ、アトミック・タイトルをつけ保存版メモとして保存する。つまらないメモはアーカイブする。\nOrg-Mode での実装 現在は、TODO アイテムに writing タグを付けることでライティング・インボックスを実装している。 練りあげてできあがった保存版メモは、Org-Roam の独立したノートを作ってそこに保存する。\n参考文献  My morning writing practice by Andy Matuschak  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302122628-%E3%83%A9%E3%82%A4%E3%83%95%E3%83%95%E3%83%AD%E3%82%AF%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%AF/",
                "title": "ライブプログラミング",
                "section": "post",
                "date" : "2021.03.02",
                "body": "ライブプログラミングとは、プログラムの実行時の情報を参照しながらコーディングできるようにするインタラクションデザインの一種。\n従来の開発環境では、プログラマはソースコード (死んだ状態) を編集しながら実行時 (生きた状態) を頭の中でエミュレーションする必要があった。一方ライブプログラミングでは、開発環境が提示する生きたプログラムの状態を確認しながらソースコードを直感的に編集できる。\nライブプログラミング環境は、頭の中だけでは想像しにくい、抽象的な記号操作をメインとするシステムの理解や開発に有効である。\n Bret Victor らの Interactive Exploration of a Dynamic System では、微分方程式の初期値やパラメータを変えながら結果をインタラクティブに確認できる。 機械学習分野でユーザの多い Jupyter Notebook は文芸的プログラミングとライブプログラミングの組み合わせである。ドキュメント内に埋め込んだソースコードの実行結果をグラフなどに可視化することで，機械学習アルゴリズムの直感的理解を支援する。 量子コンピュータも非常に複雑なシステムの一種であり、直感的には理解しづらい量子プログラミングのためのライブプログラミング環境がいくつか提案されてきた (Quirk, Davy Wybiral の量子回路シミュレータ)。  このように、ライブプログラミングは具体的なモデリング、シミュレーション、可視化をベースにした新しい実践の形を提供する。\n参考文献  Live Programming について (LIVE 2017 で基調講演します)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210302120102-%E4%BF%9D%E5%AD%98%E7%89%88%E3%83%A1%E3%83%A2%E3%81%AE%E6%95%B0/",
                "title": "保存版メモの数",
                "section": "post",
                "date" : "2021.03.02",
                "body": "一日に書いた保存版メモの数\u0026quot; が、研究者の生産性指標として使える。たとえば、毎日コンスタントに 5 〜 10 個の保存版メモを書いている人は、かなり生産的である。\n保存版メモを書かなければ、せっかくの読書のほとんどが無駄になってしまう。保存版メモを書くことは、読書に役立つだけでなくそれ自体が利益になる。たとえば、洞察力を育む、執筆そのものを加速する、など。つまり「書くことは考えること」。\n自分はどのくらい一日に書いているだろうか? どのようにすれば計測できるだろうか?\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210301083537-ox_hugo/",
                "title": "Ox-Hugo",
                "section": "post",
                "date" : "2021.03.01",
                "body": "Org-Mode のファイルを Hugo 形式の Markdown に変換するためのプラグイン。\n保存版メモをまとめてエクスポート 次の関数を使って \u0026quot;permanent notes\u0026quot; とタグのついた Org-Roam の保存版ノートを Markdown に一括エクスポートできる。\n(after! (org org-roam) (defun my/org-roam-export-all () \u0026#34;Re-exports all Org-roam files to Hugo markdown.\u0026#34; (interactive) (dolist (f (org-roam--list-all-files)) (with-current-buffer (find-file f) (when (s-contains? \u0026#34;permanent notes\u0026#34; (buffer-string)) (org-hugo-export-wim-to-md)))))) 参考文献  Ox-Hugo (GitHub)  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210301113146-%E5%AF%BE%E8%A7%92%E5%8C%96/",
                "title": "対角化",
                "section": "post",
                "date" : "2021.03.01",
                "body": "ある行列 \\(A\\) を正則行列 \\(P\\) によって相似変換して結果を対角行列にすること。 あるいは、そのような行列 \\(P\\) を見つけること\n\\[P^{-1}AP = \\begin{bmatrix} a^{\\prime}_{11} \u0026amp; 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \\\\\\\n0 \u0026amp; a^{\\prime}_{22} \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \\\\\\\n0 \u0026amp; 0 \u0026amp; \\ddots \u0026amp; \u0026amp; 0 \\\\\\\n\\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\ddots \u0026amp; 0 \\\\\\\n0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \u0026amp; a^{\\prime}_{nn} \\end{bmatrix}\\]\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210301112911-%E6%AD%A3%E5%89%87%E8%A1%8C%E5%88%97/",
                "title": "正則行列",
                "section": "post",
                "date" : "2021.03.01",
                "body": "\\(n\\) 次正方行列 \\(A\\) について、\n\\[AB = BA = I\\]\nとなる \\(n\\) 次正方行列 \\(B\\) が存在するとき、\\(A\\) は正則行列という。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210228145035-hugo/",
                "title": "Hugo",
                "section": "post",
                "date" : "2021.02.28",
                "body": "Markdown で静的サイトを作るためのツール。Ox-Hugo を使って、Org-Roam の .org ファイルから自動的に yasuhito.github.io を生成する。\nHugo 公式サイト\n.org ファイルの設定 .org ファイルの冒頭で #+SETUPFILE: setup.org を指定し setup.org には次の Hugo 共通設定を入れておく。\n#+HUGO_BASE_DIR: ~/Documents/Zettel #+HUGO_SECTION: ./posts/ テーマ Mathjax が始めから入っている cactus をとりあえず使っている。\n https://github.com/monkeyWzr/hugo-theme-cactus  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210228110804-toeic_l_r_test_%E5%87%BA%E3%82%8B%E5%8D%98%E7%89%B9%E6%80%A5_%E9%87%91%E3%81%AE%E3%83%95%E3%83%AC%E3%83%BC%E3%82%B9/",
                "title": "TOEIC L \u0026 R TEST 出る単特急 金のフレーズ",
                "section": "post",
                "date" : "2021.02.28",
                "body": "Amazon\nAnki カード作りの研究用に買ってみた。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210224084353-%E5%9F%BA%E5%BA%95%E7%8A%B6%E6%85%8B/",
                "title": "基底状態",
                "section": "post",
                "date" : "2021.02.24",
                "body": "\\(|0\\rangle\\) と \\(|1\\rangle\\) は基底状態と呼ばれ、古典コンピュータのビット 0 と 1 に対応する。数学的には、基底状態は状態ベクトル \\(|\\psi\\rangle\\) の正規直交基底を形成するベクトルであり、それぞれ次の列ベクトルで定義される。\n\\begin{equation} |0\\rangle := \\begin{bmatrix} 1 \\\\\\\n0 \\end{bmatrix}, |1\\rangle := \\begin{bmatrix} 0 \\\\\\\n1 \\end{bmatrix} \\end{equation}\nよって 1 量子ビットの状態 \\(|\\psi\\rangle\\) は、2次元複素ベクトル空間の単位ベクトルとして表現できる。\n\\begin{equation} |\\psi\\rangle = \\begin{bmatrix} \\alpha \\\\\\\n\\beta \\end{bmatrix} \\end{equation}\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210224083510-%E7%8A%B6%E6%85%8B%E3%83%98%E3%82%AF%E3%83%88%E3%83%AB/",
                "title": "状態ベクトル",
                "section": "post",
                "date" : "2021.02.24",
                "body": "量子コンピュータでは、情報を量子ビットとして表現する。量子ビットは、古典的なコンピュータでのビットに対応する。1つの量子ビットの任意の状態 \\(|\\psi\\rangle\\) は、ディラック記法を使って基底状態 \\(|0\\rangle\\) と \\(|1\\rangle\\) の重ね合わせ (線形結合) として次の式で表すことができる。\n\\[|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\]\nここで係数 \\(\\alpha, \\beta\\) を確率振幅と呼び \\(\\alpha, \\beta \\in \\mathbb{C}\\) である。また、正規化条件として \\(|\\alpha|^2 + |\\beta|^2 = 1\\) に従わなければならない。\n"
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210223123752-html_over_the_wire/",
                "title": "HTML Over the Wire",
                "section": "post",
                "date" : "2021.02.23",
                "body": "React や Vue.js などの Web プログラミングフレームワークでは、ネイティブアプリと同様の UX を提供するために処理の大半をブラウザ側で行う。サーバは HTML ではなくデータを JSON として返す API/GraphQL サーバーとして動作し、HTML の生成はクライアントサイドのブラウザで動作する JavaScript フレームワーク上で行う。\nこれは、従来の Rails などのフレームワークと比較して複雑である。従来は、サーバ側で MVC フレームワークが動作し、データとプレゼンテーションを HTML としてサーバ側で生成し、ブラウザへ送っていた。一方で、近年の Web フレームワークはブラウザ上で MVC フレームワークが動作する。画面遷移を高速にするために、DOM ツリーの差分を取り、仮想 DOM という仕組みで最小の書き換えで画面遷移を実現する。\nしかし、従来の単純なフレームワークでもネイティブアプリと同等の UX を達成することは可能である。DOM のうち動的な部分のみ JavaScript で書き換える。画面遷移についても、マウスオーバー時のプリフェッチによってソースコードを変更せずに高速化が可能である。\nこのための代表的なフレームワークが HOTwire。元々 Turbolinks や Stimulus.js だったものをまとめたもの。HTML の data 属性を使うことで、JavaScript 部分と HTML を結合することができる。JavaScript 部分は、サーバ側の MVC 実装や HTML にほとんど染み出さない。\n参考文献  HTML over the wire  "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210223134834-org_roam/",
                "title": "Org-Roam",
                "section": "post",
                "date" : "2021.02.23",
                "body": "Org-Roam は Org Mode の上に構築された、Roam Research ライクなノート環境。\nクラウドへのバックアップ iCloud で同期すれば、ソフトウェアの追加インストールなしで iPhone や Mac と org ファイルを同期できる。とにかく手軽なので、なにか問題が出るまではしばらく iCloud でバックアップを取ることにする。\niCloud に org ディレクトリを作るには、iPhone に beorg をインストールするのが手っ取り早い。インストールすると iCloud Drive 上に beorg 用のディレクトリが作られるので、ここから ~/org にシンボリックリンクを張る。\ncd ~ ln -s ~/Library/Mobile\\ Documents/iCloud~com~appsonthemove~beorg/Documents/org org "
            }
        
    ,
        
            {
                "ref": "https://yasuhito.github.io/post/20210223212225-%E7%B7%9A%E5%BD%A2%E7%B5%90%E5%90%88/",
                "title": "線形結合",
                "section": "post",
                "date" : "2021.02.23",
                "body": "和演算とスカラー倍演算を組合わせることで、ベクトル \\(|v_1\\rangle\\) と \\(|v_2\\rangle\\) の線形結合を作ることができる。\\(|v_1\\rangle\\) に \\(c\\) を掛け、\\(|v_2\\rangle\\) に \\(d\\) を掛け、さらに和 \\(c|v_1\\rangle + d|v_2\\rangle\\) を求める。これが \\(|v_1\\rangle\\) と \\(|v_2\\rangle\\) の線形結合。\n"
            }
        
    
]