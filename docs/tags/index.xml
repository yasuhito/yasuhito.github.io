<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Tags on Notes</title>
		<link>https://yasuhito.github.io/tags/</link>
		<description>Recent content in Tags </description>
		<generator>Hugo -- gohugo.io</generator>
		
  		<language>ja</language>
		
		<managingEditor>Page(/tags) (Yasuhito Takamiya)</managingEditor>
    	
		<atom:link href="/tags/" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Anki</title>
			<link>https://yasuhito.github.io/post/20210319115727-anki/</link>
			<pubDate>Fri, 19 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210319115727-anki/</guid>
			<description>https://apps.ankiweb.net/
人気のある SRS の一種。</description>
		</item>
      	
		<item>
			<title>Duolingo</title>
			<link>https://yasuhito.github.io/post/20210319132742-duolingo/</link>
			<pubDate>Fri, 19 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210319132742-duolingo/</guid>
			<description>https://en.duolingo.com/
世界で最も人気のある外国語学習サービス。単語や文法の学習に SRS を採用している。
SRS として見たときの Duolingo のユニークな点 (たとえばExecute Program との違い) は、すべての学習がカードのみで完結しているところ。Execute Program ではプログラミング言語の解説を読みながらクイズに答えていく。一方で Duolingo では外国語に対する知識ゼロの状態からいきなりクイズが始まり、正解/不正解を繰り返しながら (試行錯誤を繰り返しながら) 外国語を学んでいくことができる。
外国語学習の場合、文法や単語の説明を読むのはダルい/集中力が続かないという人が圧倒的に多いはずなので、正式な学習法と比べてどのくらい効果があるかどうかは分からないが、ひとつの妥当なデザインチョイスだと思う。</description>
		</item>
      	
		<item>
			<title>SRS の回答方式による効果の違い</title>
			<link>https://yasuhito.github.io/post/20210319113717-srs_%E3%81%AE%E5%9B%9E%E7%AD%94%E6%96%B9%E5%BC%8F%E3%81%AB%E3%82%88%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%AE%E9%81%95%E3%81%84/</link>
			<pubDate>Fri, 19 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210319113717-srs_%E3%81%AE%E5%9B%9E%E7%AD%94%E6%96%B9%E5%BC%8F%E3%81%AB%E3%82%88%E3%82%8B%E5%8A%B9%E6%9E%9C%E3%81%AE%E9%81%95%E3%81%84/</guid>
			<description>SRS のユーザ回答方式には、Anki のようにユーザが裏面を見て自分で答合わせをする方式と、Duolingo や Execute Program のようにユーザが入力した答をシステムが答合わせする方式の 2 つがある。どちらが記憶効果が高いだろうか？
この論文 (Probabilistic Models of Student Learning and Forgetting) では実験から次のことを導き出している:
 ひとつひとつの単体のレビューの効果については、ユーザが入力する方式の方が効果が高い 長期的な効果については、入力のためのタイピングにはかなり時間がかかるため、自分で答合わせをする方式のほうがレビューを多くこなせ、結果的に効果が高くなる  </description>
		</item>
      	
		<item>
			<title>never</title>
			<link>https://yasuhito.github.io/post/20210318110047-never/</link>
			<pubDate>Thu, 18 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210318110047-never/</guid>
			<description>SRS の回答方式による効果の違いを確認するために、Execute Program のレッスン never を元に Anki カードを起こしてみる。作った Anki カードはこのノートの一番下にある。
 never の説明 関数の中には、決して戻らないものがあります。例えば、常に例外を投げる関数は決して戻りません。
function throws() { throw new Error(&amp;#39;oh no&amp;#39;); } この関数の戻り値の型はどうすればよいでしょうか？ TypeScript は、この関数の戻り値の型を void と推論します。しかし、それではコードで何が起こっているのかをコンパイラは完全には把握できていません。
void 型は、何らかの処理を行い終了するが、値を返さない関数のための型です。上の関数はこれとは異なり、この関数を呼び出しても、その後のコードは全く実行されません。
幸いなことに、TypeScript にはそのための型があります: never です。
function throws(): never { throw new Error(&amp;#39;oh no&amp;#39;); } never 型はちょっと不思議です。他のどの型にも割り当て可能です1。例えば、 number 型の変数に割り当てることができます。この関数は今までと同じく例外を投げますので、結果も同じです。
function throws(): never { throw new Error(&amp;#39;oh no&amp;#39;); } const n: number = throws(); // → Error: oh no 最初は、 never が any のように振る舞っているように見えます。なぜなら、 never を number （または string 、その他何でも）に割り当てることができるからです。しかし、 any と違って、これは安全です。</description>
		</item>
      	
		<item>
			<title>デジタル・ガーデン</title>
			<link>https://yasuhito.github.io/post/20210318171123-%E3%83%86%E3%82%B7%E3%82%BF%E3%83%AB_%E3%82%AB%E3%83%BC%E3%83%86%E3%83%B3/</link>
			<pubDate>Thu, 18 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210318171123-%E3%83%86%E3%82%B7%E3%82%BF%E3%83%AB_%E3%82%AB%E3%83%BC%E3%83%86%E3%83%B3/</guid>
			<description>個人的なメモをインターネット上に公開したもの。多くの場合はメモ間にリンクが貼ってあり、Wiki のように関連するメモを読むことができる。
一般的な作り方としては、Roam Research や Obsidian といった個人用のメモツールで書いたメモを外部ツールでインターネット上に公開する場合が多い。
 MaggieAppleton/digital-gardeners デジタル・ガーデン用ツール、作りかたチュートリアル、各種ノート法などの基礎知識、個別のデジタル・ガーデンサイトへのリンク集 Andyʼs working notes デジタル・ガーデン流行の火付け役となったサイトであり、多くの人がお手本にしている Andy Matuschak のサイト 効率的なノートを作成できるドイツの社会学者が生み出した方法「Zettelkasten」とは？ ノート法の一種で、多くのデジタル・ガーデンはこの方法に則って書かれている  </description>
		</item>
      	
		<item>
			<title>スカラー行列</title>
			<link>https://yasuhito.github.io/post/20210317113230-%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC%E8%A1%8C%E5%88%97/</link>
			<pubDate>Wed, 17 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210317113230-%E3%82%B9%E3%82%AB%E3%83%A9%E3%83%BC%E8%A1%8C%E5%88%97/</guid>
			<description>単位行列の定数倍をスカラー行列という。
たとえば、
\[\begin{bmatrix} \lambda &amp;amp; 0 &amp;amp; 0 \\\
0 &amp;amp; \lambda &amp;amp; 0 \\\
0 &amp;amp; 0 &amp;amp; \lambda \end{bmatrix}\]
はスカラー行列である。</description>
		</item>
      	
		<item>
			<title>対角行列</title>
			<link>https://yasuhito.github.io/post/20210317101558-%E5%AF%BE%E8%A7%92%E8%A1%8C%E5%88%97/</link>
			<pubDate>Wed, 17 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210317101558-%E5%AF%BE%E8%A7%92%E8%A1%8C%E5%88%97/</guid>
			<description>\(n\) 次正方行列で、その対角線上にない成分がすべて \(0\) である行列のこと。
\[\begin{bmatrix} 1 &amp;amp; 0 &amp;amp; 0 \\\
0 &amp;amp; 2 &amp;amp; 0 \\\
0 &amp;amp; 0 &amp;amp; -1 \end{bmatrix}\]
注意点として、行列の対角線は右下がりのもののみを言う。右上がりのものは対角線とは呼ばない。</description>
		</item>
      	
		<item>
			<title>正方行列</title>
			<link>https://yasuhito.github.io/post/20210317105154-%E6%AD%A3%E6%96%B9%E8%A1%8C%E5%88%97/</link>
			<pubDate>Wed, 17 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210317105154-%E6%AD%A3%E6%96%B9%E8%A1%8C%E5%88%97/</guid>
			<description>\(m \times m\) 行列は正方形状に成分が並ぶので \(m\) 次正方行列と呼ぶ。
\(2\) 次正方行列の例
\[\begin{bmatrix} 1 &amp;amp; 2 \\\
2 &amp;amp; -1 \end{bmatrix}\]
\(3\) 次正方行列の例
\[\begin{bmatrix} -1 &amp;amp; 2 &amp;amp; 3 \\\
1 &amp;amp; 1 &amp;amp; 0 \\\
2 &amp;amp; 0 &amp;amp; 1 \end{bmatrix}\]</description>
		</item>
      	
		<item>
			<title>ディラック記法</title>
			<link>https://yasuhito.github.io/post/20210311082809-%E3%83%86%E3%82%A3%E3%83%A9%E3%83%83%E3%82%AF%E8%A8%98%E6%B3%95/</link>
			<pubDate>Thu, 11 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210311082809-%E3%83%86%E3%82%A3%E3%83%A9%E3%83%83%E3%82%AF%E8%A8%98%E6%B3%95/</guid>
			<description>ディラック記法は、物理学者ポール・ディラックがとくに量子論を記述する目的で導入した記法。量子論のほとんどの教科書で今日でも使われている。
   名前 記号     ディラックのケット (ket) \(\vert{}\psi\rangle\)   ディラックのブラ (bra) \(\langle\pi\vert{}\)   ディラックのブラケット (braket) \(\langle\pi\vert{}\psi\rangle\)    Quantum Computation and Quantum Information によると、量子力学の難しさの原因はそれ自体が難しいというわけではなく、ディラック記法やそのほか物理学特有の記号がたくさんあることにあるようだ。
 量子力学の公理の理解を阻む主な要因は公理それ自体にあるのではなく、それを理解するのに必要な線形代数の表記法の多さにある。物理学者が量子力学に用いている見慣れない Dirac の表記法と相まって、それは (間違って) とても恐ろしい印象を与える。
    記号 意味     \(z^{\ast}\) 複素数 \(z\) の複素共役。\((1 + i)^{\ast} = 1 - i\)   \(\vert{}\psi\rangle\) ベクトル。ケット (ket) とも呼ばれる。   \(\langle\psi\vert{}\) \(\vert{}\psi\rangle\) に双対 (dual) なベクトル。ブラ (bra) とも呼ばれる   \(\langle\varphi\vert{}\psi\rangle\) \(\vert{}\varphi\rangle\) と \(\vert{}\psi\rangle\) の内積   \(\vert{}\varphi\rangle \otimes \vert{}\psi\rangle\) \(\vert{}\varphi\rangle\) と \(\vert{}\psi\rangle\) のテンソル積   \(\vert{}\varphi\rangle\vert{}\psi\rangle\) \(\vert{}\varphi\rangle\) と \(\vert{}\psi\rangle\) のテンソル積に対する簡略記号   \(A^{\ast}\) 行列 \(A\) の複素共役   \(A^T\) 行列 \(A\) の転置   \(A^{\dagger}\) 行列 \(A\) のエルミート共役、もしくは随伴。\(A^{\dagger} = (A^T)^{\ast}\)   \(\langle\varphi\vert{}A\vert{}\psi\rangle\) \(\vert{}\varphi\rangle\) と \(A\vert{}\psi\rangle\) の内積。\(A^{\dagger}\vert{}\varphi\rangle\) と \(\vert{}\psi\rangle\) の内積に等しい。    参考文献  P.</description>
		</item>
      	
		<item>
			<title>Org Mode</title>
			<link>https://yasuhito.github.io/post/20210223135036-org_mode/</link>
			<pubDate>Wed, 10 Mar 2021 00:00:00 +0900</pubDate>
			<guid>https://yasuhito.github.io/post/20210223135036-org_mode/</guid>
			<description>メモや論文など書くこと全般に使える Emacs のメジャーモード。Org-Roam を使うと、Roam Research 的なスマートノートを作ることができる。このノート上には Anki のカードも定義できるので、スマートノートと SRS をスムーズに組み合わせることができる。そのほか、文芸的プログラミングをサポートしているので、Emacs の設定ファイルを Org のドキュメントから生成できる。
Org mode for Emacs
Org のインライン記法  強調 **強調** 斜体 /斜体/ 下線 _下線_ 打ち消し +打ち消し+ verbatim =verbatim= inline code ~inline code~  </description>
		</item>
      	
	</channel>
</rss>
